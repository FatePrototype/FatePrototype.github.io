<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-10-25T03:24:46.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[Python解决用pip装第三方库慢的方法]]></title>
        <id>https://sakuratears.cn/post/python-jie-jue-yong-pip-zhuang-di-san-fang-ku-man-de-fang-fa/</id>
        <link href="https://sakuratears.cn/post/python-jie-jue-yong-pip-zhuang-di-san-fang-ku-man-de-fang-fa/">
        </link>
        <updated>2020-10-24T10:48:49.000Z</updated>
        <content type="html"><![CDATA[<p>由于政策原因使用pip(pycharm也是)装第三方库有时会很慢有时会失败，有条件的可以使用不可描述方法进行安装或者我们可以使用清华源镜像装库<br>
链接https://mirrors.tuna.tsinghua.edu.cn/help/pypi/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[KMP算法]]></title>
        <id>https://sakuratears.cn/post/kmp-suan-fa/</id>
        <link href="https://sakuratears.cn/post/kmp-suan-fa/">
        </link>
        <updated>2020-10-23T07:02:13.000Z</updated>
        <content type="html"><![CDATA[<p>本文转载自知乎“洛谷网校 阮行止”</p>
<p>网址：https://www.zhihu.com/question/21923021/answer/1032665486?utm_source=qq&amp;utm_medium=social&amp;utm_oi=952480495343259648</p>
<p>KMP算法是一种<strong>字符串匹配</strong>算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。本文将引导您学习KMP算法。</p>
<h4 id="字符串匹配问题">字符串匹配问题</h4>
<p>所谓字符串匹配，是这样一种问题：“字符串 P 是否为字符串 S 的子串？如果是，它出现在 S 的哪些位置？” 其中 S 称为<strong>主串</strong>；P 称为<strong>模式串</strong>。下面的图片展示了一个例子。</p>
<figure data-type="image" tabindex="1"><img src="https://pic4.zhimg.com/v2-2967e415f490e03a2a9400a92b185310_r.jpg?source=1940ef5c" alt="图" loading="lazy"></figure>
<p>主串是莎翁那句著名的 “to be or not to be”，这里删去了空格。“no” 这个模式串的匹配结果是“出现了一次，从S[6]开始”；“ob”这个模式串的匹配结果是“出现了两次，分别从s[1]、s[10]开始”。按惯例，主串和模式串都以0开始编号。<br>
　　字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。<br>
　　我们先从最朴素的Brute-Force算法开始讲起。</p>
<h4 id="brute-force">Brute-Force</h4>
<p>顾名思义，Brute-Force是一个纯暴力算法。说句题外话，我怀疑，“暴力”一词在算法领域表示“穷举、极低效率的实现”，可能就是源于这个英文词。<br>
　　首先，我们应该如何实现两个字符串 A,B 的比较？所谓<strong>字符串比较</strong>，就是问“两个字符串是否相等”。最朴素的思想，就是从前往后逐字符比较，一旦遇到不相同的字符，就返回False；如果两个字符串都结束了，仍然没有出现不对应的字符，则返回True。实现如下：<br>
<img src="https://pic2.zhimg.com/80/v2-f9a7d55f60e346529f70c409dfcda786_720w.jpg?source=1940ef5c" alt="图" loading="lazy"></p>
<p>既然我们可以知道“两个字符串是否相等”，那么最朴素的字符串匹配算法 Brute-Force 就呼之欲出了——<br>
· 枚举 i = 0, 1, 2 ... , len(S)-len(P)<br>
· 将 S[i : i+len(P)] 与 P 作比较。如果一致，则找到了一个匹配。</p>
<p>现在我们来模拟 Brute-Force 算法，对主串 “AAAAAABC” 和模式串 “AAAB” 做匹配：<br>
<img src="https://pic3.zhimg.com/80/v2-1892c7f6bee02e0fc7baf22aaef7151f_720w.jpg?source=1940ef5c" alt="图" loading="lazy"><br>
这是一个清晰明了的算法，实现也极其简单。下面给出Python和C++的实现：<br>
<img src="https://pic4.zhimg.com/80/v2-36589bc0279263ec8641a295aea66a0c_720w.jpg?source=1940ef5c" alt="图" loading="lazy"><br>
<img src="https://pic4.zhimg.com/80/v2-ed28c8d60516720cc38c48d135091a58_720w.jpg?source=1940ef5c" alt="图" loading="lazy"></p>
<p>我们成功实现了 Brute-Force 算法。现在，我们需要对它的时间复杂度做一点讨论。按照惯例，记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。<br>
　　考虑“字符串比较”这个小任务的复杂度。最坏情况发生在：两个字符串唯一的差别在最后一个字符。这种情况下，字符串比较必须走完整个字符串，才能给出结果，因此复杂度是 O(len) 的。</p>
<p>由此，不难想到 Brute-Force 算法所面对的最坏情况：主串形如“AAAAAAAAAAA...B”，而模式串形如“AAAAA...B”。每次字符串比较都需要付出 |P| 次字符比较的代价，总共需要比较 |S| - |P| + 1次，因此总时间复杂度是  <img src="https://www.zhihu.com/equation?tex=O%28%7CP%7C%5Ccdot+%28%7CS%7C+-+%7CP%7C+%2B+1%29+%29" alt="[公式]" loading="lazy"> . 考虑到主串一般比模式串长很多，故 Brute-Force 的复杂度是 <img src="https://www.zhihu.com/equation?tex=O%28%7CP%7C+%5Ccdot+%7CS%7C%29" alt="[公式]" loading="lazy"> ，也就是 O(nm)的。这太慢了！</p>
<h4 id="brute-force的改进思路">Brute-Force的改进思路</h4>
<p>经过刚刚的分析，您已经看到，Brute-Force 慢得像爬一样。它最坏的情况如下图所示：<br>
<img src="https://pic4.zhimg.com/80/v2-4fe5612ff13a6286e1a8e50a0b06cd96_720w.jpg?source=1940ef5c" alt="图" loading="lazy"></p>
<p>我们很难降低字符串比较的复杂度（因为比较两个字符串，真的只能逐个比较字符）。因此，我们考虑<strong>降低比较的趟数</strong>。如果比较的趟数能降到足够低，那么总的复杂度也将会下降很多。　　要优化一个算法，首先要回答的问题是“我手上有什么信息？”　我们手上的信息是否足够、是否有效，决定了我们能把算法优化到何种程度。请记住：<strong>尽可能利用残余的信息，是KMP算法的思想所在</strong>。<br>
　　在 Brute-Force 中，如果从 S[i] 开始的那一趟比较失败了，算法会直接开始尝试从 S[i+1] 开始比较。这种行为，属于典型的“没有从之前的错误中学到东西”。我们应当注意到，一次失败的匹配，会给我们提供宝贵的信息——如果 S[i : i+len(P)] 与 P 的匹配是在第 r 个位置失败的，那么从 S[i] 开始的 (r-1) 个连续字符，一定与 P 的前 (r-1) 个字符一模一样！</p>
<figure data-type="image" tabindex="2"><img src="https://pic2.zhimg.com/80/v2-7dc61b0836af61e302d9474eeeecfe83_720w.jpg?source=1940ef5c" alt="图" loading="lazy"></figure>
<p>需要实现的任务是“字符串匹配”，而每一次失败都会给我们换来一些信息——能告诉我们，主串的某一个子串等于模式串的某一个前缀。但是这又有什么用呢？</p>
<h4 id="跳过不可能成功的字符串比较">跳过不可能成功的字符串比较</h4>
<p>有些趟字符串比较是有可能会成功的；有些则毫无可能。我们刚刚提到过，优化 Brute-Force 的路线是“尽量减少比较的趟数”，而如果我们跳过那些<strong>绝不可能成功的</strong>字符串比较，则可以希望复杂度降低到能接受的范围。<br>
　　那么，哪些字符串比较是不可能成功的？来看一个例子。已知信息如下：</p>
<ul>
<li>模式串 P = &quot;abcabd&quot;.</li>
<li>和主串从S[0]开始匹配时，在 P[5] 处失配。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://pic4.zhimg.com/50/v2-372dc6c567ba53a1e4559fdb0cb6b206_hd.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>首先，利用上一节的结论。既然是在 P[5] 失配的，那么说明 S[0:5] 等于 P[0:5]，即&quot;abcab&quot;. 现在我们来考虑：从 S[1]、S[2]、S[3] 开始的匹配尝试，有没有可能成功？<br>
　　从 S[1] 开始肯定没办法成功，因为 S[1] = P[1] = 'b'，和 P[0] 并不相等。从 S[2] 开始也是没戏的，因为 S[2] = P[2] = 'c'，并不等于P[0]. 但是从 S[3] 开始是有可能成功的——至少按照已知的信息，我们推不出矛盾。</p>
<figure data-type="image" tabindex="4"><img src="https://pic4.zhimg.com/50/v2-67dd66b86323d3d08f976589cf712a1a_hd.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>带着“跳过不可能成功的尝试”的思想，我们来看next数组。</p>
<h4 id="next数组">next数组</h4>
<p>next数组是对于模式串而言的。P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i] 这一个子串，使得 <strong>前k个字符</strong>恰等于<strong>后k个字符</strong> 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。</p>
<figure data-type="image" tabindex="5"><img src="https://pic2.zhimg.com/80/v2-49c7168b5184cc1744459f325e426a4a_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>上图给出了一个例子。P=&quot;abcabd&quot;时，next[4]=2，这是因为P[0] ~ P[4] 这个子串是&quot;abcab&quot;，前两个字符与后两个字符相等，因此next[4]取2. 而next[5]=0，是因为&quot;abcabd&quot;找不到前缀与后缀相同，因此只能取0.</p>
<p>如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是<strong>每次失配之后，移很多位</strong>，跳过那些不可能匹配成功的位置。但是该如何确定要移多少位呢？</p>
<figure data-type="image" tabindex="6"><img src="https://pic4.zhimg.com/80/v2-d6c6d433813595dce5aad08b40dc0b72_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>在 S[0] 尝试匹配，失配于 S[3] &lt;=&gt; P[3] 之后，我们直接把模式串往右移了两位，让 S[3] 对准 P[1]. 接着继续匹配，失配于 S[8] &lt;=&gt; P[6], 接下来我们把 P 往右平移了三位，把 S[8] 对准 P[3]. 此后继续匹配直到成功。<br>
　　我们应该如何移动这把标尺？<strong>很明显，如图中蓝色箭头所示，旧的后缀要与新的前缀一致</strong>（如果不一致，那就肯定没法匹配上了）！</p>
<p>回忆next数组的性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，<strong>前next[r-1]个字符恰好和后next[r-1]个字符相等</strong>——也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去！<br>
　　您可以验证一下上面的匹配例子：P[3]失配后，把P[next[3-1]]也就是P[1]对准了主串刚刚失配的那一位；P[6]失配后，把P[next[6-1]]也就是P[3]对准了主串刚刚失配的那一位。</p>
<figure data-type="image" tabindex="7"><img src="https://pic2.zhimg.com/80/v2-6ddb50d021e9fa660b5add8ea225383a_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，<strong>其长度为next[右端]</strong>. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，<strong>next数组为我们如何移动标尺提供了依据</strong>。接下来，我们实现这个优化的算法。</p>
<h4 id="利用next数组进行匹配">利用next数组进行匹配</h4>
<p>了解了利用next数组加速字符串匹配的原理，我们接下来代码实现之。分为两个部分：建立next数组、利用next数组进行匹配。<br>
　　首先是建立next数组。我们暂且用最朴素的做法，以后再回来优化：</p>
<p><img src="https://pic1.zhimg.com/50/v2-1dda8f33e5847449cd9784e76e972cab_hd.jpg?source=1940ef5c" alt="img" loading="lazy"><img src="https://pic1.zhimg.com/80/v2-1dda8f33e5847449cd9784e76e972cab_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></p>
<p>如上图代码所示，直接根据next数组的定义来建立next数组。不难发现它的复杂度是 <img src="https://www.zhihu.com/equation?tex=O%28m%5E2%29" alt="[公式]" loading="lazy"> 的。<br>
　　接下来，实现利用next数组加速字符串匹配。代码如下：</p>
<figure data-type="image" tabindex="8"><img src="https://pic2.zhimg.com/50/v2-a6bd81af7cf9bbda32b2cfb0e4858276_hd.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>如何分析这个字符串匹配的复杂度呢？乍一看，pos值可能不停地变成next[pos-1]，代价会很高；但我们使用摊还分析，显然pos值一共顶多自增len(S)次，因此pos值减少的次数不会高于len(S)次。由此，复杂度是可以接受的，不难分析出整个匹配算法的时间复杂度：O(n+m).</p>
<h4 id="快速求next数组">快速求next数组</h4>
<p>终于来到了我们最后一个问题——如何快速构建next数组。<br>
　　首先说一句：快速构建next数组，是KMP算法的精髓所在，核心思想是“<strong>P自己与自己做匹配</strong>”。<br>
　　为什么这样说呢？回顾next数组的完整定义：</p>
<ul>
<li>定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。</li>
<li>next[x] 定义为： P[0]~P[x] 这一段字符串，使得<strong>k-前缀恰等于k-后缀</strong>的最大的k.</li>
</ul>
<p>这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], ... next[x-1]均已知，那么如何求出 next[x] 呢？</p>
<p>来分情况讨论。首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1. 图示如下。</p>
<figure data-type="image" tabindex="9"><img src="https://pic3.zhimg.com/80/v2-6d6a40331cd9e44bfccd27ac5a764618_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>刚刚解决了 P[x] = P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？</p>
<figure data-type="image" tabindex="10"><img src="https://pic1.zhimg.com/80/v2-ce1d46a1e3603b07a13789b6ece6022f_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>如图。长度为 now 的子串 A 和子串 B 是 P[0]~P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该<strong>缩短这个now</strong>，把它改成小一点的值，再来试试 P[x] 是否等于 P[now].<br>
　　now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]~P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 <strong>A的k-前缀</strong>等于<strong>B的k-后缀</strong> 的最大的k.<br>
　　您应该已经注意到了一个非常强的性质——<strong>串A和串B是相同的</strong>！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！</p>
<figure data-type="image" tabindex="11"><img src="https://pic2.zhimg.com/80/v2-c5ff4faaab9c3e13690deb86d8d17d71_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></figure>
<p>来看上面的例子。当P[now]与P[x]不相等的时候，我们需要缩小now——把now变成next[now-1]，直到P[now]=P[x]为止。P[now]=P[x]时，就可以直接向右扩展了。</p>
<p>代码实现如下：</p>
<p><img src="https://pic4.zhimg.com/50/v2-010a582b0c92a92044c43a2a2ea88928_hd.jpg?source=1940ef5c" alt="img" loading="lazy"><img src="https://pic4.zhimg.com/80/v2-010a582b0c92a92044c43a2a2ea88928_720w.jpg?source=1940ef5c" alt="img" loading="lazy"></p>
<p>应用摊还分析，不难证明构建next数组的时间复杂度是O(m)的。至此，我们以O(n+m)的时间复杂度，实现了构建next数组、利用next数组进行字符串匹配。</p>
<p>以上就是KMP算法。它于1977年被提出，全称 Knuth–Morris–Pratt 算法。让我们记住前辈们的名字：<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>(K), <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/James_H._Morris">James H. Morris</a>(M), <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Vaughan_Pratt">Vaughan Pratt</a>(P).</p>
<p>作者：阮行止<br>
链接：https://www.zhihu.com/question/21923021/answer/1032665486<br>
来源：知乎</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[希尔排序]]></title>
        <id>https://sakuratears.cn/post/xi-er-pai-xu/</id>
        <link href="https://sakuratears.cn/post/xi-er-pai-xu/">
        </link>
        <updated>2020-10-23T07:00:09.000Z</updated>
        <content type="html"><![CDATA[<p>为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。<br>
对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要№1次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p>
<p>实现希尔排序的一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插人排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插人排序但使用不同增量的过程。</p>
<p>希尔排序为插入排序高级版，先把几个部分的数组用插入排序排好，然后再把这几个分散数组排序成有序数组。<br>
确定一个增量h（h可以是数组总长/3 or /2），每次循环完增量变小直到为1，每次把分散的数组整合成一个大的有序数组，直到增量为1时，整个数组排序完成。</p>
<pre><code class="language-C/C++">void shellsort(int a[], int m)
{
    int h = m / 2; //确定增量h
    for (h; h &gt;= 1; h /= 2) //每次增量变小
    {
        for (int i = h; i &lt; m; i += h)
        {
            for (int j = i; j &gt;= 0 &amp;&amp; j - h &gt;= 0 &amp;&amp; a[j] &lt; a[j - h]; j -= h)
            {
                int temp = a[j];
                a[j] = a[j - h];
                a[j - h] = temp;
            }
        }
    }

    for (int i = 0; i &lt; m; i++)
    {
        cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[快速排序]]></title>
        <id>https://sakuratears.cn/post/kuai-su-pai-xu/</id>
        <link href="https://sakuratears.cn/post/kuai-su-pai-xu/">
        </link>
        <updated>2020-10-23T06:59:36.000Z</updated>
        <content type="html"><![CDATA[<p>快速排序的特点是他是原地排序（只需要一个很小的辅助栈），且长度为N的数组时间复杂度为NlgN。<br>
快速排序是一种分治的算法，他将一个数组分成两个数组，将两部分独立排序，在快排中切分的位置取决于数组的内容。<br>
取首元素为切分元素，比切分元素小的放到左边，比切分元素大的放到右边，再把两个数组切分，最后有序<br>
<img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201015164728.jpg" alt="图" loading="lazy"></p>
<pre><code class="language-C/C++">void qsort(int a[], int lo, int hi)
{
    if (lo &gt;= hi)
        return;
    int i, j, m, temp, mid;
    m = a[lo]; //切分元素
    i = lo; //下面循环时i和j就会先自增/自减1再判断，所以i为头元素，j为尾元素 - 1
    j = hi + 1;
    while (true)
    {
        while (a[++i] &lt; m)
        {
            if (i == hi)//直到循环到右边界也没有找到比切分元素大的元素
                break;
        }
        while (a[--j] &gt; m)
        {
            if (j == lo)//直到循环到左边界也没有找到比切分元素小的元素
                break;
        }
        if (i &gt;= j)//当i的位置在j的右边，a[i] &gt; a[j],不可以交换
            break;
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    temp = a[lo];
    a[lo] = a[j];
    a[j] = temp;
    mid = j;
    qsort(a, lo, mid - 1);
    qsort(a, mid + 1, hi);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[归并排序]]></title>
        <id>https://sakuratears.cn/post/gui-bing-pai-xu/</id>
        <link href="https://sakuratears.cn/post/gui-bing-pai-xu/">
        </link>
        <updated>2020-10-23T06:57:28.000Z</updated>
        <content type="html"><![CDATA[<p>归并排序将两个有序的排列归并为一个有序的排列。</p>
<p>归并算法都基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来：你将会看到，归并排序最<br>
吸引人的性质是它能够保证将任意长度为，的数组排序所需时间和，成正比；它的主要缺点则是它所需的额外空间。简单的归并排序如图所示。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_6xnNTxUAow.png" alt="图" loading="lazy"></figure>
<h4 id="原地归并">原地归并</h4>
<p>先创建一个数组aux将a的元素全部赋给aux。然后开始将两个有序的数组归并成一个有序的数组。<br>
将a[lo, mid]和a[mid + 1, hi]两个有序数组归并为一个有序数组<br>
<img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_1FWin67kuQ.png" alt="图" loading="lazy"></p>
<pre><code class="language-C/C++">void merge(int a[], int lo, int mid, int hi)
{
    int i, j;
    i = lo;
    j = mid + 1;
    int aux[hi + 1];
    for (int k = lo; k &lt;= hi; k++)
    {
        aux[k] = a[k];
    }
    for (int k = lo; k &lt;= hi; k++)
    {
        if (i &gt; mid)
        {
            a[k] = aux[j++];
        }
        else if (j &gt; hi)
        {
            a[k] = aux[i++];
        }
        else if (aux[j] &lt; aux[i])
        {
            a[k] = aux[j++];
        }
        else
        {
            a[k] = aux[i++];
        }
    }
}
</code></pre>
<p>当左边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑左边元素，直接把右边剩余元素全部赋值给a即可  if(i &gt; mid)<br>
当右边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑右边元素，直接把左边剩余元素全部赋值给a即可  if(j &gt; hi)<br>
如果右边当前元素小于左边当前元素则将右边当前元素赋给a,(aux[j] &lt; aux[i])<br>
右边当前元素大于等于左边当前元素，最后一个else</p>
<h4 id="自上向下">自上向下</h4>
<p>自顶向下归并将一个数组先中间拆分，再把拆分的数组拆分，直到只有一个元素的数组，然后将每两个数组就行归并。最后归并为一个有序数组。<br>
<img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_pNM5lWqMZA.png" alt="图" loading="lazy"><br>
<img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_VlHXNLFh2k.png" alt="图" loading="lazy"></p>
<pre><code class="language-C/C++">void gbsort(int a[], int lo, int hi)
{
    if (hi &lt;= lo)
    {
        return;
    }
    int mid;
    mid = lo + (hi - lo) / 2;
    gbsort(a, lo, mid);
    gbsort(a, mid + 1, hi);
    merge(a, lo, mid, hi);
}
</code></pre>
<h4 id="自底向上">自底向上</h4>
<p>自底向上归并第一次每两个元素的数组归并，然后每四个，八个......归并，最终归并成一个有序数组<br>
<img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_3ixOLZEZqD.png" alt="图" loading="lazy"></p>
<pre><code class="language-c/c++">void gbsort(int a[], int lo, int hi)
{
    int n = hi + 1; //n为数组长度
    for (int i = 1; i &lt; n; i += i)//每次循环完了归并前一次翻倍的数组元素个数
    {
        for (int j = 0; j &lt; n - i; j += i * 2)
        {
            if (j + i * 2 - 1 &lt; hi)
            {
                merge(a, j, j + i - 1, j + i * 2 - 1);
            }
            else {
                merge(a, j, j + i - 1, hi);
            }
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[负进制]]></title>
        <id>https://sakuratears.cn/post/fu-jin-zhi/</id>
        <link href="https://sakuratears.cn/post/fu-jin-zhi/">
        </link>
        <updated>2020-10-23T06:55:30.000Z</updated>
        <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_kZgFEYVhht.png" alt="洛谷" loading="lazy"></figure>
<h3 id="输入格式">输入格式</h3>
<p>输入的每行有两个输入数据。<br>
第一个是十进制数 n。 第二个是负进制数的基数 −R。</p>
<h3 id="输出格式">输出格式</h3>
<p>输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。</p>
<h3 id="输入输出样例">输入输出样例</h3>
<p>输入 3000 -2<br>
输出 30000=11011010101110000(base-2)<br>
输入 -20000 -2<br>
输出 -20000=1111011000100000(base-2)<br>
输入 28800 -16<br>
输出 28800=19180(base-16)<br>
输入 -25000 -16<br>
输出 -25000=7FB8(base-16)</p>
<h3 id="说明">说明</h3>
<p>【数据范围】<br>
对于 100% 的数据,−20≤R≤−2,∣n∣≤37336。</p>
<p>NOIp2000提高组第一题</p>
<h3 id="题解">题解：</h3>
<p>正常情况下-7 % -2 商4 余1<br>
但是C语言（或者说所有语言）这里是商3 余-1<br>
这就很明显了，只需要把商+1，被除数+1就和正常计算情况一样了</p>
<h4 id="代码为">代码为：</h4>
<pre><code class="language-C/C++">#include &lt;stdio.h&gt;

void zh(int a, int b)
{
    if (a == 0) {
        return;
    }
    int m = a % b;
    if (m &lt; 0) {
        m -= b;
        a += b;
    }
    if (m &gt; 9) {
        m = 'A' + m - 10;
    }
    else
        m += '0';
    zh(a / b, b);
    printf(&quot;%c&quot;, m);
}

int main()
{
    int a, b;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    printf(&quot;%d=&quot;, a);
    zh(a, b);
    printf(&quot;(base%d)&quot;, b);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[带备忘录和dp的递归]]></title>
        <id>https://sakuratears.cn/post/dai-bei-wang-lu-he-dp-de-di-gui/</id>
        <link href="https://sakuratears.cn/post/dai-bei-wang-lu-he-dp-de-di-gui/">
        </link>
        <updated>2020-10-23T06:49:02.000Z</updated>
        <content type="html"><![CDATA[<h4 id="备忘录算法">备忘录算法</h4>
<pre><code class="language-C/C++">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int helper(vector&lt;int&gt; &amp;m, int n);
int fib(int n);

int fib(int n)
{
    if(n &lt; 1)
    {
        return 0;
    }
    vector&lt;int&gt; m(n + 1, 0);
    return helper(m, n);
}

int helper(vector&lt;int&gt;&amp;m, int n)
{
    if(n == 1 || n == 2) 
    {
        return 1;
    }
    if (m[n] != 0)
    {
        return m[n];
    }
    m[n] = helper(m, n - 1) + helper(m, n - 2);
    return m[n];
} 

int main()
{
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; fib(n);
    return 0;
}
</code></pre>
<h4 id="dp数组迭代">dp数组迭代</h4>
<pre><code class="language-C/C++">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int fib(int n);

int fib(int n)
{
    if(n &lt; 1)
    {
        return 0;
    }
    vector&lt;int&gt; dp(n + 1, 0);
    dp[1] = dp[2] = 1;
    for (int i = 3; i &lt;= n; i++) 
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

int main()
{
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; fib(n);
    return 0;
}
</code></pre>
<h4 id="空间优化">空间优化</h4>
<pre><code class="language-C/c++">#include &lt;iostream&gt;

using namespace std;

int fib(int n);

int fib(int n)
{
    if (n == 1 || n == 2)
    {
        return 1;
    }
    int a, b, sum;
    a = b = 1;
    for (int i = 3; i &lt;= n; i++) 
    {
        sum = a + b;
        a = b;
        b = sum;
    }
    return sum;
}

int main()
{
    int n;
    cin &gt;&gt; n;
    cout &lt;&lt; fib(n);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[凑零钱问题]]></title>
        <id>https://sakuratears.cn/post/cou-ling-qian-wen-ti/</id>
        <link href="https://sakuratears.cn/post/cou-ling-qian-wen-ti/">
        </link>
        <updated>2020-10-23T06:45:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-C/C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;limits.h&gt;
#define INT_MAX 2147483647;
using namespace std;

int coinchange(int coin, vector&lt;int&gt; &amp;coins, int amount, vector&lt;int&gt; &amp;bwl) 
{
    if (amount &lt; 0) return -1;
    if (amount == 0) return 0;
    if (bwl[amount] != 0) return bwl[amount];
    int res, i, j, dp = 0, m;
    m = INT_MAX;
    j = 0;
    res = INT_MAX;
    while (j &lt; coin) {
        i = coins[j];
        dp = coinchange(coin, coins, amount - i, bwl);
        if (dp == -1) {
            j++;
            continue;
        }
        if (res &gt; 1 + dp) {
            res = 1 + dp;
        }
        j++;
    }
    if (res != m) {
        bwl[amount] = res;
    }
    else {
        bwl[amount] = -1;
    }
    return bwl[amount];
}

int coinChange(vector&lt;int&gt;&amp; coins, int amount) 
{
    int coin = coins.size();
    vector&lt;int&gt; bwl(amount + 1, 0);
    return coinchange(coin, coins, amount, bwl);
}


int main() 
{
    vector&lt;int&gt; coins;
    int a, n, i = 0, amount, m;
    cin &gt;&gt; n;
    coins.clear();
    while (i &lt; n) {
        cin &gt;&gt; a;
        coins.push_back(a);
        i++;
    }
    cin &gt;&gt; amount;
    m = coinChange(coins, amount);
    cout &lt;&lt; m;
    return 0;
}

</code></pre>
<pre><code class="language-C/C++">#include &lt;iostream&gt;
#include &lt;limits.h&gt;
#include &lt;vector&gt;
#define INT_MAX 2147483647;
using namespace std;

int coinChange(vector&lt;int&gt; &amp;coins, int amount)
{
    vector&lt;int&gt; dp(amount + 1, amount + 1);
    dp[0] = 0;
    int i, j;
    for (i = 0; i &lt; dp.size(); i++) 
    {
        for (j = 0; j &lt; coins.size(); j++)
        {
            if (i &lt; coins[j])
            {
                continue;
            }
            if (dp[i] &gt; dp[i - coins[j]]) 
            {
                dp[i] = 1 + dp[i - coins[j]];
            }
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}

int main()
{
    vector&lt;int&gt; coins;
    int a, n, i = 0, amount, m;
    cin &gt;&gt; n;
    coins.clear();
    while (i &lt; n)
    {
        cin &gt;&gt; a;
        coins.push_back(a);
        i++;
    }
    cin &gt;&gt; amount;
    m = coinChange(coins, amount);
    cout &lt;&lt; m;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言实现链表基本操作（交换第i个和第j个节点）]]></title>
        <id>https://sakuratears.cn/post/c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian/</id>
        <link href="https://sakuratears.cn/post/c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian/">
        </link>
        <updated>2020-10-23T06:39:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="c语言实现链表基本操作交换第i个和第j个节点">C语言实现链表基本操作（交换第i个和第j个节点）</h2>
<h3 id="当i或者j为1时需要让链表的表头指向j">当i或者j为1时，需要让链表的表头指向j。</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200611081240188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70" alt="开始时" loading="lazy"></figure>
<p><img src="https://img-blog.csdnimg.cn/20200611081335308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020061108140129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611081415319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611081427878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
代码为</p>
<pre><code class="language-c">/*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/
    if (i == 1) { 
        t1 = *L;
        for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) {
            if (m + 1 == j) {
                *L = temp-&gt;Next;
                t2 = temp-&gt;Next-&gt;Next;
                temp-&gt;Next-&gt;Next = t1-&gt;Next;
                t1-&gt;Next = t2;
                temp-&gt;Next = t1;
            }
        }
    }
</code></pre>
<h3 id="当i和j都不为1时">当i和j都不为1时。</h3>
<p>节点相邻与不相邻也是不一样的。<br>
不相邻的情况下就是让i前面的节点指向j，然后让j前面的节点指向i。如果两个节点相邻（假设i &lt; j）j前面的节点就是i，j前面的节点指向i就是指向了自己，所以要分开写。<br>
不相邻节点时：<br>
<img src="https://img-blog.csdnimg.cn/20200611083309796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611083331554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611083418720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611083435638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
代码为：</p>
<pre><code class="language-c">if ((i - j) != 1 &amp;&amp; (j- i) != 1) {//非相邻结点之间交换
            for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m + 1 == j) {
                    t2 = temp;
                }
            }
            t5 = t1-&gt;Next-&gt;Next;
            t3 = t1-&gt;Next;
            t4 = t2-&gt;Next;
            t1-&gt;Next = t4;
            t2-&gt;Next = t3;
            t3-&gt;Next = t4-&gt;Next;
            t4-&gt;Next = t5;
        }
</code></pre>
<h3 id="最后一种情况两个节点相邻">最后一种情况，两个节点相邻：</h3>
<p><img src="https://img-blog.csdnimg.cn/20200611084227643.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611084240634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611084255116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200611084305639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
代码为：</p>
<pre><code class="language-c">for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m == j) {
                    t2 = temp;
                }
            }
            temp = t2-&gt;Next;
            t3 = t1-&gt;Next;
            t1-&gt;Next = t2;
            t3-&gt;Next = temp;
            t2-&gt;Next = t3;
        }
</code></pre>
<p>全部代码：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

typedef struct node
{
    int Score;
    struct node * Next;
}Node, * List;

void Insert(List *L, Node e)
{
    List temp = *L;
    List n = (List)malloc(sizeof(Node));
    n-&gt;Score = e.Score;
    if (temp == NULL) {
        *L = n;
    }
    else {
        while (temp-&gt;Next != NULL) {
            temp = temp-&gt;Next;
        }
        temp-&gt;Next = n;
    }
    n-&gt;Next = NULL;
}

void Swap(List * L, int i, int j)
{
    List temp = *L;
    List t1;
    List t2;
    List t3;
    List t4;
    List t5;
    int m;
    /*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/
    if (i == 1) { 
        t1 = *L;
        for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) {
            if (m + 1 == j) {
                *L = temp-&gt;Next;
                t2 = temp-&gt;Next-&gt;Next;
                temp-&gt;Next-&gt;Next = t1-&gt;Next;
                t1-&gt;Next = t2;
                temp-&gt;Next = t1;
            }
        }
    }
    if (j == 1) {
        t1 = *L;
        for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) {
            if (m + 1 == i) {
                *L = temp-&gt;Next;
                t2 = temp-&gt;Next-&gt;Next;
                temp-&gt;Next-&gt;Next = t1-&gt;Next;
                t1-&gt;Next = t2;
                temp-&gt;Next = t1;
            }
        }
    }
    /*相邻节点之间交换和非相邻结点之间交换不一样*/
    else {
        if ((i - j) != 1 &amp;&amp; (j- i) != 1) {//非相邻结点之间交换
            for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m + 1 == j) {
                    t2 = temp;
                }
            }
            t5 = t1-&gt;Next-&gt;Next;
            t3 = t1-&gt;Next;
            t4 = t2-&gt;Next;
            t1-&gt;Next = t4;
            t2-&gt;Next = t3;
            t3-&gt;Next = t4-&gt;Next;
            t4-&gt;Next = t5;
        }
        else if (i &lt; j) {//相邻节点之间交换
            for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m == j) {
                    t2 = temp;
                }
            }
            temp = t2-&gt;Next;
            t3 = t1-&gt;Next;
            t1-&gt;Next = t2;
            t3-&gt;Next = temp;
            t2-&gt;Next = t3;
        }
        else if (i &gt; j) {
            for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) {
                if (m + 1 == j) {
                    t1 = temp;
                }
                if (m == i) {
                    t2 = temp;
                }
            }
            temp = t2-&gt;Next;
            t3 = t1-&gt;Next;
            t1-&gt;Next = t2;
            t3-&gt;Next = temp;
            t2-&gt;Next = t3;
        }
    }
}

void printflist(List list) 
{
    List temp;
    for (temp = list; temp != NULL; temp = temp-&gt;Next) {
        printf(&quot;%d\n&quot;, temp-&gt;Score);
    }
}

void freelist(List *list)
{
    List temp = *list, del;
    while (temp != NULL) {
        del = temp;
        temp = temp-&gt;Next;
        free(del);
    }
}

int main()
{
    List list = NULL;
    Node n1, n2, n3, n4, e;//定义5个节点
    e.Score = 5;
    n1.Score = 1;
    n2.Score = 2;
    n3.Score = 3;
    n4.Score = 4;
    Insert(&amp;list, n1);
    Insert(&amp;list, n2);
    Insert(&amp;list, n3);
    Insert(&amp;list, n4);
    Insert(&amp;list, e);
    // dellist(&amp;list, 8);
    Swap(&amp;list, 5, 4);
    printflist(list);
    freelist(&amp;list);
    return 0;
}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言链表基本操作（头插法及其逆置）]]></title>
        <id>https://sakuratears.cn/post/c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi/</id>
        <link href="https://sakuratears.cn/post/c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi/">
        </link>
        <updated>2020-10-23T06:32:17.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-C/C++">#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

typedef struct Node
{
    char data;
	struct Node *next;
}SN;

SN * create(int n)
{
	int i;
	SN *h,*p;
    h = NULL;
    for(i = 0; i&lt;n; i++)
	{
		p=(SN*)malloc(sizeof(SN));
		printf(&quot;请输入第%d个字符：&quot;,i+1);
		p-&gt;data = getchar();
		fflush(stdin);
		p-&gt;next = h;
		h=p;
	}
	return h;
}

SN * def(SN * h)
{ 
    SN * n1, *n2;
	n1 = h;
	n2 = NULL;
	while(n1 != NULL)
	{
		SN *temp;
		temp = n1;
		n1 = n1-&gt;next;
		temp-&gt;next = n2;
		n2 = temp;
	}
	h = n2;
	return h;
}
void visit(SN * h)
{ 
	while(h != NULL)
	{
		printf(&quot;%c&quot;, h-&gt;data);
		h = h-&gt;next;
	}
	printf(&quot;\n&quot;);
}

void freelist(SN *h)
{
    SN *temp = h;
	SN *del;
	while (temp != NULL) {
        del = temp;
        temp = temp-&gt;next;
        free(del);
    }
}

int main() 
{
	int n;
	SN *h;
	printf(&quot;请输入字符个数：\n&quot;);
	scanf(&quot;%d&quot;, &amp;n);
	fflush(stdin);
	h = create(n);
	printf(&quot;链表创建成功，对其遍历\n&quot;);
    visit(h);
	printf(&quot;链表逆置成功，对其遍历\n&quot;);
	h = def(h);
	visit(h);
	freelist(h);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>