<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-24T09:45:40.114Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[切分木棒(DFS)(BFS)]]></title>
        <id>https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/</id>
        <link href="https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/">
        </link>
        <updated>2020-12-24T09:29:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
<!-- more -->
<p><img src="http://www.ituring.com.cn/figures/2017/ProgrammerPuzzle/07.d01z.014.png" alt="图 2　n ＝ 8，m ＝ 3 的时候" loading="lazy"><br>
求最多有 m 个人时，最少要切分几次。譬如 n ＝ 8，m＝ 3 时如图所示，切分 4 次就可以了。</p>
<p>作者：图灵教育<br>
链接：https://leetcode-cn.com/leetbook/read/interesting-algorithm-puzzles-for-programmers/90ach5/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1dfs">方法1：DFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	if (num &gt;= n) { //达到要求结束
		return 0;
	}
	else if (num &lt; m) { //目前段数小于人数，直接段数*2
		return 1 + sil(m, n, num * 2);
	}
	else { //目前段数大于等于人数，增加m段
		return 1 + sil(m, n, num + m);
	}
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
<h4 id="方法2bfs">方法2：BFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	int count = 0;
	while (num &lt; n) {
		num += num &lt; m ? num : m;
        /*
		if (num &lt; m) {
			num += num;
		}
		else {
			num += m;
		}
		count++;
		*/
		count++;
	}
	return count;
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 387. 字符串中的第一个唯一字符(哈希表)]]></title>
        <id>https://sakuratears.cn/post/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-ha-xi-biao/">
        </link>
        <updated>2020-12-23T11:54:29.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<!-- more -->
<p>示例：</p>
<p>s = &quot;leetcode&quot;<br>
返回 0</p>
<p>s = &quot;loveleetcode&quot;<br>
返回 2</p>
<p>提示：你可以假定该字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1哈希表">方法1：哈希表</h4>
<pre><code class="language-C++">class Solution {
public:
    int firstUniqChar(string s) {
        if (s.size() &lt;= 0) {
            return -1;
        }
        map&lt;int, int&gt; smap;
        for (char ch : s) {
            smap[ch]++;
        }
        for (int i = 0; i &lt; s.size(); i++) {
            if (smap[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
<h4 id="方法2数组">方法2：数组</h4>
<pre><code class="language-C++">class Solution {
public:
    int firstUniqChar(string s) {
        int map[26] = {0};
        for (int i = 0; i &lt; s.size(); i++) {
            map[s[i] - 'a']++;
        }
        for (int i = 0; i &lt; s.size(); i++) {
            if (map[s[i] - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 12. 整数转罗马数字(字符串)(贪心算法)]]></title>
        <id>https://sakuratears.cn/post/leetcode-12-zheng-shu-zhuan-luo-ma-shu-zi-zi-fu-chuan/</id>
        <link href="https://sakuratears.cn/post/leetcode-12-zheng-shu-zhuan-luo-ma-shu-zi-zi-fu-chuan/">
        </link>
        <updated>2020-12-22T11:15:18.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<!-- more -->
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: 3<br>
输出: &quot;III&quot;<br>
示例 2:</p>
<p>输入: 4<br>
输出: &quot;IV&quot;<br>
示例 3:</p>
<p>输入: 9<br>
输出: &quot;IX&quot;<br>
示例 4:</p>
<p>输入: 58<br>
输出: &quot;LVIII&quot;<br>
解释: L = 50, V = 5, III = 3.<br>
示例 5:</p>
<p>输入: 1994<br>
输出: &quot;MCMXCIV&quot;<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/integer-to-roman<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1暴力解法">方法1:暴力解法</h4>
<p>把每种情况都写出来然后直接暴力解决</p>
<pre><code class="language-C++">class Solution {
public:
    string five(int num) {
        string str;
         if (num == 4) {
                str = &quot;IV&quot;;
        }
        else if (num == 5) {
            str = &quot;V&quot;;
        }
        else {
            for (int i = 0; i &lt; num; i++) {
                str += 'I';
            }
        }
        return str;
    }

    string ten(int num) {
        string str;
        if (num == 9) {
            str = &quot;IX&quot;;
        }
        else if (num == 10) {
            str = &quot;X&quot;;
        }
        else {
            str = &quot;V&quot;;
            for (int i = 0; i &lt; num - 5; i++) {
                str += 'I';
            }
        }
        return str;
    }

    string fifty(int num) {
        string str;
        if (num == 40) {
            str = &quot;XL&quot;;
        }
        else if (num == 50) {
            str = &quot;L&quot;;
        }
        else if (num &gt; 40) {
            str = &quot;XL&quot;;
            int n = num - 40;
            if (n &gt; 5) {
                str += ten(n);
            }
            else {
                str += five(n);
            }
        }
        else {
            int n = num / 10;
            num %= 10;
            for (int i = 0; i &lt; n; i++) {
                str += 'X';
            }
            if (num &lt;= 5) {
                str += five(num);
            }
            else {
                str += ten(num);
            }
        }
        return str;
    }

    string hundred(int num) {
        string str;
        if (num == 90) {
            str = &quot;XC&quot;;
        }
        else if (num == 100) {
            str = &quot;C&quot;;
        }
        else if (num &gt; 90) {
            str = &quot;XC&quot;;
            int n = num - 90;
            if (n &gt; 5) {
                str += ten(n);
            }
            else {
                str += five(n);
            }            
        }
        else {
            str = &quot;L&quot;;
            num -= 50;
            int n = num / 10;
            num %= 10;
            for (int i = 0; i &lt; n; i++) {
                str += 'X';
            }
            if (num &lt;= 5) {
                str += five(num);
            }
            else {
                str += ten(num);
            }            
        }
        return str;
    }

    string fiveh(int num) {
        string str;
        if (num == 400) {
            str = &quot;CD&quot;;
        }
        else if (num == 500) {
            str = &quot;D&quot;;
        }
        else if (num &gt; 400) {
            str = &quot;CD&quot;;
            int n = num - 400;
            if (n &gt; 50) {
                str += hundred(n);
            }
            else {
                str += fifty(n);
            }
        }
        else {
            int n = num / 100;
            num %= 100;
            for (int i = 0; i &lt; n; i++) {
                str += 'C';
            }
            if (num &gt; 50) {
                str += hundred(num);
            }
            else {
                str += fifty(num);
            }
        }
        return str;
    }

    string thousand(int num) {
        string str;
        if (num == 900) {
            str = &quot;CM&quot;;
        }
        else if (num == 1000) {
            str = &quot;M&quot;;
        }
        else if (num &gt; 900) {
            str = &quot;CM&quot;;
            int n = num - 900;
            // cout&lt;&lt;num;
            if (n &gt; 50) {
                str += hundred(n);
            }
            else {
                str += fifty(n);
            }
        }
        else {
            str = &quot;D&quot;;
            num -= 500;
            int n = num / 100;
            num %= 100;
            // cout&lt;&lt;num;
            for (int i = 0; i &lt; n; i++) {
                str += &quot;C&quot;;
            }
            if (num &gt; 50) {
                str += hundred(num);
            }
            else {
                // cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;fifty(num);
                str += fifty(num);
            }
        }
        return str;
    }

    string more(int num) {
        string str;
        int n = num / 1000;
        num %= 1000;
        for (int i = 0; i &lt; n; i++) {
            str += &quot;M&quot;;
        }
        if (num &lt;= 5) {
            str += five(num);
        }
        else if (num &lt;= 10) {
            str += ten(num);
        }
        else if (num &lt;= 50) {
            str += fifty(num);
        }
        else if (num &lt;= 100) {
            str += hundred(num);
        }
        else if (num &lt;= 500) {
            str += fiveh(num);
        }
        else if (num &lt;= 1000) {
            str += thousand(num);
        }
        return str;
    }

    string intToRoman(int num) {
        string str = &quot;&quot;;
        if (num &gt; 0) {
            if (num &lt;= 5) {
                str += five(num);
            }
            else if (num &lt;= 10) {
                str += ten(num);
            }
            else if (num &lt;= 50) {
                str += fifty(num);
            }
            else if (num &lt;= 100) {
                str += hundred(num);
            }
            else if (num &lt;= 500) {
                str += fiveh(num);
            }
            else if (num &lt;= 1000) {
                str += thousand(num);
            }
            else {
                str += more(num);
            }
        }
        else {
            str = &quot;&quot;;
        }
        return str;
    }
};
</code></pre>
<h4 id="方法2贪心算法">方法2:贪心算法</h4>
<p>把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中，并且按照阿拉伯数字的大小降序排列。每次尽可能优先使用较大数值对应的字符</p>
<pre><code class="language-C++">class Solution {
public:
	string intToRoman(int num) {
		int values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};
		string reps[]= {&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
		string res;
		for(int i=0; i&lt;13; i++) {
			while(num&gt;=values[i]) {
				num -= values[i];
				res += reps[i];
			}
		}
		return res;
	}
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 69. x 的平方根(二分)]]></title>
        <id>https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/</id>
        <link href="https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/">
        </link>
        <updated>2020-12-21T09:32:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: 4<br>
输出: 2<br>
示例 2:</p>
<p>输入: 8<br>
输出: 2<br>
说明: 8 的平方根是 2.82842...,<br>
     由于返回类型是整数，小数部分将被舍去。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sqrtx<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>采用二分法每次找到中间元素与x比较大小，大则在左边查找，小则在右边查找<br>
每次判断一下lo（最左边元素）的平方与lo + 1的平方：<br>
<code>if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x)</code>这就说明x平方根是lo到lo + 1之间的值，所以直接返回lo即可<br>
判断hi同理</p>
<pre><code class="language-C++">class Solution {
public:
    int res = 0;
    void Sqrt(int lo, int hi, int x) {
        if (pow(lo, 2) == x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) == x) {
            res = hi;
            return;
        }
        else if (pow(lo, 2) &lt; x &amp;&amp; pow(lo + 1, 2) &gt; x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x) {
            res = hi;
            return;
        }
        else if (pow((lo + hi) / 2, 2) == x) {
            res = (lo + hi) / 2;
            return;
        }
        else if (pow((lo + hi) / 2, 2) &lt; x) {
            lo = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
        else if (pow((lo + hi) / 2, 2) &gt; x) {
            hi = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
    }
    int mySqrt(int x) {
        int lo = 0, hi = x;
        Sqrt(lo, hi, x);
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言实现各种进制之间转换]]></title>
        <id>https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/</id>
        <link href="https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/">
        </link>
        <updated>2020-12-20T11:55:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-C">#include &lt;Windows.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 50

//进制转换

char *Ten_MoreThanTen(int, int); //10进制数转换成10以上进制数的函数

int MoreThanTen_Ten(int, char[]); //10以上进制数转换成10进制数的函数

int Ten_LessThanTen(int, int); //10进制数转换成10以内进制数的函数

int LessThanTen_Ten(int, int); //10以内进制数转换成10进制数的函数

char array[N] = &quot;\0&quot;; //全局变量，用于存储转换后并且倒置了的数据

int LessThanTen_Ten(int before, int num) //10以内转换10，参数brfore为初始进制,num为初始数值

{

    double result = 0.0; //转换成10进制后的结果

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现按权展开相加

    {

        result += pow(before, i) * (num % 10);

        num /= 10;
    }

    return (int)result; //返回值为转换后的结果
}

int Ten_LessThanTen(int after, int num) //10转换10以内，参数after为转换后的进制，num为10进制数值

{

    double result = 0.0; //double类型因为pow函数的返回值为double类型

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现连续取余

    {

        result += (num % after) * pow(10, i);

        num /= after;
    }

    return (int)result;
}

int MoreThanTen_Ten(int before, char num[]) //10以上转换10

{

    int i = 0;

    double result = 0.0;

    int length = strlen(num);

    for (i = length - 1; i &gt;= 0; i--)

    {

        //利用ASCALL码将所有元素转换成对应的整型

        if ('A' &lt;= num[i] &amp;&amp; num[i] &lt;= 'Z')

            result += pow(before, length - i - 1) * (num[i] - 55);

        else if ('a' &lt;= num[i] &amp;&amp; num[i] &lt;= 'z')

            result += pow(before, length - i - 1) * (num[i] - 87);

        else if ('0' &lt;= num[i] &amp;&amp; num[i] &lt;= '9')

            result += pow(before, length - i - 1) * (num[i] - 48);
    }

    return (int)result;
}

char *Ten_MoreThanTen(int after, int num) //10转换10以上

{

    int i = 0;

    int j = 0;

    int tmp = 0; //存储每次余数的中间变量

    char tmp_array[N] = &quot;\0&quot;; //转换后未倒置的数组

    for (i = 0; num &gt; 0; i++)

    {

        tmp = num % after;

        if (tmp &lt; 10) //对大于等于10的余数进行字母转换

            tmp_array[i] = tmp + '0';

        else

            tmp_array[i] = tmp + 'A' - 10;

        num /= after;
    }

    for (j = 0; i &gt; 0; i--, j++) //倒置

    {

        array[j] = tmp_array[i - 1];

        array[j + 1] = '\0';
    }

    return array; //输出转换后存储数据的字符串地址
}

int main()

{

    int before = 0; //转换前的进制数

    int after = 0; //转换后的进制数

    int num1 = 0; //要转换的十进制以内的数

    char array_num1[N] = &quot;\0&quot;; //要转换的十进制以上的数

    int num2 = 0; //转换之后的数

    char *str_num2; //转换之后的数的地址

    int tmp_num1 = 0; //判断输入是否合法时代替num1的中间变量

    int i = 0;

    int m = 0; //计数器

    while (1) //整个while语句用于录入以及判断输入是否合法

    {

        printf(&quot;初始进制：&quot;);

        scanf(&quot;%d&quot;, &amp;before);

        printf(&quot;目标进制：&quot;);

        scanf(&quot;%d&quot;, &amp;after);

        printf(&quot;初始数值：&quot;);

        if (before &gt; 10) //通过对初始进制判断，决定

            scanf(&quot;%s&quot;, array_num1);

        else

            scanf(&quot;%d&quot;, &amp;num1);

        for (i = 0, tmp_num1 = num1; tmp_num1 != 0; i++)

        {

            if ((tmp_num1 % 10) &lt;= before &amp;&amp; tmp_num1 % 10 &gt;= 0 &amp;&amp; tmp_num1 % 10 &lt;= 9)

                m++;

            tmp_num1 /= 10;
        }

        if (m == i) //判断输入的数据每一位是否都小于等于进制数

            break;

        else

        {

            m = 0; //对计数器m重新初始化

            fflush(stdin); //清空缓存区

            printf(&quot;输入有误！请重新输入：\n&quot;);
        }
    }

    //将进制转换的四种情况分别表示

    if (before &lt;= 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%d\n&quot;, before, num1, after, num2);
    }

    else if (before &gt; 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%d\n&quot;, before, array_num1, after, num2);
    }

    else if (before &lt;= 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%s\n&quot;, before, num1, after, str_num2);
    }

    else if (before &gt; 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%s\n&quot;, before, array_num1, after, str_num2);
    }

    system(&quot;pause&quot;);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旋转图像(数组)]]></title>
        <id>https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/</id>
        <link href="https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/">
        </link>
        <updated>2020-12-19T10:45:03.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
<!-- more -->
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<p>给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]<br>
示例 2:</p>
<p>给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-image<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1">方法1</h4>
<p><strong>题目要求不要用辅助数组，此题解用了辅助数组</strong><br>
直接用一个辅助数组arr，arr的列是matrix的行，用两个循环即可</p>
<pre><code class="language-C++">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;vector&lt;int&gt;&gt; arr = matrix;
        for (int i = 0, j = matrix.size() - 1; i &lt; matrix.size(); i++, j--) {
            for (int m = 0; m &lt; matrix[i].size(); m++) {
                arr[m][j] = matrix[i][m];
            }
        }
        matrix = arr;
    }
};
</code></pre>
<h4 id="方法2">方法2</h4>
<p>可以先对数组进行从左上到右下对角线为轴进行翻转，再对每一行以中间为轴翻转。即可</p>
<pre><code class="language-C++">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0) {
            return;
        }
        int i, j, m, temp;
        for (i = 0; i &lt; matrix.size() - 1; i++) {
            for (j = i + 1; j &lt; matrix.size(); j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        for (i = 0; i &lt; matrix.size(); i++) {
            for (j = matrix[i].size() / 2; j &lt; matrix.size(); j++) {
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.size() - j - 1];
                matrix[i][matrix.size() - j - 1] = temp;
            }
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://sakuratears.cn/post/markdown-yu-fa/</id>
        <link href="https://sakuratears.cn/post/markdown-yu-fa/">
        </link>
        <updated>2020-12-18T13:26:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="生成目录">生成目录</h1>
<p>在markdown顶部输入<code>[TOC]</code>即可生成目录</p>
<h1 id="markdown标题">Markdown标题</h1>
<p>Markdown标题有两种</p>
<h2 id="第一种标题">第一种标题</h2>
<p>使用=和-标记</p>
<pre><code class="language-markdown">我展示的是一级标题
=================

我展示的是二级标题
-----------------
</code></pre>
<h2 id="第二种标题">第二种标题</h2>
<p>使用#标记</p>
<pre><code class="language-markdown"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<h1 id="markdown-段落格式">Markdown 段落格式</h1>
<h2 id="markdown-段落">Markdown 段落</h2>
<p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。或者</p>
<pre><code class="language-markdown">&lt;br&gt;&lt;br&gt;
</code></pre>
<h2 id="字体">字体</h2>
<pre><code class="language-markdown">*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
</code></pre>
<p><em>斜体文本</em><br>
<em>斜体文本</em><br>
<strong>粗体文本</strong><br>
<strong>粗体文本</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em><strong>粗斜体文本</strong></em></p>
<h2 id="分隔线">分隔线</h2>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code class="language-markdown">***

* * *

*****

- - -

----------
</code></pre>
<h2 id="删除线">删除线</h2>
<p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可，实例如下：</p>
<pre><code class="language-markdown">RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
</code></pre>
<p>RUNOOB.COM<br>
GOOGLE.COM<br>
<s>BAIDU.COM</s></p>
<h2 id="下划线">下划线</h2>
<p>下划线可以通过 HTML 的<code>&lt;u&gt;</code> 标签来实现：</p>
<pre><code class="language-markdown">&lt;u&gt;带下划线文本&lt;/u&gt;
</code></pre>
<p><u>带下划线文本</u></p>
<h2 id="脚注">脚注</h2>
<p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<pre><code class="language-markdown">[^要注明的文本]
</code></pre>
<p>以下实例演示了脚注的用法：</p>
<pre><code class="language-markdown">创建脚注格式类似这样 [^RUNOOB]。

[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！
</code></pre>
<p>创建脚注格式类似这样 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h1 id="markdown-列表">Markdown 列表</h1>
<h2 id="无序列表">无序列表</h2>
<p>Markdown 支持有序列表和无序列表。<br>
无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<pre><code class="language-markdown">* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项

- 第一项
- 第二项
- 第三项
</code></pre>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h2 id="有序列表">有序列表</h2>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<pre><code class="language-markdown">1. 第一项
2. 第二项
3. 第三项
</code></pre>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="列表嵌套">列表嵌套</h2>
<p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<pre><code class="language-markdown">1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
    - 第二项嵌套的第二个元素
   
</code></pre>
<ol>
<li>第一项：
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：
<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="markdown-区块">Markdown 区块</h1>
<p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>
<pre><code class="language-markdown">&gt; 区块引用
&gt; 菜鸟教程
&gt; 学的不仅是技术更是梦想
</code></pre>
<blockquote>
<p>区块引用<br>
菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<pre><code class="language-markdown">&gt; 最外层
&gt; &gt; 第一层嵌套
&gt; &gt; &gt; 第二层嵌套
</code></pre>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="区块中使用列表">区块中使用列表</h2>
<p>区块中使用列表实例如下:</p>
<pre><code class="language-markdown">&gt; 区块中使用列表
&gt; 1. 第一项
&gt; 2. 第二项
&gt; + 第一项
&gt; + 第二项
&gt; + 第三项
</code></pre>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h2 id="列表中使用区块">列表中使用区块</h2>
<p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。<br>
区块中使用列表实例如下：</p>
<pre><code class="language-markdown">* 第一项
    &gt; 菜鸟教程
    &gt; 学的不仅是技术更是梦想
* 第二项
</code></pre>
<ul>
<li>第一项
<blockquote>
<p>菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<h1 id="markdown-代码">Markdown 代码</h1>
<p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来<code>（`）</code>，例如：</p>
<pre><code class="language-markdown">`printf()` 函数
</code></pre>
<p><code>printf()</code> 函数</p>
<h2 id="代码区块">代码区块</h2>
<p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p>
<p>实例如下：<br>
printf(&quot;hello&quot;)</p>
<p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<pre><code class="language-markdown">​```javascript
$(document).ready(function () {
    alert('hello word!');
});
​```
</code></pre>
<pre><code class="language-javascript">$(document).ready(function () {
    alert('hello word!');
});
</code></pre>
<h1 id="markdown-链接">Markdown 链接</h1>
<p>链接使用方法如下：</p>
<pre><code class="language-markdown">[链接名称](链接地址)

或者

&lt;链接地址&gt;
</code></pre>
<p><a href="https://sakuratears.cn">blog</a></p>
<p>或者</p>
<p><a href="https://sakuratears.cn">https://sakuratears.cn</a></p>
<h2 id="高级链接">高级链接</h2>
<p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [Google][1]
这个链接用 sakura 作为网址变量 [sakura][sakura]
然后在文档的结尾为变量赋值（网址）

  [1]: http://www.google.com/
  [sakura]: https://sakuratears.cn/
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>
这个链接用 sakura 作为网址变量 <a href="https://sakuratears.cn/">sakura</a><br>
然后在文档的结尾为变量赋值（网址）</p>
<h1 id="markdown-图片">Markdown 图片</h1>
<p>Markdown 图片语法格式如下：</p>
<pre><code class="language-markdown">![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &quot;可选标题&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"></figure>
<p>当然，你也可以像网址那样对图片网址使用变量:</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [RUNOOB][1].
然后在文档的结尾为变量赋值（网址）

[1]: http://static.runoob.com/images/runoob-logo.png
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>
然后在文档的结尾为变量赋值（网址）</p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<pre><code class="language-markdown">&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;
</code></pre>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">
<h1 id="markdown-表格">Markdown 表格</h1>
<p>Markdown 制作表格使用 <code>|</code>来分隔不同的单元格，使用<code>-</code> 来分隔表头和其他行。<br>
语法格式如下：</p>
<pre><code class="language-markdown">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<p>对齐方式</p>
<p>我们可以设置表格的对齐方式：</p>
<p><code>-:</code> 设置内容和标题栏居右对齐。<br>
<code>:-</code>设置内容和标题栏居左对齐。<br>
<code>:-:</code>设置内容和标题栏居中对齐。</p>
<pre><code class="language-markdown">| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
<h1 id="markdown-高级技巧">Markdown 高级技巧</h1>
<h2 id="支持的-html-元素">支持的 HTML 元素</h2>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</p>
<pre><code class="language-markdown">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑
</code></pre>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h2 id="转义">转义</h2>
<p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p>
<pre><code class="language-markdown">**文本加粗** 
\*\* 正常显示星号 \*\*
</code></pre>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code class="language-markdown">\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
</code></pre>
<h2 id="公式">公式</h2>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<pre><code class="language-markdown">$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 248: …
\end{vmatrix}
$̲{$tep1}{\style{…'>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>菜鸟教程 -- 学的不仅是技术，更是梦想！！！ <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[找不同(位运算)(哈希表)]]></title>
        <id>https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/">
        </link>
        <updated>2020-12-18T09:38:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
<!-- more -->
<p></p>
<p>示例 1：<br>
输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;<br>
输出：&quot;e&quot;<br>
解释：'e' 是那个被添加的字母。</p>
<p>示例 2：<br>
输入：s = &quot;&quot;, t = &quot;y&quot;<br>
输出：&quot;y&quot;</p>
<p>示例 3：<br>
输入：s = &quot;a&quot;, t = &quot;aa&quot;<br>
输出：&quot;a&quot;</p>
<p>示例 4：<br>
输入：s = &quot;ae&quot;, t = &quot;aea&quot;<br>
输出：&quot;a&quot;<br>
 <br>
提示：</p>
<p>0 &lt;= s.length &lt;= 1000<br>
t.length == s.length + 1<br>
s 和 t 只包含小写字母</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-difference<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1位运算">方法1：位运算</h4>
<p><sup>运算符：0与任何数ch做</sup>运算都是ch<br>
相同字符异或为0</p>
<p>因为t中的字符是s + ch，所以s与t做异或剩下的就是ch</p>
<pre><code class="language-C++">class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for(char c : s + t) {
            res ^= c;
        }
        return res;
    }
};
</code></pre>
<h4 id="方法2哈希表">方法2：哈希表</h4>
<p>把s中所有元素存到一个哈希表mpS里，t中所有元素存到一个哈希表mpT里<br>
然后比较两个哈希表每个元素个数，不一样的就是题目所求</p>
<pre><code class="language-C++">char findTheDifference(string s, string t) {
        unordered_map&lt;char, int&gt; mpS;
        unordered_map&lt;char, int&gt; mpT;
        char ch;
        for (auto ch : s) {
            mpS[ch]++;
        }
        for (auto ch : t) {
            mpT[ch]++;
        }

        for (ch = 'a'; ch &lt;= 'z'; ch++) {
            if (mpS[ch] != mpT[ch]) {
                return ch;
            }
        }
        return ch;
    }
    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长公共前缀(字符串)]]></title>
        <id>https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/</id>
        <link href="https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/">
        </link>
        <updated>2020-12-18T09:02:23.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;<br>
示例 2:</p>
<p>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
输出: &quot;&quot;<br>
解释: 输入不存在公共前缀。<br>
说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-prefix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>直接每个字符串从头开始元素比较，不一样直接return即可A</p>
<pre><code class="language-C++">class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        string str = &quot;&quot;;
        if (strs.size() == 0) {
            return str;
        }
        char ch;
        int i, j, min = INT_MAX;
        for (int m = 0; m &lt; strs.size(); m++) {
            if (strs[m].size() &lt; min) {
                min = strs[m].size();
            }
        }
        for (i = 0; i &lt; min; i++) {
            ch = strs[0][i];
            for (j = 0; j &lt; strs.size(); j++) {
                if (strs[j][i] != ch) {
                    return str;
                }
            }
            str += ch;
        }
        return str;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波那契数列(递归)]]></title>
        <id>https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/</id>
        <link href="https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/">
        </link>
        <updated>2020-12-17T09:13:05.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<!-- more -->
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：n = 2<br>
输出：1<br><br><br>
示例 2：</p>
<p>输入：n = 5<br>
输出：5<br><br></p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1递归">方法1：递归</h4>
<p>常规递归方法，然后愉快的超时</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }
};
</code></pre>
<h4 id="方法2带备忘录的递归自顶向下">方法2：带备忘录的递归（自顶向下）</h4>
<p>可以把递归看成一颗树，自顶向下<br>
在递归的过程中很多元素其实已经被访问过了，比如n = 20，求n = 19 + n = 18，求19的时候求n = 18 + n = 17，这里可以看到n = 18被求了两次，下面的元素还有更多次重复的所以一般的递归时间复杂度非常高。如果可以把每个元素的值记录下来，下次求的时候直接用时间可以减少很多。</p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;int&gt; arr;

    int help(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        if (arr[n] != 0) { //如果已经记录则直接用
            return arr[n];
        }
        //未记录则记录下来
        arr[n - 1] = help(n - 1) % 1000000007;
        arr[n - 2] = help(n - 2) % 1000000007;
        return arr[n - 1] + arr[n - 2];
    }

    int fib(int n) {
        for (int i = 1; i &lt;= 101; i++) {
            arr.push_back(0);
        }
        return help(n) % 1000000007;
    }
};
</code></pre>
<h4 id="方法3dp自底向上">方法3：DP（自底向上）</h4>
<p>方法2是从树的顶端到下面依次递归求值，也可以从树的底端到顶端求。<br>
还是利用一个数组，把每个值记录下来，从底到顶。</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        int dp[101];
        dp[1] = 1;
        dp[2] = 1;
        if (n == 0) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
};
</code></pre>
]]></content>
    </entry>
</feed>