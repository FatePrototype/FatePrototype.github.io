<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-14T09:42:42.304Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[无重复字符的最长子串(滑动窗口)]]></title>
        <id>https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/</id>
        <link href="https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/">
        </link>
        <updated>2020-12-13T09:21:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<!-- more -->
<p></p>
<p>示例 1:</p>
<p>输入: s = &quot;abcabcbb&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br><br><br>
示例 2:</p>
<p>输入: s = &quot;bbbbb&quot;<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br><br><br>
示例 3:</p>
<p>输入: s = &quot;pwwkew&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br><br><br>
示例 4:</p>
<p>输入: s = &quot;&quot;<br>
输出: 0<br><br></p>
<p>提示：</p>
<p>0 &lt;= s.length &lt;= 5 * 104<br>
s 由英文字母、数字、符号和空格组成<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>定义p为子串的头，j为尾部，p到j为一个窗口，如果新的元素i和窗口里的元素相同，则把p移动到i的后面。记录每一个窗口的长度，最后取最大</p>
<pre><code class="language-C++">class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        if (s.size() == 0)
        {
            return 0;
        }
        int i, j, max, n, p, jud = 0;
        i = 0;
        p = i;
        j = i + 1;
        max = 1;
        n = 1;
        for (; j &lt; s.size(); j++)
        {
            jud = 0;
            for (p = i; p &lt; j; p++)
            {
                if (s[p] == s[j])
                {
                    i = p + 1;
                    if (i == j)
                    {
                        n = 1;
                    }
                    else if (s[i] == s[j])
                    {
                        n = j - i;
                    }
                    else
                    {
                        n = j - i + 1;
                    }
                    jud = 1;
                    break;
                }
            }
            if (jud == 1)
            {
                continue;
            }
            n++;
            if (n &gt; max)
                max = n;
        }
        return max;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[填充每个节点的下一个右侧节点指针(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-13T09:10:23.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<!-- more -->
<p>struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。<br><br></p>
<p></p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br><br></p>
<p>输入：root = [1,2,3,4,5,6,7]<br>
输出：[1,#,2,3,#,4,5,6,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。<br><br></p>
<p>提示：</p>
<p>树中节点的数量少于 4096<br>
-1000 &lt;= node.val &lt;= 1000<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>每次循环用队列存储每一行的节点，每存储一个节点让前一个节点指向现在的节点。<br>
每次循环队列弹一个，进两个。这样每次循环完队列把上一层的节点全部弹出，把新一层的节点全部加入。</p>
<pre><code class="language-C++">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) {
            return NULL;
        }
        int num = 0;
        queue&lt;Node*&gt; q;
        q.push(root);
        while (!q.empty()) {
            Node* node;
            Node* front;
            front = NULL;
            num = q.size();
            for (int j = 0; j &lt; num; j++) {
                node = q.front();
                q.pop();
                if (node-&gt;left != NULL)
                    q.push(node-&gt;left);
                if (node-&gt;right != NULL) 
                    q.push(node-&gt;right);
                if (front == NULL) {
                    front = node;
                }
                else {
                    front-&gt;next = node;
                    front = front-&gt;next;
                }
            };
        }
        return root;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径总和(二叉树)(DFS)]]></title>
        <id>https://sakuratears.cn/post/lu-jing-zong-he-er-cha-shu-dfs/</id>
        <link href="https://sakuratears.cn/post/lu-jing-zong-he-er-cha-shu-dfs/">
        </link>
        <updated>2020-12-13T07:52:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<!-- more -->
<p>说明: 叶子节点是指没有子节点的节点。<br><br></p>
<p>示例: <br>
给定如下二叉树，以及目标和 sum = 22，<br>
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>从根节点开始遍历每个节点，每次递归将此根节点和前面路径的节点传入，然后当时叶子结点时判断总路径是否相等。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子
    int num;
    void path(TreeNode* root, int n) {
        if (root == NULL) { //根为空的情况
            return;
        }
        //判断路径和是否相等，并且判断是否为叶子结点
        if (root-&gt;val + n == num &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { 
            jud = true;
            return;
        }
        //递归遍历每个节点
        path(root-&gt;left, root-&gt;val + n);
        path(root-&gt;right, root-&gt;val + n);
    }
    bool hasPathSum(TreeNode* root, int sum) {
        //判断两者中特殊情况
        if (root == NULL &amp;&amp; sum == 0) {
            return false;
        }
        if (root == NULL &amp;&amp; sum != 0) {
            return false;
        }
        num = sum;
        path(root, 0);
        return jud;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最小(最大)路径(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu/">
        </link>
        <updated>2020-12-13T05:54:14.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明：叶子节点是指没有子节点的节点。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明：叶子节点是指没有子节点的节点。</p>
<!-- more -->
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：2<br><br></p>
<p>示例 2：<br>
输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5<br><br></p>
<p>提示：<br>
树中节点数的范围在 [0, 105] 内<br>
-1000 &lt;= Node.val &lt;= 1000<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>二叉树每个节点的路径最小(最大)为左子树和右子树中最小(最大)路径加上它自己</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = minDepth(root-&gt;left);
        int right = minDepth(root-&gt;right);
        if (left == 0) {
            return right + 1;
        }
        if (right == 0) {
            return left + 1;
        }
        return min(left, right) + 1;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的层序遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-12T08:51:11.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<!-- more -->
<p></p>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
<img src="https://sakuratears.cn/post-images/1607763983990.png" alt="" loading="lazy"></p>
<p>返回其层次遍历结果：</p>
<p>[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="解题思路">解题思路</h3>
<p>在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了</p>
<h3 id="代码">代码</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; arr;

    void BFS(TreeNode* root) {
        queue&lt;TreeNode*&gt; brr;
        vector&lt;int&gt; crr;
        brr.push(root);
        int n = 0;
        while (!brr.empty()) {
            TreeNode* node = brr.front();
            n = brr.size(); //n记录当前队列元素个数
            for (int i = 0; i &lt; n; i++) { //循环n次
                if (node-&gt;left != NULL) { //左孩子不为空则添加左孩子
                    brr.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) { //右孩子不为空则添加右孩子
                    brr.push(node-&gt;right);
                }
                crr.push_back(brr.front()-&gt;val); //每次循环把队列的头元素的值添加到一个数组里
                brr.pop();
                node = brr.front(); //节点移动到下一个
            }
            arr.push_back(crr); //把当前数组元素添加到二维数组中
            crr.clear(); //当前数组清空
        }
    }

    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (root == NULL) {
            return arr;
        }
        BFS(root);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从前序与中序遍历序列构造二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-12T04:26:26.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<!-- more -->
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>和上一题基本一样0.0</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        TreeNode* tree = new TreeNode(preorder[0]);
        if (inorder.size() &lt;= 1) {
            return tree;
        }
        int i, m;
        for (i = 0; i &lt; inorder.size(); i++) {
            if (inorder[i] == preorder[0]) {
                break;
            }
        }
        m = i;
        vector&lt;int&gt; arr0, arr1, brr0, brr1;
        if (m == 0) {
            tree-&gt;left = NULL;
        }
        else {
            for (int j = 0, i = 1; j &lt; m; j++, i++) {
                arr0.push_back(preorder[i]);
                brr0.push_back(inorder[j]);
            }
            tree-&gt;left = build(arr0, brr0);
        }
        if (m &gt;= inorder.size() - 1) {
            tree-&gt;right = NULL;
        }
        else {
            for (int j = m + 1; j &lt; inorder.size(); j++) {
                arr1.push_back(preorder[j]);
                brr1.push_back(inorder[j]);
            }
            tree-&gt;right = build(arr1, brr1);
        }
        return tree;
    }

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        if (inorder.size() == 0 || preorder.size() == 0) {
            return NULL;
        }
        return build(preorder, inorder);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从中序与后序遍历序列构造二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-11T12:51:54.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<!-- more -->
<p>注意:<br>
你可以假设树中没有重复的元素。<br><br></p>
<p>例如，给出<br>
中序遍历 inorder = [9,3,15,20,7]<br>
后序遍历 postorder = [9,15,7,20,3]<br><br></p>
<p>得到结果：[3,9,20,null,null,15,7]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>二叉树的后序遍历最后一个元素是二叉树的的根节点，然后中序遍历根节点左边元素是左子树的节点，右边是右子树的节点。<br>
知道这个这道题就很简单了，用递归调用求左子树右子树。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        TreeNode* tree = new TreeNode(postorder[postorder.size() - 1]);
        if (inorder.size() &lt;= 1) {
            return tree;
        }
        int i, m; //找到根节点m
        for (i = 0; i &lt; inorder.size(); i++) {
            if (inorder[i] == postorder[postorder.size() - 1]) {
                break;
            }
        }
        m = i;
        vector&lt;int&gt; arr0, arr1, brr0, brr1;
        if (m == 0) { //考虑左边已经空了的情况
            tree-&gt;left = NULL;
        }
        else {
            for (int i = 0; i &lt; m; i++) {
                arr0.push_back(inorder[i]);
                brr0.push_back(postorder[i]);
            }
            tree-&gt;left = build(arr0, brr0);
        }
        if (m &gt;= inorder.size() - 1) {  //考虑右边已经空了的情况
            tree-&gt;right = NULL;
        }
        else {
            for (int i = m + 1, j = m; i &lt; inorder.size(); i++, j++) {
                arr1.push_back(inorder[i]);
                brr1.push_back(postorder[j]);
            }
            tree-&gt;right = build(arr1, brr1);
        }
        return tree;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) {
            return NULL;
        }
        return build(inorder, postorder);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的中序遍历(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/">
        </link>
        <updated>2020-12-10T09:26:48.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<!-- more -->
<p></p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>
输出：[1,3,2]<br><br><br>
示例 2：</p>
<p>输入：root = []<br>
输出：[]<br><br><br>
示例 3：</p>
<p>输入：root = [1]<br>
输出：[1]<br><br><br>
示例 4：</p>
<p>输入：root = [1,2]<br>
输出：[2,1]<br><br><br>
示例 5：</p>
<p>输入：root = [1,null,2]<br>
输出：[1,2]<br><br></p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>
-100 &lt;= Node.val &lt;= 100<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>就二叉树的中序遍历，没有任何坑，直接写就行</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; arr;
    void traversal(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        inorderTraversal(root-&gt;left);
        arr.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        traversal(root);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对称二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/dui-cheng-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/dui-cheng-er-cha-shu/">
        </link>
        <updated>2020-12-10T06:44:24.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<!-- more -->
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_35r5gAjUVn.png" alt="" loading="lazy"></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_BIOlXHyv1p.png" alt="" loading="lazy"></figure>
<p>进阶：</p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/symmetric-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>判断二叉树是否对称可以理解为判断一个节点的两个子树的里侧和外侧是否对称，就是后序遍历。<br>
判断外侧是否对称，传入左节点的左孩子，右节点的右孩子。<br>
判断里侧是否对称，传入左节点的右孩子，右节点的左孩子。<br>
可以用递归挨个判断，所以递归函数传的值就要是left,right两个，想通这一点就好做了。<br>
判断空的情况，<br>
左空右空       返回true<br>
左空右不空    返回false<br>
左不空右空    返回false<br>
最后是都不空，判断值</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool cmp(TreeNode* left, TreeNode* right) {
        if (left == NULL &amp;&amp; right == NULL) {
            return true;
        }
        else if (left == NULL &amp;&amp; right != NULL) {
            return false;
        }
        else if (left != NULL &amp;&amp; right == NULL) {
            return false;
        }
        //都不空判断值
        else if (left-&gt;val != right-&gt;val) {
            return false;
        }

        bool in = cmp(left-&gt;right, right-&gt;left);
        bool out = cmp(left-&gt;left, right-&gt;right);
        return in &amp;&amp; out;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) {
            return true;
        }
        return cmp(root-&gt;left, root-&gt;right);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-09T02:40:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br></p>
<!-- more -->
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br><br></p>
<p></p>
<p>示例 1：<br>
<img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="" loading="lazy"></p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：true<br><br><br>
示例 2：<br>
<img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="" loading="lazy"></p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false<br><br><br>
示例 3：</p>
<p>输入：root = []<br>
输出：true<br><br></p>
<p>提示：</p>
<p>树中的节点数在范围 [0, 5000] 内<br>
-104 &lt;= Node.val &lt;= 104<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/balanced-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>还是用二叉树的框架就行，每个节点的最大深度就是左子树或右子树中的最大深度加1</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool jud = true; //判断因子
    int deep(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = deep(root-&gt;left);
        int right = deep(root-&gt;right);
        if (abs(left - right) &gt; 1) { //如果左右子树深度相差大于1将判断因子设为false;
            jud = false;
        }
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        deep(root);
        return jud;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>