<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-07T09:26:02.773Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[杨辉三角(数组)]]></title>
        <id>https://sakuratears.cn/post/yang-hui-san-jiao/</id>
        <link href="https://sakuratears.cn/post/yang-hui-san-jiao/">
        </link>
        <updated>2020-12-07T09:18:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br></p>
<!-- more -->
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><br></p>
<p>示例:<br><br></p>
<p>输入: 5<br>
输出:<br>
[<br>
[1],<br>
[1,1],<br>
[1,2,1],<br>
[1,3,3,1],<br>
[1,4,6,4,1]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/pascals-triangle<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>简单题，直接写就行，leetcode的测试用例也没啥恶心的<s>可能是这个题没法恶心了吧</s></p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; nums;
        if (numRows == 0) {  //判断0的情况下
            return nums;
        }
        vector&lt;int&gt; num;
        num.push_back(1);
        nums.push_back(num);
        for (int i = 1; i &lt; numRows; i++) {
            vector&lt;int&gt; num;
            num.push_back(1);
            for (int j = 1; j &lt; i; j++) {
                num.push_back(nums[i - 1][j - 1] + nums[i - 1][j]); //每行数组的[j]是上一个数组的[j]位置+[j - 1]位置
            }
            num.push_back(1);
            nums.push_back(num);
        }
        return nums;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串转换整数 (atoi)(字符串)]]></title>
        <id>https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/</id>
        <link href="https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/">
        </link>
        <updated>2020-12-06T15:19:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br></p>
<!-- more -->
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br><br></p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br><br></p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br><br></p>
<p>提示：<br><br></p>
<p>本题中的空白字符只包括空格字符 ' ' 。<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br><br></p>
<p>示例 1:</p>
<p>输入: &quot;42&quot;<br>
输出: 42<br><br><br>
示例 2:</p>
<p>输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 '-', 它是一个负号。<br>
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br><br><br>
示例 3:</p>
<p>输入: &quot;4193 with words&quot;<br>
输出: 4193<br>
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。<br><br><br>
示例 4:</p>
<p>输入: &quot;words and 987&quot;<br>
输出: 0<br>
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。<br>
因此无法执行有效的转换。<br><br><br>
示例 5:</p>
<p>输入: &quot;-91283472332&quot;<br>
输出: -2147483648<br>
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。<br>
     因此返回 INT_MIN (−231) 。<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-to-integer-atoi<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<pre><code class="language-C++">class Solution {
public:
    int myAtoi(string s) {
        int i = 0, m = 0, jud = 0, n = 0, p, j = 0;
        while (s[i] == ' ') {
            i++;
        }
        if (s[i] != '-' &amp;&amp; s[i] != '+' &amp;&amp; (s[i] &gt; 57 || s[i] &lt; 48))
            return 0;
        if ((s[i] == '-' || s[i] == '+') &amp;&amp; (s[i + 1] &gt; 57 || s[i + 1] &lt; 48))
            return 0;
        while (s[i] &gt; 57 || s[i] &lt; 48) {
            i++;
        }
        if (i &gt; 0 &amp;&amp; s[i - 1] == '-') {
            jud = 1;
        }
        while (s[i] == '0') {
            i++;
        }
        if (s[i] &gt; 57 || s[i] &lt; 48) {
            return 0;
        }
        j = i;
        while (s[i] &lt;= 57 &amp;&amp; s[i] &gt;= 48) {
            i++;
            n++;//位数
        }
        if (n &gt; 10) {
            if (jud == 0)
                return pow(2, 31) - 1;
            else
                return -pow(2, 31);
        }
        p = n - 1;
        for (; j &lt; i; j++) {
            if ((m + (s[j] - 48) * pow(10, p) &gt; pow(2, 31) - 1) &amp;&amp; jud == 0) {
                return pow(2, 31) - 1;
            }
            if ((m + (s[j] - 48) * pow(10, p) &gt;= pow(2, 31)) &amp;&amp; jud == 1) {
                return -pow(2, 31);
            }
            m += (s[j] - 48) * pow(10, p);
            p--;
        }
        if (jud == 1) {
            m = -m;
        }
        return m;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[整数反转(数组)]]></title>
        <id>https://sakuratears.cn/post/zheng-shu-fan-zhuan/</id>
        <link href="https://sakuratears.cn/post/zheng-shu-fan-zhuan/">
        </link>
        <updated>2020-12-06T09:16:41.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br></p>
<!-- more -->
<p>示例 1:</p>
<p>输入: 123<br>
输出: 321<br><br></p>
<p>示例 2:</p>
<p>输入: -123<br>
输出: -321<br><br></p>
<p>示例 3:</p>
<p>输入: 120<br>
输出: 21<br><br></p>
<p>注意:<br><br></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="题解">题解</h3>
<p>多注意爆int的地方，多wa几发就过了<s>手动狗头</s></p>
<pre><code class="language-C++">class Solution {
public:
    int reverse(int x) {
        int j = 0, m = 0, num = 0, jud = 0;
        char str[1000];
        int i = 0;
        if (x &lt; 0)
        {
            if (x &lt;= -pow(2, 31)) // 负数正好没爆int，转正可能就会正好爆
                return 0;
            x = -x;
            jud = 1;
        }
        while (x &gt; 0)
        {
            str[i++] = x % 10 + 48;
            x /= 10;
        }
        str[i] = '\0';
        if (str[0] == '0')
        {
            m = 1;
        }
        for (int i = m; str[i] != '\0'; i++)
        {
            j++;
        }
        j--;
        for (int i = m; str[i] != '\0'; i++)
        {
            if ((str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) { //可能爆int的地方
                return 0;
            }
            if (num + (str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || num + (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) {  //可能爆int的地方
                return 0;
            }
            num += (str[i] - 48) * pow(10, j);
            j--;
        }
        if (jud != 0)
        {
            num = -num;
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Z 字形变换(字符串)]]></title>
        <id>https://sakuratears.cn/post/z-zi-xing-bian-huan/</id>
        <link href="https://sakuratears.cn/post/z-zi-xing-bian-huan/">
        </link>
        <updated>2020-12-05T12:51:16.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。<br></p>
<!-- more -->
<p>比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：<br></p>
<p>L   C   I   R<br>
E T O E S I I G<br>
E   D   H   N<br>
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。<br></p>
<p>请你实现这个将字符串进行指定行数变换的函数：<br></p>
<p>string convert(string s, int numRows);<br></p>
<p>示例 1:<br>
输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3<br>
输出: &quot;LCIRETOESIIGEDHN&quot;<br></p>
<p>示例 2:<br>
输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4<br>
输出: &quot;LDREOEIIECIHNTSG&quot;<br>
解释:<br></p>
<p>L     D     R<br>
E   O E   I I<br>
E C   I H   N<br>
T     S     G<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/zigzag-conversion<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></p>
<h3 id="思路">思路</h3>
<h4 id="代码1">代码1.</h4>
<p>纯暴力写出来了，贴个代码算了0.0</p>
<pre><code class="language-C++">class Solution {
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1)
            return s;
        int num = 0, m = 0, p = 1, j = 0;
        char arr[1000][1000];
        string str;
        for (int i = 0; i &lt; 1000; i++)
        {
            for (int j = 0; j &lt; 1000; j++)
            {
                arr[i][j] = NULL;
            }
        }
        for (int i = 0; num &lt; s.size(); i++)
        {
            for (j = 0; j &lt; numRows &amp;&amp; num &lt; s.size(); j++)
            {
                if (i == 0 || i == m + numRows - 1)
                {
                    m = i;
                    for (j = 0; j &lt; numRows &amp;&amp; num &lt; s.size(); j++)
                    {
                        arr[j][i] = s[num];
                        num++;
                    }
                    p = 0;
                    continue;
                }
                else
                {
                    if (j != numRows - 1 &amp;&amp; arr[j + 1][i - 1] != NULL)
                    {
                        if (i != m + 1 &amp;&amp; i != 1)
                        {
                            arr[j][i] = s[num];
                            p = 0;
                            num++;
                            continue;
                        }
                        else
                        {
                            j = numRows - 2;
                            arr[j][i] = s[num];
                            i++;
                            j = -1;
                            num++;
                            continue;
                        }
                    }
                }
            }
        }
        for (int i = 0; i &lt; s.size() &amp;&amp; str.size() != s.size(); i++)
        {
            for (int j = 0; j &lt; s.size() &amp;&amp; str.size() != s.size(); j++)
            {
                if (arr[i][j] &gt;= 41 &amp;&amp; arr[i][j] &lt;= 176)
                {
                    str += arr[i][j];
                }
            }
        }
        return str;
    }
};
</code></pre>
<h4 id="代码2">代码2</h4>
<p>1.res[i] += c： 把每个字符 c 填入对应行 s i;<br>
2.i += flag： 更新当前字符 c 对应的行索引；<br>
3.flag = - flag： 在达到 Z 字形转折点时，执行反向<br></p>
<p>把每一行放到一个字符串数组里面，利用flag就行上下控制。<s>比我那菜鸡算法好太多了</s></p>
<pre><code class="language-C++">class Solution {
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1) {
            return s;
        }
        string str[1000];
        int i = 0, flag = 1, num = 0;
        while (num &lt; s.size())
        {

            str[i] += s[num];
            i += flag;
            if (i &gt;= numRows)
            {
                flag = -flag;
                i += flag;
                i += flag;
            }
            if (i &lt; 0)
            {
                flag = -flag;
                i += flag;
                i += flag;
            }
            num++;
        }
        s = &quot;&quot;;
        for (i = 0; i &lt; numRows; i++) {
            s += str[i];
        }
        return s;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长回文子串(动态规划)]]></title>
        <id>https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/</id>
        <link href="https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/">
        </link>
        <updated>2020-12-04T11:47:51.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。<br><br></p>
<!-- more -->
<p>示例 1：<br>
输入: &quot;babad&quot;<br>
输出: &quot;bab&quot;<br>
注意: &quot;aba&quot; 也是一个有效答案。<br><br></p>
<p>示例 2：<br>
输入: &quot;cbbd&quot;<br>
输出: &quot;bb&quot;<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-palindromic-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="题解">题解</h3>
<h4 id="暴力求解">暴力求解</h4>
<p>把每个长度大于二的子串都进行验证，然后取最大，时间复杂度O(n3)，然后就愉快的超时0.0</p>
<pre><code class="language-C++">class Solution {
public:
    bool vali(string s, int i, int j)
    {
        while (i &lt;= j) {
            if (s[i] != s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }
    string longestPalindrome(string s) {
        int size = s.size();
        if (size &lt; 2)
            return s;
        int max = 1;
        string str = s.substr(0, 1);
        for (int i = 0; i &lt; size - 1; i++) {
            for (int j = i + 1; j &lt; size; j++) {
                if (j - i + 1 &gt; max &amp;&amp; vali(s, i, j)) {
                    max = j - i + 1;
                    str = s.substr(i, max);
                }
            }
        }
        return str;
    }
};
</code></pre>
<h4 id="动态规划">动态规划</h4>
<p>动态规划关键步骤状态转移：<br>
一个回文去掉两头以后，剩下的部分依然是回文；<br>
如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；<br>
如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<br>
如果里面的子串是回文，整体就是回文串；<br>
如果里面的子串不是回文串，整体就不是回文串。<br><br></p>
<p>定义dp[i][j]表示s[i....j]是否为回文串(左闭右闭)，根据“如果里面的子串判断是否回文”，可以得到转移方程：dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1] == true<br><br></p>
<p>然后考虑一下边界问题：<br><br><br>
s[i + 1......j - 1]，成立的条件为长度小于2，即j - 1 - (i + 1) &lt; 2，即j - i &lt; 3.<br>
j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。<br><br></p>
<p>如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文；<br>
如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。<br><br></p>
<p>因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。<br><br></p>
<pre><code class="language-C++">class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if (len &lt; 2)
            return s;
        int begin = 0;
        int max = 1; //记录回文子串开始位置和长度
        bool dp[len][len];
        for (int i = 0; i &lt; len; i++) {
            dp[i][i] = true; //初始化，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 
        }
        for (int j = 1; j &lt; len; j++) {
            for (int i = 0; i &lt; j; i++) {
                if (s[i] != s[j]) {
                    dp[i][j] = false;
                }
                else {
                    if (j - i &lt; 3) {
                        dp[i][j] = true;
                    }
                    else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] &amp;&amp; j - i + 1 &gt; max) {
                    begin = i;
                    max = j - i + 1;
                }
            }
        }
        string str = &quot;&quot;;
        for (int i = begin; i &lt; begin + max; i++) {
            str += s[i];
        }
        return str;
    }
};
</code></pre>
<p>思路参考：liweiwei1419</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寻找两个正序数组的中位数(分治)]]></title>
        <id>https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/</id>
        <link href="https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/">
        </link>
        <updated>2020-12-04T06:42:22.000Z</updated>
        <summary type="html"><![CDATA[<p>力扣的困难题<s>极其简单！！！</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>力扣的困难题<s>极其简单！！！</s></p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br><br></p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？<br><br></p>
<p>示例 1：<br>
输入：nums1 = [1,3], nums2 = [2]<br>
输出：2.00000<br>
解释：合并数组 = [1,2,3] ，中位数 2<br><br></p>
<p>示例 2：<br>
输入：nums1 = [1,2], nums2 = [3,4]<br>
输出：2.50000<br>
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br><br></p>
<p>示例 3：<br>
输入：nums1 = [0,0], nums2 = [0,0]<br>
输出：0.00000<br><br></p>
<p>示例 4：<br>
输入：nums1 = [], nums2 = [1]<br>
输出：1.00000<br><br></p>
<p>示例 5：<br>
输入：nums1 = [2], nums2 = []<br>
输出：2.00000<br><br></p>
<p>提示：<br><br></p>
<p>nums1.length == m<br>
nums2.length == n<br>
0 &lt;= m &lt;= 1000<br>
0 &lt;= n &lt;= 1000<br>
1 &lt;= m + n &lt;= 2000<br>
-106 &lt;= nums1[i], nums2[i] &lt;= 106<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>题目过于简单，把小的数组加到大的数组题然后sort，再找中位数。0.0<br><br></p>
<h3 id="代码">代码</h3>
<pre><code class="language-C++">class Solution {
public:
    double median(vector&lt;int&gt; nums) {
        if (nums.size() % 2 == 0) {
            double dou0 = nums[nums.size() / 2];
            double dou1 = nums[nums.size() / 2 - 1];
            return (dou0 + dou1) / 2;
        }
        else {
            double dou0 = nums[nums.size() / 2];
            return dou0;
        }
    } 
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        if (nums1.size() == 0 &amp;&amp; nums2.size() == 0)
            return 0;
        if (nums1.size() &gt;= nums2.size()) {
            for (int i = 0; i &lt; nums2.size(); i++) {
                nums1.push_back(nums2[i]);
            }
            sort(nums1.begin(), nums1.end());
            return median(nums1);
        }
        else {
            for (int i = 0; i &lt; nums1.size(); i++) {
                nums2.push_back(nums1[i]);
            }
            sort(nums2.begin(), nums2.end());
            return median(nums2);
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[朋友圈(并查集)]]></title>
        <id>https://sakuratears.cn/post/bing-cha-ji/</id>
        <link href="https://sakuratears.cn/post/bing-cha-ji/">
        </link>
        <updated>2020-12-02T11:02:21.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode547题 朋友圈</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode547题 朋友圈</p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br><br></p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br><br><br></p>
<p></p>
<p>示例 1：<br><br>
输入：<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br><br><br>
输出：2<br>
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回 2 。<br><br></p>
<p>示例 2：<br><br>
输入：<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br><br><br>
输出：1<br>
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。<br><br></p>
<p>提示：<br><br></p>
<p>1 &lt;= N &lt;= 200<br>
M[i][i] == 1<br>
M[i][j] == M[j][i]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/friend-circles<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>运用并查集算出相关集合</p>
<h4 id="并查集不优化代码">并查集不优化代码：</h4>
<pre><code class="language-C++">void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
int count() { 
    return count;
}
</code></pre>
<p>find函数是把一棵树直接接到另一棵树下面，这也就造成了树的退化(往链表退化)，就会使时间复杂度达到O(n)，union和connected都是要用到find，所以他们的时间复杂度也是O(n)。<br><br></p>
<h4 id="优化方案">优化方案</h4>
<h5 id="平衡优化">平衡优化</h5>
<p>另外开一个数组记录每棵树的“重量”(节点数),节点数少的接到节点数多的树里面，就可以降低复杂度。<br></p>
<pre><code class="language-C++">void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    
    // 小树接到大树下面，较平衡
    if (size[rootP] &gt; size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ];
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    count--;
}
</code></pre>
<br>
##### 路径~~亚索~~压缩
如果我们可以进一步压缩树的高度，让树的高度始终为常数，那find的复杂度就是O(1).
压缩完是一个根节点下面都是叶子节点，这样树的高度就为常数，非常友好。<br><br>
```C++
int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r]; //找到根节点
    int i = x, j;
    while (i != r) { //让每个节点都练到根节点上
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}
```
<br><br>
### 代码
```C++
class Solution {
public:
    int counts;
    vector<int> parent;
    vector<int> size;
    void UF(int n) {
        counts = n;
        for (int i = 0; i < n; i++) {
            parent.push_back(i);
            size.push_back(1);
        }
    }
<pre><code>void Union(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    if (rootp == rootq)
        return;
    if (size[rootp] &gt; size[rootq]) {
        parent[rootq] = rootp;
        size[rootp] += size[rootq];
    }
    else {
        parent[rootp] = rootq;
        size[rootq] += size[rootp];
    }
    counts--;
}

int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r];
    int i = x, j;
    while (i != r) {
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}

bool connected(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    return rootp == rootq;
}

int count() {
    return counts;
}

int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
    UF(M[0].size());
    for (int i = 0; i &lt; M.size(); i++) {
        for (int j = 0; j &lt; M[0].size(); j++) {
            if (M[i][j] == 1) {
                Union(i, j);
            }
        }
    }
    return counts;
}
</code></pre>
<p>};</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux一些环境配置]]></title>
        <id>https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/</id>
        <link href="https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/">
        </link>
        <updated>2020-11-29T10:00:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cc">C/C++</h2>
<p>安装环境g++,gcc,gdb<br>
终端命令</p>
<pre><code>sudo apt-get install g++
sudo apt-get install gcc
sudo apt-get install gdb
</code></pre>
<h2 id="java">Java</h2>
<p>jdk,jre</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux(deepin)日常操作]]></title>
        <id>https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/</id>
        <link href="https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/">
        </link>
        <updated>2020-11-29T09:53:09.000Z</updated>
        <summary type="html"><![CDATA[<p>记录日常使用linux一些操作<br>
deepin永远滴神！！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录日常使用linux一些操作<br>
deepin永远滴神！！！</p>
<!-- more -->
<h3 id="安装deb文件">安装deb文件</h3>
<p>在deb文件目录下终端输入<code>sudo apt-get xx.deb</code>(xx为文件名)</p>
<h3 id="打开taggz文件">打开tag.gz文件</h3>
<p>情况一(没有可执行文件)：解压缩后终端进入文件目录，然后cd进入/bin，执行./xxx.sh(xxx为程序名)<br>
情况二(有可执行文件)：直接运行可执行文件即可运行</p>
<h3 id="进入root身份">进入root身份</h3>
<p>终端输入<code>su</code>然后输入密码(开机密码)<br>
如果提示su鉴定故障可以输入<code>sudo su</code></p>
<h3 id="双系统切换时间问题">双系统切换时间问题</h3>
<p>终端输入<code>timedatectl set-local-rtc 1</code></p>
<h3 id="双系统开机默认linux更改">双系统开机默认linux更改</h3>
<p>1.ctrl+alt+T打开终端，输入<code>sudo gedit /etc/default/grub</code><br>
2.验证密码，grub配置文件被打开<br>
3.将弹出的文件中文本“GRUB-DEFAULT=0”中的0修改为2.（我这里是2，具体数字应该和选择系统的时候win系统的位置-1相同。注意这个-1，因为它是从上到下从0开始排序，所以我这里win系统是第三位，就改成2）<br>
4.保存文件。←这时可能会弹出警告框，但是一般情况下好像并没有什么关系<br>
5.在终端输入<code>sudo update-grub</code>以更新配置<br>
6.重启即可发现已经修改完毕</p>
<h3 id="linux显示系统信息">linux显示系统信息</h3>
<p>终端执行<code>sudo apt-get install screenfetch</code>安装screenfetch<br>
然后执行<code>screenfetch -s</code>显示系统信息</p>
<h3 id="bios声音问题">BIOS声音问题</h3>
<p>(deepin)有时候发生错误(比如在QQ输入框没有字的情况下按退格),会出现“嘟”的一声。这是主板BIOS声音没关的问题。<br>
执行 <code>sudo dedit /etc/modprobe.d/alsa-base-blacklist.conf</code>，输入</p>
<pre><code>blacklist pcspkr
blacklist snd_pcsp
</code></pre>
<p>保存后执行 <code>sudo update-initramfs -u</code>后重启即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机 II(贪心)]]></title>
        <id>https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/</id>
        <link href="https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/">
        </link>
        <updated>2020-11-12T12:22:38.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="题目">题目</h4>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<!-- more -->
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br><br></p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 7<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br><br></p>
<p>示例 2:<br>
输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br><br></p>
<p>示例 3:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br><br></p>
<p>提示：<br><br></p>
<p>1 &lt;= prices.length &lt;= 3 * 10 ^ 4<br>
0 &lt;= prices[i] &lt;= 10 ^ 4<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii<br><br></p>
<h4 id="思路">思路</h4>
<p>第一天买入，第三天卖出的利润是prices[3] - prices[1],也就是(prices[3] - prices[2]) + (prices[2] - porces[1])<br>
可以发现，我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润就可以了，不需要记录区间。<br><br></p>
<p><strong>这就是贪心所贪的地方，只收集正利润。</strong><br><br></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/1604803105-SzWZhG-122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.png" alt="图" loading="lazy"></figure>
<h4 id="代码">代码</h4>
<pre><code class="language-C++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for (int i = 1; i &lt; prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
</code></pre>
<p><br><br><br></p>
<p>思路借鉴作者：carlsun-2<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/122-mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin-xi/<br>
来源：力扣（LeetCode）</p>
]]></content>
    </entry>
</feed>