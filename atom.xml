<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-17T07:14:05.269Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[恢复二叉搜索树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/">
        </link>
        <updated>2020-12-16T11:44:46.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<!-- more -->
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：root = [1,3,null,null,2]<br>
输出：[3,1,null,null,2]<br>
解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。<br><br><br>
示例 2：</p>
<p>输入：root = [3,1,4,null,null,2]<br>
输出：[2,1,4,null,null,3]<br>
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。<br><br></p>
<p>提示：</p>
<p>树上节点的数目在范围 [2, 1000] 内<br>
-231 &lt;= Node.val &lt;= 231 - 1<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>二叉树搜索树中序遍历就是二叉搜索树元素从小到大排列，知道这个就好做了。<br>
采用中序遍历：每个节点和前一个相比，小的话就把前一个节点记录下来(只有第一次记录前一个节点，因为题目说明只有两个元素错位)，然后下一次遇到前一个元素比后面的元素大的情况把后一个元素记录下来。<br>
最后把两个记录点的val交换。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = new TreeNode(-2147483648);
    TreeNode* s = NULL;
    TreeNode* t = new TreeNode();

    void recover(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        recover(root-&gt;left);
        if (root-&gt;val &lt; pre-&gt;val) {
            s = (s == NULL) ? pre:s;
            t = root; 
        }
        pre = root;
        recover(root-&gt;right);
    }
    void recoverTree(TreeNode* root) {
        recover(root);
        int n = s-&gt;val;
        s-&gt;val = t-&gt;val;
        t-&gt;val = n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的锯齿形层次遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-15T09:01:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
<!-- more -->
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层次遍历如下：</p>
<p>[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>首先把每一行所有节点存放到一个数组中，然后再把这个数组存放到一个二维数组中，然后把一维数组清空。依次遍历，然后每遍历完一行下一行数组翻转即可。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子，判断是否翻转
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; arr;
        vector&lt;int&gt; brr;
        if (root == NULL) {
            return arr;
        }
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        TreeNode* node;
        while (!q.empty()) { //BFS
            int n = q.size(); //记录当前队列元素数量
            for (int i = 0; i &lt; n; i++) {
                brr.push_back(q.front()-&gt;val); //把上一层所有节点加入到一维数组中
                node = q.front();
                q.pop();
                if (node-&gt;left != NULL) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) {
                    q.push(node-&gt;right);
                }
            }
            if (jud == true) { //翻转
                reverse(brr.begin(), brr.end());
                jud = false; //更改反转因子
            }
            else { //不翻转
                jud = true; //更改反转因子
            }
            arr.push_back(brr); //把一维数组加入到二维数组
            brr.clear(); //然后把一维数组清空
        }
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的序列化与反序列化(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/">
        </link>
        <updated>2020-12-15T00:23:20.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<!-- more -->
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例:</p>
<p>你可以将以下二叉树：</p>
<pre><code>      1
     / \
    2   3
       / \
      4   5
</code></pre>
<p>序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        string str = &quot;&quot;;
        TreeNode* node;
        while (!q.empty()) {
            int n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (node == NULL) {
                    str += &quot;null,&quot;;
                    continue;
                }
                str += to_string(node-&gt;val);
                str += &quot;,&quot;;
                q.push(node-&gt;left);
                q.push(node-&gt;right);
            }
        }
        return str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data[0] == 'n') {
            return NULL;
        }
        int m = 0, n = 0;
        TreeNode* node;
        queue&lt;TreeNode*&gt; q;
        vector&lt;int&gt; arr;
        string str = &quot;&quot;;
        while (m &lt; data.size()) {
            if (data[m] == ',') {
                if (!str.empty())
                    arr.push_back(stoi(str));
                str = &quot;&quot;;
                m++;
                continue;
            }
            if (data[m] == 'n') {
                m += 4;
                if (!str.empty())
                    arr.push_back(stoi(str));
                arr.push_back(-1024);
                str = &quot;&quot;;
                continue;
            }
            str += data[m];
            m++;
        }
        TreeNode* root = new TreeNode(arr[0]);
        if (arr.size() == 1) {
            return root;
        }
        m = 1;
        q.push(root);
        while (!q.empty() &amp;&amp; m &lt; arr.size()) {
            n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (arr[m] != -1024) {
                    node-&gt;left = new TreeNode(arr[m]);
                    q.push(node-&gt;left);
                }
                else {
                    node-&gt;left = nullptr;
                }
                if (arr[m + 1] != -1024) {
                    node-&gt;right = new TreeNode(arr[m+1]);
                    q.push(node-&gt;right);
                }
                else {
                    node-&gt;right = nullptr;
                }
                m += 2;
            }
        }
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最近公共祖先(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu/">
        </link>
        <updated>2020-12-14T12:12:36.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<!-- more -->
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br><br></p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="" loading="lazy"></figure>
<p></p>
<p>示例 1:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><br><br>
示例 2:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br><br></p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>递归自底向上遍历每个节点：<br>
如果此节点为空返回空；<br>
如果此节点为p或q返回该节点；<br>
如果该节点的左孩子或右孩子为p或q，返回该节点的左子树或右子树；<br>
如果该节点左子树为p右子树为q则该节点为最近公共祖先，返回该节点。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        if (left != NULL &amp;&amp; right != NULL) {
            return root;
        }
        return left ? left : right;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无重复字符的最长子串(滑动窗口)]]></title>
        <id>https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/</id>
        <link href="https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/">
        </link>
        <updated>2020-12-13T09:21:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<!-- more -->
<p></p>
<p>示例 1:</p>
<p>输入: s = &quot;abcabcbb&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br><br><br>
示例 2:</p>
<p>输入: s = &quot;bbbbb&quot;<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br><br><br>
示例 3:</p>
<p>输入: s = &quot;pwwkew&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br><br><br>
示例 4:</p>
<p>输入: s = &quot;&quot;<br>
输出: 0<br><br></p>
<p>提示：</p>
<p>0 &lt;= s.length &lt;= 5 * 104<br>
s 由英文字母、数字、符号和空格组成<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>定义p为子串的头，j为尾部，p到j为一个窗口，如果新的元素i和窗口里的元素相同，则把p移动到i的后面。记录每一个窗口的长度，最后取最大</p>
<pre><code class="language-C++">class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        if (s.size() == 0)
        {
            return 0;
        }
        int i, j, max, n, p, jud = 0;
        i = 0;
        p = i;
        j = i + 1;
        max = 1;
        n = 1;
        for (; j &lt; s.size(); j++)
        {
            jud = 0;
            for (p = i; p &lt; j; p++)
            {
                if (s[p] == s[j])
                {
                    i = p + 1;
                    if (i == j)
                    {
                        n = 1;
                    }
                    else if (s[i] == s[j])
                    {
                        n = j - i;
                    }
                    else
                    {
                        n = j - i + 1;
                    }
                    jud = 1;
                    break;
                }
            }
            if (jud == 1)
            {
                continue;
            }
            n++;
            if (n &gt; max)
                max = n;
        }
        return max;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[填充每个节点的下一个右侧节点指针(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-13T09:10:23.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<!-- more -->
<p>struct Node {<br>
int val;<br>
Node *left;<br>
Node *right;<br>
Node *next;<br>
}<br>
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。<br><br></p>
<p></p>
<p>进阶：</p>
<p>你只能使用常量级额外空间。<br>
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。<br><br></p>
<p>输入：root = [1,2,3,4,5,6,7]<br>
输出：[1,#,2,3,#,4,5,6,7,#]<br>
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。<br><br></p>
<p>提示：</p>
<p>树中节点的数量少于 4096<br>
-1000 &lt;= node.val &lt;= 1000<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>每次循环用队列存储每一行的节点，每存储一个节点让前一个节点指向现在的节点。<br>
每次循环队列弹一个，进两个。这样每次循环完队列把上一层的节点全部弹出，把新一层的节点全部加入。</p>
<pre><code class="language-C++">/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) {
            return NULL;
        }
        int num = 0;
        queue&lt;Node*&gt; q;
        q.push(root);
        while (!q.empty()) {
            Node* node;
            Node* front;
            front = NULL;
            num = q.size();
            for (int j = 0; j &lt; num; j++) {
                node = q.front();
                q.pop();
                if (node-&gt;left != NULL)
                    q.push(node-&gt;left);
                if (node-&gt;right != NULL) 
                    q.push(node-&gt;right);
                if (front == NULL) {
                    front = node;
                }
                else {
                    front-&gt;next = node;
                    front = front-&gt;next;
                }
            };
        }
        return root;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[路径总和(二叉树)(DFS)]]></title>
        <id>https://sakuratears.cn/post/lu-jing-zong-he-er-cha-shu-dfs/</id>
        <link href="https://sakuratears.cn/post/lu-jing-zong-he-er-cha-shu-dfs/">
        </link>
        <updated>2020-12-13T07:52:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<!-- more -->
<p>说明: 叶子节点是指没有子节点的节点。<br><br></p>
<p>示例: <br>
给定如下二叉树，以及目标和 sum = 22，<br>
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>从根节点开始遍历每个节点，每次递归将此根节点和前面路径的节点传入，然后当时叶子结点时判断总路径是否相等。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子
    int num;
    void path(TreeNode* root, int n) {
        if (root == NULL) { //根为空的情况
            return;
        }
        //判断路径和是否相等，并且判断是否为叶子结点
        if (root-&gt;val + n == num &amp;&amp; root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) { 
            jud = true;
            return;
        }
        //递归遍历每个节点
        path(root-&gt;left, root-&gt;val + n);
        path(root-&gt;right, root-&gt;val + n);
    }
    bool hasPathSum(TreeNode* root, int sum) {
        //判断两者中特殊情况
        if (root == NULL &amp;&amp; sum == 0) {
            return false;
        }
        if (root == NULL &amp;&amp; sum != 0) {
            return false;
        }
        num = sum;
        path(root, 0);
        return jud;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最小(最大)路径(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu/">
        </link>
        <updated>2020-12-13T05:54:14.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明：叶子节点是指没有子节点的节点。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，找出其最小深度。<br>
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>
说明：叶子节点是指没有子节点的节点。</p>
<!-- more -->
<p>示例 1：<br>
输入：root = [3,9,20,null,null,15,7]<br>
输出：2<br><br></p>
<p>示例 2：<br>
输入：root = [2,null,3,null,4,null,5,null,6]<br>
输出：5<br><br></p>
<p>提示：<br>
树中节点数的范围在 [0, 105] 内<br>
-1000 &lt;= Node.val &lt;= 1000<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>二叉树每个节点的路径最小(最大)为左子树和右子树中最小(最大)路径加上它自己</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = minDepth(root-&gt;left);
        int right = minDepth(root-&gt;right);
        if (left == 0) {
            return right + 1;
        }
        if (right == 0) {
            return left + 1;
        }
        return min(left, right) + 1;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的层序遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-12T08:51:11.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<!-- more -->
<p></p>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
<img src="https://sakuratears.cn/post-images/1607763983990.png" alt="" loading="lazy"></p>
<p>返回其层次遍历结果：</p>
<p>[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="解题思路">解题思路</h3>
<p>在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了</p>
<h3 id="代码">代码</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; arr;

    void BFS(TreeNode* root) {
        queue&lt;TreeNode*&gt; brr;
        vector&lt;int&gt; crr;
        brr.push(root);
        int n = 0;
        while (!brr.empty()) {
            TreeNode* node = brr.front();
            n = brr.size(); //n记录当前队列元素个数
            for (int i = 0; i &lt; n; i++) { //循环n次
                if (node-&gt;left != NULL) { //左孩子不为空则添加左孩子
                    brr.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) { //右孩子不为空则添加右孩子
                    brr.push(node-&gt;right);
                }
                crr.push_back(brr.front()-&gt;val); //每次循环把队列的头元素的值添加到一个数组里
                brr.pop();
                node = brr.front(); //节点移动到下一个
            }
            arr.push_back(crr); //把当前数组元素添加到二维数组中
            crr.clear(); //当前数组清空
        }
    }

    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (root == NULL) {
            return arr;
        }
        BFS(root);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从前序与中序遍历序列构造二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-12T04:26:26.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<!-- more -->
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>和上一题基本一样0.0</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        TreeNode* tree = new TreeNode(preorder[0]);
        if (inorder.size() &lt;= 1) {
            return tree;
        }
        int i, m;
        for (i = 0; i &lt; inorder.size(); i++) {
            if (inorder[i] == preorder[0]) {
                break;
            }
        }
        m = i;
        vector&lt;int&gt; arr0, arr1, brr0, brr1;
        if (m == 0) {
            tree-&gt;left = NULL;
        }
        else {
            for (int j = 0, i = 1; j &lt; m; j++, i++) {
                arr0.push_back(preorder[i]);
                brr0.push_back(inorder[j]);
            }
            tree-&gt;left = build(arr0, brr0);
        }
        if (m &gt;= inorder.size() - 1) {
            tree-&gt;right = NULL;
        }
        else {
            for (int j = m + 1; j &lt; inorder.size(); j++) {
                arr1.push_back(preorder[j]);
                brr1.push_back(inorder[j]);
            }
            tree-&gt;right = build(arr1, brr1);
        }
        return tree;
    }

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        if (inorder.size() == 0 || preorder.size() == 0) {
            return NULL;
        }
        return build(preorder, inorder);
    }
};
</code></pre>
]]></content>
    </entry>
</feed>