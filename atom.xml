<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-05T05:34:29.800Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[最长回文子串(动态规划)]]></title>
        <id>https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/</id>
        <link href="https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/">
        </link>
        <updated>2020-12-04T11:47:51.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<!-- more -->
<p>示例 1：<br></p>
<p>输入: &quot;babad&quot;<br>
输出: &quot;bab&quot;<br>
注意: &quot;aba&quot; 也是一个有效答案。<br>
示例 2：<br></p>
<p>输入: &quot;cbbd&quot;<br>
输出: &quot;bb&quot;<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-palindromic-substring<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></p>
<h3 id="题解">题解</h3>
<h4 id="暴力求解">暴力求解</h4>
<p>把每个长度大于二的子串都进行验证，然后取最大，时间复杂度O(n3)，然后就愉快的超时0.0</p>
<pre><code class="language-C++">class Solution {
public:
    bool vali(string s, int i, int j)
    {
        while (i &lt;= j) {
            if (s[i] != s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }
    string longestPalindrome(string s) {
        int size = s.size();
        if (size &lt; 2)
            return s;
        int max = 1;
        string str = s.substr(0, 1);
        for (int i = 0; i &lt; size - 1; i++) {
            for (int j = i + 1; j &lt; size; j++) {
                if (j - i + 1 &gt; max &amp;&amp; vali(s, i, j)) {
                    max = j - i + 1;
                    str = s.substr(i, max);
                }
            }
        }
        return str;
    }
};
</code></pre>
<h4 id="动态规划">动态规划</h4>
<p>动态规划关键步骤状态转移：<br>
一个回文去掉两头以后，剩下的部分依然是回文；<br>
如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；<br>
如果一个字符串的头尾两个字符相等，才有必要继续判断下去。<br>
如果里面的子串是回文，整体就是回文串；<br>
如果里面的子串不是回文串，整体就不是回文串。<br></p>
<p>定义dp[i][j]表示s[i....j]是否为回文串(左闭右闭)，根据“如果里面的子串判断是否回文”，可以得到转移方程：dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1] == true<br></p>
<p>然后考虑一下边界问题：<br><br>
s[i + 1......j - 1]，成立的条件为长度小于2，即j - 1 - (i + 1) &lt; 2，即j - i &lt; 3.<br>
j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。<br></p>
<p>如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文；<br>
如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。<br></p>
<p>因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。<br></p>
<pre><code class="language-C++">class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if (len &lt; 2)
            return s;
        int begin = 0;
        int max = 1; //记录回文子串开始位置和长度
        bool dp[len][len];
        for (int i = 0; i &lt; len; i++) {
            dp[i][i] = true; //初始化，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 
        }
        for (int j = 1; j &lt; len; j++) {
            for (int i = 0; i &lt; j; i++) {
                if (s[i] != s[j]) {
                    dp[i][j] = false;
                }
                else {
                    if (j - i &lt; 3) {
                        dp[i][j] = true;
                    }
                    else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] &amp;&amp; j - i + 1 &gt; max) {
                    begin = i;
                    max = j - i + 1;
                }
            }
        }
        string str = &quot;&quot;;
        for (int i = begin; i &lt; begin + max; i++) {
            str += s[i];
        }
        return str;
    }
};
</code></pre>
<p>思路参考：liweiwei1419</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[寻找两个正序数组的中位数(分治)]]></title>
        <id>https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/</id>
        <link href="https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/">
        </link>
        <updated>2020-12-04T06:42:22.000Z</updated>
        <summary type="html"><![CDATA[<p>力扣的困难题<s>极其简单！！！</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>力扣的困难题<s>极其简单！！！</s></p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。<br></p>
<p>进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？<br><br></p>
<p></p>
<p>示例 1：<br></p>
<p>输入：nums1 = [1,3], nums2 = [2]<br>
输出：2.00000<br>
解释：合并数组 = [1,2,3] ，中位数 2<br></p>
<p>示例 2：<br><br>
输入：nums1 = [1,2], nums2 = [3,4]<br>
输出：2.50000<br>
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br></p>
<p>示例 3：<br>
输入：nums1 = [0,0], nums2 = [0,0]<br>
输出：0.00000<br></p>
<p>示例 4：<br>
输入：nums1 = [], nums2 = [1]<br>
输出：1.00000<br></p>
<p>示例 5：<br>
输入：nums1 = [2], nums2 = []<br>
输出：2.00000<br></p>
<p>提示：<br></p>
<p>nums1.length == m<br>
nums2.length == n<br>
0 &lt;= m &lt;= 1000<br>
0 &lt;= n &lt;= 1000<br>
1 &lt;= m + n &lt;= 2000<br>
-106 &lt;= nums1[i], nums2[i] &lt;= 106<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></p>
<h3 id="思路">思路</h3>
<p>题目过于简单，把小的数组加到大的数组题然后sort，再找中位数。0.0<br></p>
<h3 id="代码">代码</h3>
<pre><code class="language-C++">class Solution {
public:
    double median(vector&lt;int&gt; nums) {
        if (nums.size() % 2 == 0) {
            double dou0 = nums[nums.size() / 2];
            double dou1 = nums[nums.size() / 2 - 1];
            return (dou0 + dou1) / 2;
        }
        else {
            double dou0 = nums[nums.size() / 2];
            return dou0;
        }
    } 
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        if (nums1.size() == 0 &amp;&amp; nums2.size() == 0)
            return 0;
        if (nums1.size() &gt;= nums2.size()) {
            for (int i = 0; i &lt; nums2.size(); i++) {
                nums1.push_back(nums2[i]);
            }
            sort(nums1.begin(), nums1.end());
            return median(nums1);
        }
        else {
            for (int i = 0; i &lt; nums1.size(); i++) {
                nums2.push_back(nums1[i]);
            }
            sort(nums2.begin(), nums2.end());
            return median(nums2);
        }
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[朋友圈(并查集)]]></title>
        <id>https://sakuratears.cn/post/bing-cha-ji/</id>
        <link href="https://sakuratears.cn/post/bing-cha-ji/">
        </link>
        <updated>2020-12-02T11:02:21.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode547题 朋友圈</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode547题 朋友圈</p>
<!-- more -->
<h3 id="题目">题目</h3>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。<br></p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。<br><br><br></p>
<p></p>
<p>示例 1：<br><br>
输入：<br>
[[1,1,0],<br>
[1,1,0],<br>
[0,0,1]]<br><br>
输出：2<br>
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>
第2个学生自己在一个朋友圈。所以返回 2 。<br></p>
<p>示例 2：<br><br>
输入：<br>
[[1,1,0],<br>
[1,1,1],<br>
[0,1,1]]<br><br>
输出：1<br>
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。<br><br></p>
<p>提示：<br></p>
<p>1 &lt;= N &lt;= 200<br>
M[i][i] == 1<br>
M[i][j] == M[j][i]<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/friend-circles<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br></p>
<h3 id="思路">思路</h3>
<p>运用并查集算出相关集合</p>
<h4 id="并查集不优化代码">并查集不优化代码：</h4>
<pre><code class="language-C++">void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
int count() { 
    return count;
}
</code></pre>
<p>find函数是把一棵树直接接到另一棵树下面，这也就造成了树的退化(往链表退化)，就会使时间复杂度达到O(n)，union和connected都是要用到find，所以他们的时间复杂度也是O(n)。<br><br></p>
<h4 id="优化方案">优化方案</h4>
<h5 id="平衡优化">平衡优化</h5>
<p>另外开一个数组记录每棵树的“重量”(节点数),节点数少的接到节点数多的树里面，就可以降低复杂度。<br></p>
<pre><code class="language-C++">void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    
    // 小树接到大树下面，较平衡
    if (size[rootP] &gt; size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ];
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    count--;
}
</code></pre>
<br>
##### 路径~~亚索~~压缩
如果我们可以进一步压缩树的高度，让树的高度始终为常数，那find的复杂度就是O(1).
压缩完是一个根节点下面都是叶子节点，这样树的高度就为常数，非常友好。<br>
```C++
int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r]; //找到根节点
    int i = x, j;
    while (i != r) { //让每个节点都练到根节点上
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}
```
<br>
### 代码
```C++
class Solution {
public:
    int counts;
    vector<int> parent;
    vector<int> size;
    void UF(int n) {
        counts = n;
        for (int i = 0; i < n; i++) {
            parent.push_back(i);
            size.push_back(1);
        }
    }
<pre><code>void Union(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    if (rootp == rootq)
        return;
    if (size[rootp] &gt; size[rootq]) {
        parent[rootq] = rootp;
        size[rootp] += size[rootq];
    }
    else {
        parent[rootp] = rootq;
        size[rootq] += size[rootp];
    }
    counts--;
}

int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r];
    int i = x, j;
    while (i != r) {
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}

bool connected(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    return rootp == rootq;
}

int count() {
    return counts;
}

int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) {
    UF(M[0].size());
    for (int i = 0; i &lt; M.size(); i++) {
        for (int j = 0; j &lt; M[0].size(); j++) {
            if (M[i][j] == 1) {
                Union(i, j);
            }
        }
    }
    return counts;
}
</code></pre>
<p>};</p>
<pre><code></code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux一些环境配置]]></title>
        <id>https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/</id>
        <link href="https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/">
        </link>
        <updated>2020-11-29T10:00:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="cc">C/C++</h2>
<p>安装环境g++,gcc,gdb<br>
终端命令</p>
<pre><code>sudo apt-get install g++
sudo apt-get install gcc
sudo apt-get install gdb
</code></pre>
<h2 id="java">Java</h2>
<p>jdk,jre</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux(deepin)日常操作]]></title>
        <id>https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/</id>
        <link href="https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/">
        </link>
        <updated>2020-11-29T09:53:09.000Z</updated>
        <summary type="html"><![CDATA[<p>记录日常使用linux一些操作<br>
deepin永远滴神！！！</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录日常使用linux一些操作<br>
deepin永远滴神！！！</p>
<!-- more -->
<h3 id="安装deb文件">安装deb文件</h3>
<p>在deb文件目录下终端输入<code>sudo apt-get xx.deb</code>(xx为文件名)</p>
<h3 id="打开taggz文件">打开tag.gz文件</h3>
<p>情况一(没有可执行文件)：解压缩后终端进入文件目录，然后cd进入/bin，执行./xxx.sh(xxx为程序名)<br>
情况二(有可执行文件)：直接运行可执行文件即可运行</p>
<h3 id="进入root身份">进入root身份</h3>
<p>终端输入<code>su</code>然后输入密码(开机密码)<br>
如果提示su鉴定故障可以输入<code>sudo su</code></p>
<h3 id="双系统切换时间问题">双系统切换时间问题</h3>
<p>终端输入<code>timedatectl set-local-rtc 1</code></p>
<h3 id="双系统开机默认linux更改">双系统开机默认linux更改</h3>
<p>1.ctrl+alt+T打开终端，输入<code>sudo gedit /etc/default/grub</code><br>
2.验证密码，grub配置文件被打开<br>
3.将弹出的文件中文本“GRUB-DEFAULT=0”中的0修改为2.（我这里是2，具体数字应该和选择系统的时候win系统的位置-1相同。注意这个-1，因为它是从上到下从0开始排序，所以我这里win系统是第三位，就改成2）<br>
4.保存文件。←这时可能会弹出警告框，但是一般情况下好像并没有什么关系<br>
5.在终端输入<code>sudo update-grub</code>以更新配置<br>
6.重启即可发现已经修改完毕</p>
<h3 id="linux显示系统信息">linux显示系统信息</h3>
<p>终端执行<code>sudo apt-get install screenfetch</code>安装screenfetch<br>
然后执行<code>screenfetch -s</code>显示系统信息</p>
<h3 id="bios声音问题">BIOS声音问题</h3>
<p>(deepin)有时候发生错误(比如在QQ输入框没有字的情况下按退格),会出现“嘟”的一声。这是主板BIOS声音没关的问题。<br>
执行 <code>sudo dedit /etc/modprobe.d/alsa-base-blacklist.conf</code>，输入</p>
<pre><code>blacklist pcspkr
blacklist snd_pcsp
</code></pre>
<p>保存后执行 <code>sudo update-initramfs -u</code>后重启即可。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[买卖股票的最佳时机 II(贪心)]]></title>
        <id>https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/</id>
        <link href="https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/">
        </link>
        <updated>2020-11-12T12:22:38.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="题目">题目</h4>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="题目">题目</h4>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<!-- more -->
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br></p>
<p>示例 1:<br>
输入: [7,1,5,3,6,4]<br>
输出: 7<br>
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br></p>
<p>示例 2:<br>
输入: [1,2,3,4,5]<br>
输出: 4<br>
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></p>
<p>示例 3:<br>
输入: [7,6,4,3,1]<br>
输出: 0<br>
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。<br><br></p>
<p>提示：<br></p>
<p>1 &lt;= prices.length &lt;= 3 * 10 ^ 4<br>
0 &lt;= prices[i] &lt;= 10 ^ 4<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii<br></p>
<h4 id="思路">思路</h4>
<p>第一天买入，第三天卖出的利润是prices[3] - prices[1],也就是(prices[3] - prices[2]) + (prices[2] - porces[1])<br>
可以发现，我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润就可以了，不需要记录区间。<br></p>
<p><strong>这就是贪心所贪的地方，只收集正利润。</strong><br></p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/1604803105-SzWZhG-122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.png" alt="图" loading="lazy"></figure>
<h4 id="代码">代码</h4>
<pre><code class="language-C++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for (int i = 1; i &lt; prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
</code></pre>
<p><br><br><br></p>
<p>思路借鉴作者：carlsun-2<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/122-mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin-xi/<br>
来源：力扣（LeetCode）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C/C++如何传递二维数组？]]></title>
        <id>https://sakuratears.cn/post/ccru-he-chuan-di-er-wei-shu-zu/</id>
        <link href="https://sakuratears.cn/post/ccru-he-chuan-di-er-wei-shu-zu/">
        </link>
        <updated>2020-11-08T12:06:47.000Z</updated>
        <summary type="html"><![CDATA[<p>一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。</p>
]]></summary>
        <content type="html"><![CDATA[<p>一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。</p>
<!-- more -->
<p>如：<br></p>
<pre><code class="language-C++">void Func(int array[3][10]);

void Func(int array[][10]);
</code></pre>
<p><br><br><br>
​</p>
<p>二者都是合法而且等价，但是不能把第二维或者更高维的大小省略，如下面的定义是不合法的：<br></p>
<pre><code class="language-C++">void Func(int array[][]);
</code></pre>
<br>
将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。在学编译原理这么课程的时候知道编译器是这样处理数组的：<br>
<p>对于数组 int p[m][n]; 如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为：<br></p>
<pre><code class="language-C++">p + i*n + j;
```&lt;br&gt;

从以上可以看出，如果我们省略了第二维或者更高维的大小，编译器将不知道如何正确的寻址。但是我们在编写程序的时候却需要用到各个维数都不固定的二维数组作为参数，这就难办了，编译器不能识别阿，怎么办呢？不要着急，编译器虽然不能识别，但是我们完全可以不把它当作一个二维数组，而是把它当作一个普通的指针，再另外加上两个参数指明各个维数，然后我们为二维数组手工寻址，这样就达到了将二维数组作为函数的参数传递的目的，根据这个思想，我们可以把维数固定的参数变为维数随即的参数，例如：&lt;br&gt;

```C++
void Func(int array[3][10]); 

void Func(int array[][10]);
```&lt;br&gt;

变为：&lt;br&gt;

```C++
void Func(int **array, int m, int n);
```&lt;br&gt;

在转变后的函数中，array[i][j]这样的式子是不对的(不信，大家可以试一下)，因为编译器不能正确的为它寻址，所以我们需要模仿编译器的行为把array[i][j]这样的式子手工转变为&lt;br&gt;

```C++
*((int*)array + n*i + j);
</code></pre>
<p>​    <br></p>
<p>在调用这样的函数的时候，需要注意一下，如下面的例子：<br></p>
<pre><code class="language-C++">int a[3][3] = 

    {
{1, 1, 1},
{2, 2, 2},
{3, 3, 3}
};

Func(a, 3, 3);
</code></pre>
<br>
<p>根据不同编译器不同的设置，可能出现warning 或者error,可以进行强制转换如下调用：  <br></p>
<pre><code class="language-C++">Func((int**)a, 3, 3);
</code></pre>
<br>
<p>需要(int**）的强制转换，是因为二维数组和二级指针是不同的，a实质上是一个int (<em>a)[3]，它是一个数组指针，即a[0]是第一维数组的首个元素的地址，a[1]是第二维数组的首个元素的地址，a[2]是第三维数组的首个元素的地址，与int*<em>是不同的类型；如果转为int*</em>，就失去了像数组指针那样a + i = a + i</em>3的效果了<br></p>
<p>而如果又定义一个char *p[3]，它是一个一维的指针数组，此时p是指向了一个指针，而不是数组。那么这时如果定义char **q = p，就是可以的，而且可以通过q[0]，q[1]来访问字符串。<br></p>
<p>数组和指针这种东西真是太繁琐复杂了，个人愚见，在C++里就尽量使用STL，并且可以用模板的非类型形参来解决这种灵活处理不固定行列数矩阵的函数，Effective C++里面应该有介绍，并且有对这种模板的优化。<br></p>
<p>转载自CSDN</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[N皇后(回溯)]]></title>
        <id>https://sakuratears.cn/post/n-huang-hou/</id>
        <link href="https://sakuratears.cn/post/n-huang-hou/">
        </link>
        <updated>2020-11-06T00:56:46.000Z</updated>
        <summary type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
]]></summary>
        <content type="html"><![CDATA[<p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<!-- more -->
<p><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/8-queens.png" alt="图" loading="lazy"><br></p>
<p>上图为 8 皇后问题的一种解法。<br></p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br></p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。<br></p>
<p></p>
<p>示例：<br></p>
<p>输入：4<br>
输出：[<br>
[&quot;.Q..&quot;,  // 解法 1<br>
&quot;...Q&quot;,<br>
&quot;Q...&quot;,<br>
&quot;..Q.&quot;],<br></p>
<p>[&quot;..Q.&quot;,  // 解法 2<br>
&quot;Q...&quot;,<br>
&quot;...Q&quot;,<br>
&quot;.Q..&quot;]<br>
]<br>
解释: 4 皇后问题存在两个不同的解法。<br></p>
<p>提示：<br></p>
<p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。<br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/n-queens</p>
<p>经典回溯+递归问题，当发现这种情况不行时就回溯到之前的点。<br></p>
<p>代码：</p>
<pre><code class="language-C++">class Solution {
public:
    int col[12] = {};//将合适的皇后行数放入数组中
    vector&lt;vector&lt;string&gt;&gt; arr;
    vector&lt;string&gt; brr;
    char crr[100][100];
    int cnumber = 0;
    int num, number = 0, jud = 0, tot = 0;
    bool check(int c, int r)
    {
        int i = 0;
        for (i = 0; i &lt; r; i++)
        {
            if (col[i] == c || (abs(col[i] - c) == abs(i - r)))
                return false;
        }
        return true;
    }

    void DFS(int r)
    {
        if (r == num)
        {
            string str = &quot;&quot;;
            brr.clear();
            for (int j = 0; j &lt; num; j++)
            {
                str = &quot;&quot;;
                
                for (int i = 0; i &lt; num; i++)
                {
                    if (crr[j][i] == 'Q')
                        str += &quot;Q&quot;;
                    else
                        str += &quot;.&quot;;
                }
                brr.push_back(str);
            }
            arr.push_back(brr);
            return;
        }
        for (int c = 0; c &lt; num; c++)
        {
            if (check(c, r) == true)
            {
                col[r] = c;
                int i = 0;
                while (i &lt; num)
                {
                    if (i == c)
                    {
                        crr[r][i] = 'Q';
                    }
                    else
                        crr[r][i] = '.';
                    i++;
                }
                DFS(r + 1);
            }
        }
    }

    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)
    {
        num = n;
        DFS(0);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[水域大小（DFS）（BFS）]]></title>
        <id>https://sakuratears.cn/post/shui-yu-da-xiao-dfsbfs/</id>
        <link href="https://sakuratears.cn/post/shui-yu-da-xiao-dfsbfs/">
        </link>
        <updated>2020-11-04T12:46:03.000Z</updated>
        <summary type="html"><![CDATA[<p>DFS BFS例题</p>
]]></summary>
        <content type="html"><![CDATA[<p>DFS BFS例题</p>
<!-- more -->
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/pond-sizes-lcci<br></p>
<p>你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。<br></p>
<p>示例：<br></p>
<p>输入：<br>
[<br>
[0,2,1,0],<br>
[0,1,0,1],<br>
[1,1,0,1],<br>
[0,1,0,1]<br>
]<br>
输出： [1,2,4]<br>
提示：<br></p>
<p>0 &lt; len(land) &lt;= 1000<br>
0 &lt; len(land[i]) &lt;= 1000<br></p>
<p>此题DFS，BFS都可以用。<br>
(代码格式为leetcode模板格式)<br></p>
<p>代码:</p>
<h5 id="bfs">BFS</h5>
<pre><code class="language-C++">class Solution {
public:
    int n = 0;
    vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};//可以斜着所以是8个方向
    struct Node {int x; int y;};
    queue&lt;Node&gt; q;
    int BFS(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; land)
    {
        n = 1;
        Node start, node;
        start.x = i;
        start.y = j;
        land[i][j] = 1;
        q.push(start);
        while (!q.empty()) {
            start = q.front();
            q.pop();
            for (int i = 0; i &lt; 8; i++)
            {
                node.x = start.x + dirs[i][0];
                node.y = start.y + dirs[i][1];
                if (node.x &gt;= 0 &amp;&amp; node.x &lt; land.size() &amp;&amp; node.y &gt;= 0 &amp;&amp; node.y &lt; land[0].size() &amp;&amp; land[node.x][node.y] == 0)//判断是否为鱼塘
                {
                    q.push(node);
                    land[node.x][node.y] = 1;//染色
                    n++;
                }
            }
        }
        return n;
    }

    vector&lt;int&gt; pondSizes(vector&lt;vector&lt;int&gt;&gt;&amp; land) {
        vector&lt;int&gt; arr;
        for (int i = 0; i &lt; land.size(); i++)
        {
            for (int j = 0; j &lt; land[i].size(); j++)
            {
                if (land[i][j] == 0)
                {
                    arr.push_back(BFS(i, j, land));
                }
                else 
                {
                    continue;
                }
            }
        }
        sort(arr.begin(), arr.end());
        return arr;
    }
};
</code></pre>
<h5 id="dfs">DFS</h5>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    struct Node {int x; int y;};
    
    int DFS(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; land)
    {
        if (i &lt; 0 || i &gt;= land.size() || j &lt; 0 || j &gt;= land[0].size()) return 0;
        if (land[i][j] != 0) return 0;//判断是否为鱼塘
        land[i][j] = 1;//染色
        Node next;
        int n = 1;
        for (int m = 0; m &lt; 8; m++)
        {
            next.x = i + dirs[m][0];
            next.y = j + dirs[m][1];
            n += DFS(next.x, next.y, land);
        }
        return n;
    }

    vector&lt;int&gt; pondSizes(vector&lt;vector&lt;int&gt;&gt;&amp; land) {
        vector&lt;int&gt; arr;
        for (int i = 0; i &lt; land.size(); i++)
        {
            for (int j = 0; j &lt; land[i].size(); j++)
            {
                if (land[i][j] == 0)
                {
                    arr.push_back(DFS(i, j, land));
                }
                else 
                {
                    continue;
                }
            }
        }
        sort(arr.begin(), arr.end());
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[四数之和（双指针）]]></title>
        <id>https://sakuratears.cn/post/si-shu-zhi-he/</id>
        <link href="https://sakuratears.cn/post/si-shu-zhi-he/">
        </link>
        <updated>2020-11-01T13:32:08.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="题目描述">题目描述：</h4>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="题目描述">题目描述：</h4>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<!-- more -->
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</p>
<p>满足要求的四元组集合为：<br>
[<br>
[-1,  0, 0, 1],<br>
[-2, -1, 1, 2],<br>
[-2,  0, 0, 2]<br>
]</p>
<p>来源：力扣18题（LeetCode）<br>
链接：https://leetcode-cn.com/problems/4sum</p>
<h4 id="题目分析">题目分析</h4>
<p>此题可以用双指针法解决，先用两个for循环i, j遍历前面，两个指针left, right收缩，当nums[i] + nums[j] + nums[left] + nums[right] == target 时，入数组，然后注意一下去重。（三数之和一个for循环，四数之和用两个，五数之和用三个......）</p>
<h4 id="代码题解">代码题解</h4>
<pre><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target)
{
    vector&lt;vector&lt;int&gt;&gt; re;
    sort(nums.begin(), nums.end());
    for (int i = 0; i &lt; nums.size(); i++)
    {
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])//去重
            continue;
        for (int j = i + 1; j &lt; nums.size(); j++)
        {
            if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])//去重
                continue;
            int left = j + 1;
            int right = nums.size() - 1;
            while (left &lt; right)
            {
                if (nums[i] + nums[j] + nums[left] + nums[right] &gt; target)
                {
                    right--;
                }
                else if (nums[i] + nums[j] + nums[left] + nums[right] &lt; target)
                {
                    left++;
                }
                else
                {
                    re.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]});//下面两个循环去重
                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1])
                    {
                        right--;
                    }
                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1])
                    {
                        left++;
                    }
                    //找到一个适合的后左右指针收缩
                    left++;
                    right--;
                }
            }
        }
    }
    return re;
}
</code></pre>
]]></content>
    </entry>
</feed>