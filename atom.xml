<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-27T12:19:21.300Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode 205. 同构字符串(哈希表)]]></title>
        <id>https://sakuratears.cn/post/leetcode-205-tong-gou-zi-fu-chuan-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/leetcode-205-tong-gou-zi-fu-chuan-ha-xi-biao/">
        </link>
        <updated>2020-12-27T12:13:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: s = &quot;egg&quot;, t = &quot;add&quot;<br>
输出: true<br>
示例 2:</p>
<p>输入: s = &quot;foo&quot;, t = &quot;bar&quot;<br>
输出: false<br>
示例 3:</p>
<p>输入: s = &quot;paper&quot;, t = &quot;title&quot;<br>
输出: true<br>
说明:<br>
你可以假设 s 和 t 具有相同的长度。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/isomorphic-strings<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>题意为：s中任意一个字符都在t中有唯一对应，t中任意一个字符也都在s中有唯一对应。<br>
所以用两个哈希表一一对应再判断。</p>
<pre><code class="language-C++">class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map&lt;char, char&gt; map1;
        unordered_map&lt;char, char&gt; map2;
        for (int i = 0; i &lt; s.size(); i++) {
            if (map1.find(s[i]) == map1.end()) { // map1保存s[i] 到 t[j]的映射
                map1[s[i]] = t[i];
            }
            if (map2.find(t[i]) == map2.end()) { // map2保存t[j] 到 s[i]的映射
                map2[t[i]] = s[i];
            }
            // 发现映射 对应不上，立刻返回false
            if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {
                return false;
            }
        }
        return true;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 13. 罗马数字转整数(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-13-luo-ma-shu-zi-zhuan-zheng-shu-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-13-luo-ma-shu-zi-zhuan-zheng-shu-tan-xin/">
        </link>
        <updated>2020-12-26T06:16:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<!-- more -->
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p></p>
<p>示例 1:</p>
<p>输入: &quot;III&quot;<br>
输出: 3<br>
示例 2:</p>
<p>输入: &quot;IV&quot;<br>
输出: 4<br>
示例 3:</p>
<p>输入: &quot;IX&quot;<br>
输出: 9<br>
示例 4:</p>
<p>输入: &quot;LVIII&quot;<br>
输出: 58<br>
解释: L = 50, V= 5, III = 3.<br>
示例 5:</p>
<p>输入: &quot;MCMXCIV&quot;<br>
输出: 1994<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>提示：</p>
<p>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>
IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。<br>
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/roman-to-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>把罗马数字对应的整数存放到一个数组里，对s从头遍历，如果s[i] != reps[j][0]则j++，因为reps是字符串而且要判断的是首字母，所以是reps[j][0]。当s[i] == reps[j][0]时，还需要判断是不是特殊情况比如：四对应的IV，是对应的IX</p>
<p><code>if (reps[j].size() &gt; 1)</code>则说明reps当前对应的字符串属于特殊情况，<code>if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1])</code>说明s当前对应的数字与reps当前对应的数字相匹配，因为一个数占了两个字符所以要i++，j++。再把num累加。</p>
<p><code>if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1])</code>不满足的情况有可能为s对应IV，reps对应IX，这样虽然前面的I相同但是后面的字符不相同，这种情况就让i不动（因为每次循环结束都会i++，所以先i--），j往后挪一个。</p>
<p>非特殊情况即<code>reps[j].size() &lt;= 1</code>直接将num累加即可</p>
<pre><code class="language-C++">class Solution {
public:
    int romanToInt(string s) {
        if (s.size() == 0) {
            return 0;
        }
        int values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};
		string reps[]= {&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
        int j = 0, num = 0;
        for (int i = 0; i &lt; s.size(); i++) {
            while (s[i] != reps[j][0]) {
                j++;
            }
            if (reps[j].size() &gt; 1) {
                if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1]) {
                    i++;
                    num += values[j];
                    j++;
                }
                else {
                    i--;
                    j++;
                }
            }
            else {
                num += values[j];
            }
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序(排序)]]></title>
        <id>https://sakuratears.cn/post/dui-pai-xu/</id>
        <link href="https://sakuratears.cn/post/dui-pai-xu/">
        </link>
        <updated>2020-12-25T10:02:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定义">定义</h3>
<p><strong>堆排序</strong>：是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p>
<h3 id="概述">概述</h3>
<p>若以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。<br>
重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p>
<h3 id="堆节点的访问">堆节点的访问</h3>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<p>父节点i的左子节点在位置(2i + 1);<br>
父节点i的右子节点在位置(2i + 2));<br>
子节点i的父节点在位置(i - 1) / 2;</p>
<h3 id="操作">操作</h3>
<p>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void swap(int *a, int *b)
{
    int temp = *b;
    *b = *a;
    *a = temp;
}

void max_heapify(int arr[], int start, int end)
{
    // 建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son &lt;= end)
    {                                                  // 若子节点指标在范围内才做比较
        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] &gt; arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数
            return;
        else
        { // 否则交换父子内容再继续子节点和孙节点比较
            swap(&amp;arr[dad], &amp;arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len)
{
    int i;
    // 初始化，i从最后一个父节点开始调整
    for (i = len / 2 - 1; i &gt;= 0; i--)
        max_heapify(arr, i, len - 1);
    // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕
    for (i = len - 1; i &gt; 0; i--)
    {
        swap(&amp;arr[0], &amp;arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main()
{
    // int arr[] = {9, 10, 5, 11, 12, 7};
    // int len = (int)sizeof(arr) / sizeof(*arr);

    int len;
    printf(&quot;输入数组长度&quot;);
    scanf(&quot;%d&quot;, &amp;len);
    int *arr = (int *)malloc(sizeof(int) * len);
    printf(&quot;输入数组：&quot;);
    for (int i = 0; i &lt; len; i++)
    {
        scanf(&quot;%d&quot;, &amp;arr[i]);
    }
    heap_sort(arr, len);
    int i;
    for (i = 0; i &lt; len; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>(来自：维基百科)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 455. 分发饼干(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-455-fen-fa-bing-gan-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-455-fen-fa-bing-gan-tan-xin/">
        </link>
        <updated>2020-12-25T09:05:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<!-- more -->
<p>示例 1:<br>
输入: g = [1,2,3], s = [1,1]<br>
输出: 1<br>
解释:<br>
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>
所以你应该输出1。</p>
<p>示例 2:<br>
输入: g = [1,2], s = [1,2,3]<br>
输出: 2<br>
解释:<br>
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>
你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>
所以你应该输出2.<br>
 <br>
提示：</p>
<p>1 &lt;= g.length &lt;= 3 * 104<br>
0 &lt;= s.length &lt;= 3 * 104<br>
1 &lt;= g[i], s[j] &lt;= 231 - 1</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/assign-cookies<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>现将孩子胃口数组和饼干尺寸排序，然后遍历孩子胃口，如果孩子胃口大于当前饼干尺寸饼干尺寸指针后移直到当前孩子胃口小于等于当前饼干尺寸</p>
<pre><code class="language-C++">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int n = 0;
        for (int i = 0, j = 0; i &lt; g.size(); i++) {
            while (j &lt; s.size() &amp;&amp; g[i] &gt; s[j]) {
                j++;
            }
            if (j &lt; s.size() &amp;&amp; g[i] &lt;= s[j]) {
                n++;
                j++;
            }
        }
        return n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 135. 分发糖果(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-135-fen-fa-tang-guo-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-135-fen-fa-tang-guo-tan-xin/">
        </link>
        <updated>2020-12-24T11:14:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>
相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>
那么这样下来，老师至少需要准备多少颗糖果呢？</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>
相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>
那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: [1,0,2]<br>
输出: 5<br>
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。<br>
示例 2:</p>
<p>输入: [1,2,2]<br>
输出: 4<br>
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>
第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/candy<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>根据题意得出规则：<br>
A在B左边<br>
左规则：<code>if(ratings[A] &lt; ratings[B])</code>则B获得糖比A多<br>
右规则：<code>if(ratings[A] &gt; ratings[B])</code>则A获得糖比B多</p>
<pre><code class="language-markdown">1.先从左到右遍历，将每个人得到糖果数记录到left数组中
    1.将left用1填充（给所有学生一个糖果）
    2.``if (ratings[i] &gt; ratings[i - 1])``则``left[i] = left[i - 1] + 1``
    3.``if (ratings[i] &lt; ratings[i - 1])``不变
2.再从右到左遍历，将每个人得到糖果数记录到right数组中，规则满足右规则
3.最终取left[i]和right[i]中最大值，即可同时满足左规则和右规则
</code></pre>
<pre><code class="language-C++">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        int num = 0;
        vector&lt;int&gt; left(ratings.size(), 1);
        vector&lt;int&gt; right(ratings.size(), 1);
        for (int i = 1; i &lt; ratings.size(); i++) {
            if (ratings[i] &gt; ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        for (int i = ratings.size() - 2; i &gt;= 0; i--) {
            if (ratings[i] &gt; ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }
        for (int i = 0; i &lt; ratings.size(); i++) {
            num += max(left[i], right[i]);
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[切分木棒(DFS)(BFS)]]></title>
        <id>https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/</id>
        <link href="https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/">
        </link>
        <updated>2020-12-24T09:29:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
<!-- more -->
<p><img src="http://www.ituring.com.cn/figures/2017/ProgrammerPuzzle/07.d01z.014.png" alt="图 2　n ＝ 8，m ＝ 3 的时候" loading="lazy"><br>
求最多有 m 个人时，最少要切分几次。譬如 n ＝ 8，m＝ 3 时如图所示，切分 4 次就可以了。</p>
<p>作者：图灵教育<br>
链接：https://leetcode-cn.com/leetbook/read/interesting-algorithm-puzzles-for-programmers/90ach5/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1dfs">方法1：DFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	if (num &gt;= n) { //达到要求结束
		return 0;
	}
	else if (num &lt; m) { //目前段数小于人数，直接段数*2
		return 1 + sil(m, n, num * 2);
	}
	else { //目前段数大于等于人数，增加m段
		return 1 + sil(m, n, num + m);
	}
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
<h4 id="方法2bfs">方法2：BFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	int count = 0;
	while (num &lt; n) {
		num += num &lt; m ? num : m;
        /*
		if (num &lt; m) {
			num += num;
		}
		else {
			num += m;
		}
		count++;
		*/
		count++;
	}
	return count;
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 387. 字符串中的第一个唯一字符(哈希表)]]></title>
        <id>https://sakuratears.cn/post/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu-ha-xi-biao/">
        </link>
        <updated>2020-12-23T11:54:29.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<!-- more -->
<p>示例：</p>
<p>s = &quot;leetcode&quot;<br>
返回 0</p>
<p>s = &quot;loveleetcode&quot;<br>
返回 2</p>
<p>提示：你可以假定该字符串只包含小写字母。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1哈希表">方法1：哈希表</h4>
<pre><code class="language-C++">class Solution {
public:
    int firstUniqChar(string s) {
        if (s.size() &lt;= 0) {
            return -1;
        }
        map&lt;int, int&gt; smap;
        for (char ch : s) {
            smap[ch]++;
        }
        for (int i = 0; i &lt; s.size(); i++) {
            if (smap[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
<h4 id="方法2数组">方法2：数组</h4>
<pre><code class="language-C++">class Solution {
public:
    int firstUniqChar(string s) {
        int map[26] = {0};
        for (int i = 0; i &lt; s.size(); i++) {
            map[s[i] - 'a']++;
        }
        for (int i = 0; i &lt; s.size(); i++) {
            if (map[s[i] - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 12. 整数转罗马数字(字符串)(贪心算法)]]></title>
        <id>https://sakuratears.cn/post/leetcode-12-zheng-shu-zhuan-luo-ma-shu-zi-zi-fu-chuan/</id>
        <link href="https://sakuratears.cn/post/leetcode-12-zheng-shu-zhuan-luo-ma-shu-zi-zi-fu-chuan/">
        </link>
        <updated>2020-12-22T11:15:18.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<!-- more -->
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p>示例 1:</p>
<p>输入: 3<br>
输出: &quot;III&quot;<br>
示例 2:</p>
<p>输入: 4<br>
输出: &quot;IV&quot;<br>
示例 3:</p>
<p>输入: 9<br>
输出: &quot;IX&quot;<br>
示例 4:</p>
<p>输入: 58<br>
输出: &quot;LVIII&quot;<br>
解释: L = 50, V = 5, III = 3.<br>
示例 5:</p>
<p>输入: 1994<br>
输出: &quot;MCMXCIV&quot;<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/integer-to-roman<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1暴力解法">方法1:暴力解法</h4>
<p>把每种情况都写出来然后直接暴力解决</p>
<pre><code class="language-C++">class Solution {
public:
    string five(int num) {
        string str;
         if (num == 4) {
                str = &quot;IV&quot;;
        }
        else if (num == 5) {
            str = &quot;V&quot;;
        }
        else {
            for (int i = 0; i &lt; num; i++) {
                str += 'I';
            }
        }
        return str;
    }

    string ten(int num) {
        string str;
        if (num == 9) {
            str = &quot;IX&quot;;
        }
        else if (num == 10) {
            str = &quot;X&quot;;
        }
        else {
            str = &quot;V&quot;;
            for (int i = 0; i &lt; num - 5; i++) {
                str += 'I';
            }
        }
        return str;
    }

    string fifty(int num) {
        string str;
        if (num == 40) {
            str = &quot;XL&quot;;
        }
        else if (num == 50) {
            str = &quot;L&quot;;
        }
        else if (num &gt; 40) {
            str = &quot;XL&quot;;
            int n = num - 40;
            if (n &gt; 5) {
                str += ten(n);
            }
            else {
                str += five(n);
            }
        }
        else {
            int n = num / 10;
            num %= 10;
            for (int i = 0; i &lt; n; i++) {
                str += 'X';
            }
            if (num &lt;= 5) {
                str += five(num);
            }
            else {
                str += ten(num);
            }
        }
        return str;
    }

    string hundred(int num) {
        string str;
        if (num == 90) {
            str = &quot;XC&quot;;
        }
        else if (num == 100) {
            str = &quot;C&quot;;
        }
        else if (num &gt; 90) {
            str = &quot;XC&quot;;
            int n = num - 90;
            if (n &gt; 5) {
                str += ten(n);
            }
            else {
                str += five(n);
            }            
        }
        else {
            str = &quot;L&quot;;
            num -= 50;
            int n = num / 10;
            num %= 10;
            for (int i = 0; i &lt; n; i++) {
                str += 'X';
            }
            if (num &lt;= 5) {
                str += five(num);
            }
            else {
                str += ten(num);
            }            
        }
        return str;
    }

    string fiveh(int num) {
        string str;
        if (num == 400) {
            str = &quot;CD&quot;;
        }
        else if (num == 500) {
            str = &quot;D&quot;;
        }
        else if (num &gt; 400) {
            str = &quot;CD&quot;;
            int n = num - 400;
            if (n &gt; 50) {
                str += hundred(n);
            }
            else {
                str += fifty(n);
            }
        }
        else {
            int n = num / 100;
            num %= 100;
            for (int i = 0; i &lt; n; i++) {
                str += 'C';
            }
            if (num &gt; 50) {
                str += hundred(num);
            }
            else {
                str += fifty(num);
            }
        }
        return str;
    }

    string thousand(int num) {
        string str;
        if (num == 900) {
            str = &quot;CM&quot;;
        }
        else if (num == 1000) {
            str = &quot;M&quot;;
        }
        else if (num &gt; 900) {
            str = &quot;CM&quot;;
            int n = num - 900;
            // cout&lt;&lt;num;
            if (n &gt; 50) {
                str += hundred(n);
            }
            else {
                str += fifty(n);
            }
        }
        else {
            str = &quot;D&quot;;
            num -= 500;
            int n = num / 100;
            num %= 100;
            // cout&lt;&lt;num;
            for (int i = 0; i &lt; n; i++) {
                str += &quot;C&quot;;
            }
            if (num &gt; 50) {
                str += hundred(num);
            }
            else {
                // cout&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;fifty(num);
                str += fifty(num);
            }
        }
        return str;
    }

    string more(int num) {
        string str;
        int n = num / 1000;
        num %= 1000;
        for (int i = 0; i &lt; n; i++) {
            str += &quot;M&quot;;
        }
        if (num &lt;= 5) {
            str += five(num);
        }
        else if (num &lt;= 10) {
            str += ten(num);
        }
        else if (num &lt;= 50) {
            str += fifty(num);
        }
        else if (num &lt;= 100) {
            str += hundred(num);
        }
        else if (num &lt;= 500) {
            str += fiveh(num);
        }
        else if (num &lt;= 1000) {
            str += thousand(num);
        }
        return str;
    }

    string intToRoman(int num) {
        string str = &quot;&quot;;
        if (num &gt; 0) {
            if (num &lt;= 5) {
                str += five(num);
            }
            else if (num &lt;= 10) {
                str += ten(num);
            }
            else if (num &lt;= 50) {
                str += fifty(num);
            }
            else if (num &lt;= 100) {
                str += hundred(num);
            }
            else if (num &lt;= 500) {
                str += fiveh(num);
            }
            else if (num &lt;= 1000) {
                str += thousand(num);
            }
            else {
                str += more(num);
            }
        }
        else {
            str = &quot;&quot;;
        }
        return str;
    }
};
</code></pre>
<h4 id="方法2贪心算法">方法2:贪心算法</h4>
<p>把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中，并且按照阿拉伯数字的大小降序排列。每次尽可能优先使用较大数值对应的字符</p>
<pre><code class="language-C++">class Solution {
public:
	string intToRoman(int num) {
		int values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};
		string reps[]= {&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
		string res;
		for(int i=0; i&lt;13; i++) {
			while(num&gt;=values[i]) {
				num -= values[i];
				res += reps[i];
			}
		}
		return res;
	}
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 69. x 的平方根(二分)]]></title>
        <id>https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/</id>
        <link href="https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/">
        </link>
        <updated>2020-12-21T09:32:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: 4<br>
输出: 2<br>
示例 2:</p>
<p>输入: 8<br>
输出: 2<br>
说明: 8 的平方根是 2.82842...,<br>
     由于返回类型是整数，小数部分将被舍去。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sqrtx<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>采用二分法每次找到中间元素与x比较大小，大则在左边查找，小则在右边查找<br>
每次判断一下lo（最左边元素）的平方与lo + 1的平方：<br>
<code>if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x)</code>这就说明x平方根是lo到lo + 1之间的值，所以直接返回lo即可<br>
判断hi同理</p>
<pre><code class="language-C++">class Solution {
public:
    int res = 0;
    void Sqrt(int lo, int hi, int x) {
        if (pow(lo, 2) == x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) == x) {
            res = hi;
            return;
        }
        else if (pow(lo, 2) &lt; x &amp;&amp; pow(lo + 1, 2) &gt; x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x) {
            res = hi;
            return;
        }
        else if (pow((lo + hi) / 2, 2) == x) {
            res = (lo + hi) / 2;
            return;
        }
        else if (pow((lo + hi) / 2, 2) &lt; x) {
            lo = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
        else if (pow((lo + hi) / 2, 2) &gt; x) {
            hi = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
    }
    int mySqrt(int x) {
        int lo = 0, hi = x;
        Sqrt(lo, hi, x);
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言实现各种进制之间转换]]></title>
        <id>https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/</id>
        <link href="https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/">
        </link>
        <updated>2020-12-20T11:55:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-C">#include &lt;Windows.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 50

//进制转换

char *Ten_MoreThanTen(int, int); //10进制数转换成10以上进制数的函数

int MoreThanTen_Ten(int, char[]); //10以上进制数转换成10进制数的函数

int Ten_LessThanTen(int, int); //10进制数转换成10以内进制数的函数

int LessThanTen_Ten(int, int); //10以内进制数转换成10进制数的函数

char array[N] = &quot;\0&quot;; //全局变量，用于存储转换后并且倒置了的数据

int LessThanTen_Ten(int before, int num) //10以内转换10，参数brfore为初始进制,num为初始数值

{

    double result = 0.0; //转换成10进制后的结果

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现按权展开相加

    {

        result += pow(before, i) * (num % 10);

        num /= 10;
    }

    return (int)result; //返回值为转换后的结果
}

int Ten_LessThanTen(int after, int num) //10转换10以内，参数after为转换后的进制，num为10进制数值

{

    double result = 0.0; //double类型因为pow函数的返回值为double类型

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现连续取余

    {

        result += (num % after) * pow(10, i);

        num /= after;
    }

    return (int)result;
}

int MoreThanTen_Ten(int before, char num[]) //10以上转换10

{

    int i = 0;

    double result = 0.0;

    int length = strlen(num);

    for (i = length - 1; i &gt;= 0; i--)

    {

        //利用ASCALL码将所有元素转换成对应的整型

        if ('A' &lt;= num[i] &amp;&amp; num[i] &lt;= 'Z')

            result += pow(before, length - i - 1) * (num[i] - 55);

        else if ('a' &lt;= num[i] &amp;&amp; num[i] &lt;= 'z')

            result += pow(before, length - i - 1) * (num[i] - 87);

        else if ('0' &lt;= num[i] &amp;&amp; num[i] &lt;= '9')

            result += pow(before, length - i - 1) * (num[i] - 48);
    }

    return (int)result;
}

char *Ten_MoreThanTen(int after, int num) //10转换10以上

{

    int i = 0;

    int j = 0;

    int tmp = 0; //存储每次余数的中间变量

    char tmp_array[N] = &quot;\0&quot;; //转换后未倒置的数组

    for (i = 0; num &gt; 0; i++)

    {

        tmp = num % after;

        if (tmp &lt; 10) //对大于等于10的余数进行字母转换

            tmp_array[i] = tmp + '0';

        else

            tmp_array[i] = tmp + 'A' - 10;

        num /= after;
    }

    for (j = 0; i &gt; 0; i--, j++) //倒置

    {

        array[j] = tmp_array[i - 1];

        array[j + 1] = '\0';
    }

    return array; //输出转换后存储数据的字符串地址
}

int main()

{

    int before = 0; //转换前的进制数

    int after = 0; //转换后的进制数

    int num1 = 0; //要转换的十进制以内的数

    char array_num1[N] = &quot;\0&quot;; //要转换的十进制以上的数

    int num2 = 0; //转换之后的数

    char *str_num2; //转换之后的数的地址

    int tmp_num1 = 0; //判断输入是否合法时代替num1的中间变量

    int i = 0;

    int m = 0; //计数器

    while (1) //整个while语句用于录入以及判断输入是否合法

    {

        printf(&quot;初始进制：&quot;);

        scanf(&quot;%d&quot;, &amp;before);

        printf(&quot;目标进制：&quot;);

        scanf(&quot;%d&quot;, &amp;after);

        printf(&quot;初始数值：&quot;);

        if (before &gt; 10) //通过对初始进制判断，决定

            scanf(&quot;%s&quot;, array_num1);

        else

            scanf(&quot;%d&quot;, &amp;num1);

        for (i = 0, tmp_num1 = num1; tmp_num1 != 0; i++)

        {

            if ((tmp_num1 % 10) &lt;= before &amp;&amp; tmp_num1 % 10 &gt;= 0 &amp;&amp; tmp_num1 % 10 &lt;= 9)

                m++;

            tmp_num1 /= 10;
        }

        if (m == i) //判断输入的数据每一位是否都小于等于进制数

            break;

        else

        {

            m = 0; //对计数器m重新初始化

            fflush(stdin); //清空缓存区

            printf(&quot;输入有误！请重新输入：\n&quot;);
        }
    }

    //将进制转换的四种情况分别表示

    if (before &lt;= 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%d\n&quot;, before, num1, after, num2);
    }

    else if (before &gt; 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%d\n&quot;, before, array_num1, after, num2);
    }

    else if (before &lt;= 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%s\n&quot;, before, num1, after, str_num2);
    }

    else if (before &gt; 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%s\n&quot;, before, array_num1, after, str_num2);
    }

    system(&quot;pause&quot;);

    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>