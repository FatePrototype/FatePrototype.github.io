<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-21T10:09:22.786Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[LeetCode 69. x 的平方根(二分)]]></title>
        <id>https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/</id>
        <link href="https://sakuratears.cn/post/leetcode-69-x-de-ping-fang-gen-er-fen/">
        </link>
        <updated>2020-12-21T09:32:31.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>实现 int sqrt(int x) 函数。<br>
计算并返回 x 的平方根，其中 x 是非负整数。<br>
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: 4<br>
输出: 2<br>
示例 2:</p>
<p>输入: 8<br>
输出: 2<br>
说明: 8 的平方根是 2.82842...,<br>
     由于返回类型是整数，小数部分将被舍去。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/sqrtx<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>采用二分法每次找到中间元素与x比较大小，大则在左边查找，小则在右边查找<br>
每次判断一下lo（最左边元素）的平方与lo + 1的平方：<br>
<code>if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x)</code>这就说明x平方根是lo到lo + 1之间的值，所以直接返回lo即可<br>
判断hi同理</p>
<pre><code class="language-C++">class Solution {
public:
    int res = 0;
    void Sqrt(int lo, int hi, int x) {
        if (pow(lo, 2) == x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) == x) {
            res = hi;
            return;
        }
        else if (pow(lo, 2) &lt; x &amp;&amp; pow(lo + 1, 2) &gt; x) {
            res = lo;
            return;
        }
        else if (pow(hi, 2) &lt; x &amp;&amp; pow(hi + 1, 2) &gt; x) {
            res = hi;
            return;
        }
        else if (pow((lo + hi) / 2, 2) == x) {
            res = (lo + hi) / 2;
            return;
        }
        else if (pow((lo + hi) / 2, 2) &lt; x) {
            lo = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
        else if (pow((lo + hi) / 2, 2) &gt; x) {
            hi = (lo + hi) / 2;
            Sqrt(lo, hi, x);
        }
    }
    int mySqrt(int x) {
        int lo = 0, hi = x;
        Sqrt(lo, hi, x);
        return res;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C语言实现各种进制之间转换]]></title>
        <id>https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/</id>
        <link href="https://sakuratears.cn/post/c-yu-yan-shi-xian-ge-chong-jin-zhi-zhi-jian-zhuan-huan/">
        </link>
        <updated>2020-12-20T11:55:47.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-C">#include &lt;Windows.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 50

//进制转换

char *Ten_MoreThanTen(int, int); //10进制数转换成10以上进制数的函数

int MoreThanTen_Ten(int, char[]); //10以上进制数转换成10进制数的函数

int Ten_LessThanTen(int, int); //10进制数转换成10以内进制数的函数

int LessThanTen_Ten(int, int); //10以内进制数转换成10进制数的函数

char array[N] = &quot;\0&quot;; //全局变量，用于存储转换后并且倒置了的数据

int LessThanTen_Ten(int before, int num) //10以内转换10，参数brfore为初始进制,num为初始数值

{

    double result = 0.0; //转换成10进制后的结果

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现按权展开相加

    {

        result += pow(before, i) * (num % 10);

        num /= 10;
    }

    return (int)result; //返回值为转换后的结果
}

int Ten_LessThanTen(int after, int num) //10转换10以内，参数after为转换后的进制，num为10进制数值

{

    double result = 0.0; //double类型因为pow函数的返回值为double类型

    int i = 0;

    for (i = 0; num != 0; i++) //利用for循环实现连续取余

    {

        result += (num % after) * pow(10, i);

        num /= after;
    }

    return (int)result;
}

int MoreThanTen_Ten(int before, char num[]) //10以上转换10

{

    int i = 0;

    double result = 0.0;

    int length = strlen(num);

    for (i = length - 1; i &gt;= 0; i--)

    {

        //利用ASCALL码将所有元素转换成对应的整型

        if ('A' &lt;= num[i] &amp;&amp; num[i] &lt;= 'Z')

            result += pow(before, length - i - 1) * (num[i] - 55);

        else if ('a' &lt;= num[i] &amp;&amp; num[i] &lt;= 'z')

            result += pow(before, length - i - 1) * (num[i] - 87);

        else if ('0' &lt;= num[i] &amp;&amp; num[i] &lt;= '9')

            result += pow(before, length - i - 1) * (num[i] - 48);
    }

    return (int)result;
}

char *Ten_MoreThanTen(int after, int num) //10转换10以上

{

    int i = 0;

    int j = 0;

    int tmp = 0; //存储每次余数的中间变量

    char tmp_array[N] = &quot;\0&quot;; //转换后未倒置的数组

    for (i = 0; num &gt; 0; i++)

    {

        tmp = num % after;

        if (tmp &lt; 10) //对大于等于10的余数进行字母转换

            tmp_array[i] = tmp + '0';

        else

            tmp_array[i] = tmp + 'A' - 10;

        num /= after;
    }

    for (j = 0; i &gt; 0; i--, j++) //倒置

    {

        array[j] = tmp_array[i - 1];

        array[j + 1] = '\0';
    }

    return array; //输出转换后存储数据的字符串地址
}

int main()

{

    int before = 0; //转换前的进制数

    int after = 0; //转换后的进制数

    int num1 = 0; //要转换的十进制以内的数

    char array_num1[N] = &quot;\0&quot;; //要转换的十进制以上的数

    int num2 = 0; //转换之后的数

    char *str_num2; //转换之后的数的地址

    int tmp_num1 = 0; //判断输入是否合法时代替num1的中间变量

    int i = 0;

    int m = 0; //计数器

    while (1) //整个while语句用于录入以及判断输入是否合法

    {

        printf(&quot;初始进制：&quot;);

        scanf(&quot;%d&quot;, &amp;before);

        printf(&quot;目标进制：&quot;);

        scanf(&quot;%d&quot;, &amp;after);

        printf(&quot;初始数值：&quot;);

        if (before &gt; 10) //通过对初始进制判断，决定

            scanf(&quot;%s&quot;, array_num1);

        else

            scanf(&quot;%d&quot;, &amp;num1);

        for (i = 0, tmp_num1 = num1; tmp_num1 != 0; i++)

        {

            if ((tmp_num1 % 10) &lt;= before &amp;&amp; tmp_num1 % 10 &gt;= 0 &amp;&amp; tmp_num1 % 10 &lt;= 9)

                m++;

            tmp_num1 /= 10;
        }

        if (m == i) //判断输入的数据每一位是否都小于等于进制数

            break;

        else

        {

            m = 0; //对计数器m重新初始化

            fflush(stdin); //清空缓存区

            printf(&quot;输入有误！请重新输入：\n&quot;);
        }
    }

    //将进制转换的四种情况分别表示

    if (before &lt;= 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%d\n&quot;, before, num1, after, num2);
    }

    else if (before &gt; 10 &amp;&amp; after &lt;= 10)

    {

        num2 = Ten_LessThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%d\n&quot;, before, array_num1, after, num2);
    }

    else if (before &lt;= 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, LessThanTen_Ten(before, num1));

        printf(&quot;\n%d进制的%d对应的%d进制数为：%s\n&quot;, before, num1, after, str_num2);
    }

    else if (before &gt; 10 &amp;&amp; after &gt; 10)

    {

        str_num2 = Ten_MoreThanTen(after, MoreThanTen_Ten(before, array_num1));

        printf(&quot;\n%d进制的%s对应的%d进制数为：%s\n&quot;, before, array_num1, after, str_num2);
    }

    system(&quot;pause&quot;);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[旋转图像(数组)]]></title>
        <id>https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/</id>
        <link href="https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/">
        </link>
        <updated>2020-12-19T10:45:03.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
<!-- more -->
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<p>给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]<br>
示例 2:</p>
<p>给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-image<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p><strong>题目要求不要用辅助数组，此题解用了辅助数组</strong><br>
直接用一个辅助数组arr，arr的列是matrix的行，用两个循环即可</p>
<pre><code class="language-C++">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;vector&lt;int&gt;&gt; arr = matrix;
        for (int i = 0, j = matrix.size() - 1; i &lt; matrix.size(); i++, j--) {
            for (int m = 0; m &lt; matrix[i].size(); m++) {
                arr[m][j] = matrix[i][m];
            }
        }
        matrix = arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://sakuratears.cn/post/markdown-yu-fa/</id>
        <link href="https://sakuratears.cn/post/markdown-yu-fa/">
        </link>
        <updated>2020-12-18T13:26:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="生成目录">生成目录</h1>
<p>在markdown顶部输入<code>[TOC]</code>即可生成目录</p>
<h1 id="markdown标题">Markdown标题</h1>
<p>Markdown标题有两种</p>
<h2 id="第一种标题">第一种标题</h2>
<p>使用=和-标记</p>
<pre><code class="language-markdown">我展示的是一级标题
=================

我展示的是二级标题
-----------------
</code></pre>
<h2 id="第二种标题">第二种标题</h2>
<p>使用#标记</p>
<pre><code class="language-markdown"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<h1 id="markdown-段落格式">Markdown 段落格式</h1>
<h2 id="markdown-段落">Markdown 段落</h2>
<p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。或者</p>
<pre><code class="language-markdown">&lt;br&gt;&lt;br&gt;
</code></pre>
<h2 id="字体">字体</h2>
<pre><code class="language-markdown">*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
</code></pre>
<p><em>斜体文本</em><br>
<em>斜体文本</em><br>
<strong>粗体文本</strong><br>
<strong>粗体文本</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em><strong>粗斜体文本</strong></em></p>
<h2 id="分隔线">分隔线</h2>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code class="language-markdown">***

* * *

*****

- - -

----------
</code></pre>
<h2 id="删除线">删除线</h2>
<p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可，实例如下：</p>
<pre><code class="language-markdown">RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
</code></pre>
<p>RUNOOB.COM<br>
GOOGLE.COM<br>
<s>BAIDU.COM</s></p>
<h2 id="下划线">下划线</h2>
<p>下划线可以通过 HTML 的<code>&lt;u&gt;</code> 标签来实现：</p>
<pre><code class="language-markdown">&lt;u&gt;带下划线文本&lt;/u&gt;
</code></pre>
<p><u>带下划线文本</u></p>
<h2 id="脚注">脚注</h2>
<p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<pre><code class="language-markdown">[^要注明的文本]
</code></pre>
<p>以下实例演示了脚注的用法：</p>
<pre><code class="language-markdown">创建脚注格式类似这样 [^RUNOOB]。

[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！
</code></pre>
<p>创建脚注格式类似这样 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h1 id="markdown-列表">Markdown 列表</h1>
<h2 id="无序列表">无序列表</h2>
<p>Markdown 支持有序列表和无序列表。<br>
无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<pre><code class="language-markdown">* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项

- 第一项
- 第二项
- 第三项
</code></pre>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h2 id="有序列表">有序列表</h2>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<pre><code class="language-markdown">1. 第一项
2. 第二项
3. 第三项
</code></pre>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="列表嵌套">列表嵌套</h2>
<p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<pre><code class="language-markdown">1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
    - 第二项嵌套的第二个元素
   
</code></pre>
<ol>
<li>第一项：
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：
<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="markdown-区块">Markdown 区块</h1>
<p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>
<pre><code class="language-markdown">&gt; 区块引用
&gt; 菜鸟教程
&gt; 学的不仅是技术更是梦想
</code></pre>
<blockquote>
<p>区块引用<br>
菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<pre><code class="language-markdown">&gt; 最外层
&gt; &gt; 第一层嵌套
&gt; &gt; &gt; 第二层嵌套
</code></pre>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="区块中使用列表">区块中使用列表</h2>
<p>区块中使用列表实例如下:</p>
<pre><code class="language-markdown">&gt; 区块中使用列表
&gt; 1. 第一项
&gt; 2. 第二项
&gt; + 第一项
&gt; + 第二项
&gt; + 第三项
</code></pre>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h2 id="列表中使用区块">列表中使用区块</h2>
<p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。<br>
区块中使用列表实例如下：</p>
<pre><code class="language-markdown">* 第一项
    &gt; 菜鸟教程
    &gt; 学的不仅是技术更是梦想
* 第二项
</code></pre>
<ul>
<li>第一项
<blockquote>
<p>菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<h1 id="markdown-代码">Markdown 代码</h1>
<p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来<code>（`）</code>，例如：</p>
<pre><code class="language-markdown">`printf()` 函数
</code></pre>
<p><code>printf()</code> 函数</p>
<h2 id="代码区块">代码区块</h2>
<p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p>
<p>实例如下：<br>
printf(&quot;hello&quot;)</p>
<p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<pre><code class="language-markdown">​```javascript
$(document).ready(function () {
    alert('hello word!');
});
​```
</code></pre>
<pre><code class="language-javascript">$(document).ready(function () {
    alert('hello word!');
});
</code></pre>
<h1 id="markdown-链接">Markdown 链接</h1>
<p>链接使用方法如下：</p>
<pre><code class="language-markdown">[链接名称](链接地址)

或者

&lt;链接地址&gt;
</code></pre>
<p><a href="https://sakuratears.cn">blog</a></p>
<p>或者</p>
<p><a href="https://sakuratears.cn">https://sakuratears.cn</a></p>
<h2 id="高级链接">高级链接</h2>
<p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [Google][1]
这个链接用 sakura 作为网址变量 [sakura][sakura]
然后在文档的结尾为变量赋值（网址）

  [1]: http://www.google.com/
  [sakura]: https://sakuratears.cn/
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>
这个链接用 sakura 作为网址变量 <a href="https://sakuratears.cn/">sakura</a><br>
然后在文档的结尾为变量赋值（网址）</p>
<h1 id="markdown-图片">Markdown 图片</h1>
<p>Markdown 图片语法格式如下：</p>
<pre><code class="language-markdown">![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &quot;可选标题&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"></figure>
<p>当然，你也可以像网址那样对图片网址使用变量:</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [RUNOOB][1].
然后在文档的结尾为变量赋值（网址）

[1]: http://static.runoob.com/images/runoob-logo.png
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>
然后在文档的结尾为变量赋值（网址）</p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<pre><code class="language-markdown">&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;
</code></pre>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">
<h1 id="markdown-表格">Markdown 表格</h1>
<p>Markdown 制作表格使用 <code>|</code>来分隔不同的单元格，使用<code>-</code> 来分隔表头和其他行。<br>
语法格式如下：</p>
<pre><code class="language-markdown">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<p>对齐方式</p>
<p>我们可以设置表格的对齐方式：</p>
<p><code>-:</code> 设置内容和标题栏居右对齐。<br>
<code>:-</code>设置内容和标题栏居左对齐。<br>
<code>:-:</code>设置内容和标题栏居中对齐。</p>
<pre><code class="language-markdown">| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
<h1 id="markdown-高级技巧">Markdown 高级技巧</h1>
<h2 id="支持的-html-元素">支持的 HTML 元素</h2>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</p>
<pre><code class="language-markdown">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑
</code></pre>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h2 id="转义">转义</h2>
<p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p>
<pre><code class="language-markdown">**文本加粗** 
\*\* 正常显示星号 \*\*
</code></pre>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code class="language-markdown">\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
</code></pre>
<h2 id="公式">公式</h2>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<pre><code class="language-markdown">$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 248: …
\end{vmatrix}
$̲{$tep1}{\style{…'>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>菜鸟教程 -- 学的不仅是技术，更是梦想！！！ <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[找不同(位运算)(哈希表)]]></title>
        <id>https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/">
        </link>
        <updated>2020-12-18T09:38:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
<!-- more -->
<p></p>
<p>示例 1：<br>
输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;<br>
输出：&quot;e&quot;<br>
解释：'e' 是那个被添加的字母。</p>
<p>示例 2：<br>
输入：s = &quot;&quot;, t = &quot;y&quot;<br>
输出：&quot;y&quot;</p>
<p>示例 3：<br>
输入：s = &quot;a&quot;, t = &quot;aa&quot;<br>
输出：&quot;a&quot;</p>
<p>示例 4：<br>
输入：s = &quot;ae&quot;, t = &quot;aea&quot;<br>
输出：&quot;a&quot;<br>
 <br>
提示：</p>
<p>0 &lt;= s.length &lt;= 1000<br>
t.length == s.length + 1<br>
s 和 t 只包含小写字母</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-difference<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1位运算">方法1：位运算</h4>
<p><sup>运算符：0与任何数ch做</sup>运算都是ch<br>
相同字符异或为0</p>
<p>因为t中的字符是s + ch，所以s与t做异或剩下的就是ch</p>
<pre><code class="language-C++">class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for(char c : s + t) {
            res ^= c;
        }
        return res;
    }
};
</code></pre>
<h4 id="方法2哈希表">方法2：哈希表</h4>
<p>把s中所有元素存到一个哈希表mpS里，t中所有元素存到一个哈希表mpT里<br>
然后比较两个哈希表每个元素个数，不一样的就是题目所求</p>
<pre><code class="language-C++">char findTheDifference(string s, string t) {
        unordered_map&lt;char, int&gt; mpS;
        unordered_map&lt;char, int&gt; mpT;
        char ch;
        for (auto ch : s) {
            mpS[ch]++;
        }
        for (auto ch : t) {
            mpT[ch]++;
        }

        for (ch = 'a'; ch &lt;= 'z'; ch++) {
            if (mpS[ch] != mpT[ch]) {
                return ch;
            }
        }
        return ch;
    }
    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长公共前缀(字符串)]]></title>
        <id>https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/</id>
        <link href="https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/">
        </link>
        <updated>2020-12-18T09:02:23.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;<br>
示例 2:</p>
<p>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
输出: &quot;&quot;<br>
解释: 输入不存在公共前缀。<br>
说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-prefix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>直接每个字符串从头开始元素比较，不一样直接return即可A</p>
<pre><code class="language-C++">class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        string str = &quot;&quot;;
        if (strs.size() == 0) {
            return str;
        }
        char ch;
        int i, j, min = INT_MAX;
        for (int m = 0; m &lt; strs.size(); m++) {
            if (strs[m].size() &lt; min) {
                min = strs[m].size();
            }
        }
        for (i = 0; i &lt; min; i++) {
            ch = strs[0][i];
            for (j = 0; j &lt; strs.size(); j++) {
                if (strs[j][i] != ch) {
                    return str;
                }
            }
            str += ch;
        }
        return str;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波那契数列(递归)]]></title>
        <id>https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/</id>
        <link href="https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/">
        </link>
        <updated>2020-12-17T09:13:05.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<!-- more -->
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：n = 2<br>
输出：1<br><br><br>
示例 2：</p>
<p>输入：n = 5<br>
输出：5<br><br></p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1递归">方法1：递归</h4>
<p>常规递归方法，然后愉快的超时</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }
};
</code></pre>
<h4 id="方法2带备忘录的递归自顶向下">方法2：带备忘录的递归（自顶向下）</h4>
<p>可以把递归看成一颗树，自顶向下<br>
在递归的过程中很多元素其实已经被访问过了，比如n = 20，求n = 19 + n = 18，求19的时候求n = 18 + n = 17，这里可以看到n = 18被求了两次，下面的元素还有更多次重复的所以一般的递归时间复杂度非常高。如果可以把每个元素的值记录下来，下次求的时候直接用时间可以减少很多。</p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;int&gt; arr;

    int help(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        if (arr[n] != 0) { //如果已经记录则直接用
            return arr[n];
        }
        //未记录则记录下来
        arr[n - 1] = help(n - 1) % 1000000007;
        arr[n - 2] = help(n - 2) % 1000000007;
        return arr[n - 1] + arr[n - 2];
    }

    int fib(int n) {
        for (int i = 1; i &lt;= 101; i++) {
            arr.push_back(0);
        }
        return help(n) % 1000000007;
    }
};
</code></pre>
<h4 id="方法3dp自底向上">方法3：DP（自底向上）</h4>
<p>方法2是从树的顶端到下面依次递归求值，也可以从树的底端到顶端求。<br>
还是利用一个数组，把每个值记录下来，从底到顶。</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        int dp[101];
        dp[1] = 1;
        dp[2] = 1;
        if (n == 0) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[恢复二叉搜索树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/">
        </link>
        <updated>2020-12-16T11:44:46.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<!-- more -->
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：root = [1,3,null,null,2]<br>
输出：[3,1,null,null,2]<br>
解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。<br><br><br>
示例 2：</p>
<p>输入：root = [3,1,4,null,null,2]<br>
输出：[2,1,4,null,null,3]<br>
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。<br><br></p>
<p>提示：</p>
<p>树上节点的数目在范围 [2, 1000] 内<br>
-231 &lt;= Node.val &lt;= 231 - 1<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>二叉树搜索树中序遍历就是二叉搜索树元素从小到大排列，知道这个就好做了。<br>
采用中序遍历：每个节点和前一个相比，小的话就把前一个节点记录下来(只有第一次记录前一个节点，因为题目说明只有两个元素错位)，然后下一次遇到前一个元素比后面的元素大的情况把后一个元素记录下来。<br>
最后把两个记录点的val交换。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = new TreeNode(-2147483648);
    TreeNode* s = NULL;
    TreeNode* t = new TreeNode();

    void recover(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        recover(root-&gt;left);
        if (root-&gt;val &lt; pre-&gt;val) {
            s = (s == NULL) ? pre:s;
            t = root; 
        }
        pre = root;
        recover(root-&gt;right);
    }
    void recoverTree(TreeNode* root) {
        recover(root);
        int n = s-&gt;val;
        s-&gt;val = t-&gt;val;
        t-&gt;val = n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的锯齿形层次遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-15T09:01:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
<!-- more -->
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层次遍历如下：</p>
<p>[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>首先把每一行所有节点存放到一个数组中，然后再把这个数组存放到一个二维数组中，然后把一维数组清空。依次遍历，然后每遍历完一行下一行数组翻转即可。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子，判断是否翻转
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; arr;
        vector&lt;int&gt; brr;
        if (root == NULL) {
            return arr;
        }
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        TreeNode* node;
        while (!q.empty()) { //BFS
            int n = q.size(); //记录当前队列元素数量
            for (int i = 0; i &lt; n; i++) {
                brr.push_back(q.front()-&gt;val); //把上一层所有节点加入到一维数组中
                node = q.front();
                q.pop();
                if (node-&gt;left != NULL) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) {
                    q.push(node-&gt;right);
                }
            }
            if (jud == true) { //翻转
                reverse(brr.begin(), brr.end());
                jud = false; //更改反转因子
            }
            else { //不翻转
                jud = true; //更改反转因子
            }
            arr.push_back(brr); //把一维数组加入到二维数组
            brr.clear(); //然后把一维数组清空
        }
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的序列化与反序列化(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/">
        </link>
        <updated>2020-12-15T00:23:20.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<!-- more -->
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例:</p>
<p>你可以将以下二叉树：</p>
<pre><code>      1
     / \
    2   3
       / \
      4   5
</code></pre>
<p>序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        string str = &quot;&quot;;
        TreeNode* node;
        while (!q.empty()) {
            int n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (node == NULL) {
                    str += &quot;null,&quot;;
                    continue;
                }
                str += to_string(node-&gt;val);
                str += &quot;,&quot;;
                q.push(node-&gt;left);
                q.push(node-&gt;right);
            }
        }
        return str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data[0] == 'n') {
            return NULL;
        }
        int m = 0, n = 0;
        TreeNode* node;
        queue&lt;TreeNode*&gt; q;
        vector&lt;int&gt; arr;
        string str = &quot;&quot;;
        while (m &lt; data.size()) {
            if (data[m] == ',') {
                if (!str.empty())
                    arr.push_back(stoi(str));
                str = &quot;&quot;;
                m++;
                continue;
            }
            if (data[m] == 'n') {
                m += 4;
                if (!str.empty())
                    arr.push_back(stoi(str));
                arr.push_back(-1024);
                str = &quot;&quot;;
                continue;
            }
            str += data[m];
            m++;
        }
        TreeNode* root = new TreeNode(arr[0]);
        if (arr.size() == 1) {
            return root;
        }
        m = 1;
        q.push(root);
        while (!q.empty() &amp;&amp; m &lt; arr.size()) {
            n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (arr[m] != -1024) {
                    node-&gt;left = new TreeNode(arr[m]);
                    q.push(node-&gt;left);
                }
                else {
                    node-&gt;left = nullptr;
                }
                if (arr[m + 1] != -1024) {
                    node-&gt;right = new TreeNode(arr[m+1]);
                    q.push(node-&gt;right);
                }
                else {
                    node-&gt;right = nullptr;
                }
                m += 2;
            }
        }
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
</code></pre>
]]></content>
    </entry>
</feed>