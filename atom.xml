<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-12T09:06:53.021Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[二叉树的层序遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-12T08:51:11.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<!-- more -->
<p></p>
<p>示例：<br>
二叉树：[3,9,20,null,null,15,7],<br>
<img src="https://sakuratears.cn/post-images/1607763983990.png" alt="" loading="lazy"></p>
<p>返回其层次遍历结果：</p>
<p>[<br>
[3],<br>
[9,20],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="解题思路">解题思路</h3>
<p>在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了</p>
<h3 id="代码">代码</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; arr;

    void BFS(TreeNode* root) {
        queue&lt;TreeNode*&gt; brr;
        vector&lt;int&gt; crr;
        brr.push(root);
        int n = 0;
        while (!brr.empty()) {
            TreeNode* node = brr.front();
            n = brr.size(); //n记录当前队列元素个数
            for (int i = 0; i &lt; n; i++) { //循环n次
                if (node-&gt;left != NULL) { //左孩子不为空则添加左孩子
                    brr.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) { //右孩子不为空则添加右孩子
                    brr.push(node-&gt;right);
                }
                crr.push_back(brr.front()-&gt;val); //每次循环把队列的头元素的值添加到一个数组里
                brr.pop();
                node = brr.front(); //节点移动到下一个
            }
            arr.push_back(crr); //把当前数组元素添加到二维数组中
            crr.clear(); //当前数组清空
        }
    }

    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if (root == NULL) {
            return arr;
        }
        BFS(root);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从前序与中序遍历序列构造二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-12T04:26:26.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。</p>
<!-- more -->
<p>注意:<br>
你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]<br>
中序遍历 inorder = [9,3,15,20,7]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>和上一题基本一样0.0</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        TreeNode* tree = new TreeNode(preorder[0]);
        if (inorder.size() &lt;= 1) {
            return tree;
        }
        int i, m;
        for (i = 0; i &lt; inorder.size(); i++) {
            if (inorder[i] == preorder[0]) {
                break;
            }
        }
        m = i;
        vector&lt;int&gt; arr0, arr1, brr0, brr1;
        if (m == 0) {
            tree-&gt;left = NULL;
        }
        else {
            for (int j = 0, i = 1; j &lt; m; j++, i++) {
                arr0.push_back(preorder[i]);
                brr0.push_back(inorder[j]);
            }
            tree-&gt;left = build(arr0, brr0);
        }
        if (m &gt;= inorder.size() - 1) {
            tree-&gt;right = NULL;
        }
        else {
            for (int j = m + 1; j &lt; inorder.size(); j++) {
                arr1.push_back(preorder[j]);
                brr1.push_back(inorder[j]);
            }
            tree-&gt;right = build(arr1, brr1);
        }
        return tree;
    }

    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        if (inorder.size() == 0 || preorder.size() == 0) {
            return NULL;
        }
        return build(preorder, inorder);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从中序与后序遍历序列构造二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-11T12:51:54.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<!-- more -->
<p>注意:<br>
你可以假设树中没有重复的元素。<br><br></p>
<p>例如，给出<br>
中序遍历 inorder = [9,3,15,20,7]<br>
后序遍历 postorder = [9,15,7,20,3]<br><br></p>
<p>得到结果：[3,9,20,null,null,15,7]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>二叉树的后序遍历最后一个元素是二叉树的的根节点，然后中序遍历根节点左边元素是左子树的节点，右边是右子树的节点。<br>
知道这个这道题就很简单了，用递归调用求左子树右子树。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        TreeNode* tree = new TreeNode(postorder[postorder.size() - 1]);
        if (inorder.size() &lt;= 1) {
            return tree;
        }
        int i, m; //找到根节点m
        for (i = 0; i &lt; inorder.size(); i++) {
            if (inorder[i] == postorder[postorder.size() - 1]) {
                break;
            }
        }
        m = i;
        vector&lt;int&gt; arr0, arr1, brr0, brr1;
        if (m == 0) { //考虑左边已经空了的情况
            tree-&gt;left = NULL;
        }
        else {
            for (int i = 0; i &lt; m; i++) {
                arr0.push_back(inorder[i]);
                brr0.push_back(postorder[i]);
            }
            tree-&gt;left = build(arr0, brr0);
        }
        if (m &gt;= inorder.size() - 1) {  //考虑右边已经空了的情况
            tree-&gt;right = NULL;
        }
        else {
            for (int i = m + 1, j = m; i &lt; inorder.size(); i++, j++) {
                arr1.push_back(inorder[i]);
                brr1.push_back(postorder[j]);
            }
            tree-&gt;right = build(arr1, brr1);
        }
        return tree;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) {
            return NULL;
        }
        return build(inorder, postorder);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的中序遍历(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/">
        </link>
        <updated>2020-12-10T09:26:48.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树的根节点 root ，返回它的 中序 遍历。</p>
<!-- more -->
<p></p>
<p>示例 1：</p>
<p>输入：root = [1,null,2,3]<br>
输出：[1,3,2]<br><br><br>
示例 2：</p>
<p>输入：root = []<br>
输出：[]<br><br><br>
示例 3：</p>
<p>输入：root = [1]<br>
输出：[1]<br><br><br>
示例 4：</p>
<p>输入：root = [1,2]<br>
输出：[2,1]<br><br><br>
示例 5：</p>
<p>输入：root = [1,null,2]<br>
输出：[1,2]<br><br></p>
<p>提示：</p>
<p>树中节点数目在范围 [0, 100] 内<br>
-100 &lt;= Node.val &lt;= 100<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>就二叉树的中序遍历，没有任何坑，直接写就行</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; arr;
    void traversal(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        inorderTraversal(root-&gt;left);
        arr.push_back(root-&gt;val);
        inorderTraversal(root-&gt;right);
    }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        traversal(root);
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[对称二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/dui-cheng-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/dui-cheng-er-cha-shu/">
        </link>
        <updated>2020-12-10T06:44:24.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，检查它是否是镜像对称的。</p>
<!-- more -->
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_35r5gAjUVn.png" alt="" loading="lazy"></figure>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_BIOlXHyv1p.png" alt="" loading="lazy"></figure>
<p>进阶：</p>
<p>你可以运用递归和迭代两种方法解决这个问题吗？<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/symmetric-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>判断二叉树是否对称可以理解为判断一个节点的两个子树的里侧和外侧是否对称，就是后序遍历。<br>
判断外侧是否对称，传入左节点的左孩子，右节点的右孩子。<br>
判断里侧是否对称，传入左节点的右孩子，右节点的左孩子。<br>
可以用递归挨个判断，所以递归函数传的值就要是left,right两个，想通这一点就好做了。<br>
判断空的情况，<br>
左空右空       返回true<br>
左空右不空    返回false<br>
左不空右空    返回false<br>
最后是都不空，判断值</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool cmp(TreeNode* left, TreeNode* right) {
        if (left == NULL &amp;&amp; right == NULL) {
            return true;
        }
        else if (left == NULL &amp;&amp; right != NULL) {
            return false;
        }
        else if (left != NULL &amp;&amp; right == NULL) {
            return false;
        }
        //都不空判断值
        else if (left-&gt;val != right-&gt;val) {
            return false;
        }

        bool in = cmp(left-&gt;right, right-&gt;left);
        bool out = cmp(left-&gt;left, right-&gt;right);
        return in &amp;&amp; out;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) {
            return true;
        }
        return cmp(root-&gt;left, root-&gt;right);
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[平衡二叉树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/">
        </link>
        <updated>2020-12-09T02:40:35.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。<br><br></p>
<!-- more -->
<p>本题中，一棵高度平衡二叉树定义为：</p>
<p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。<br><br></p>
<p></p>
<p>示例 1：<br>
<img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="" loading="lazy"></p>
<p>输入：root = [3,9,20,null,null,15,7]<br>
输出：true<br><br><br>
示例 2：<br>
<img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" alt="" loading="lazy"></p>
<p>输入：root = [1,2,2,3,3,null,null,4,4]<br>
输出：false<br><br><br>
示例 3：</p>
<p>输入：root = []<br>
输出：true<br><br></p>
<p>提示：</p>
<p>树中的节点数在范围 [0, 5000] 内<br>
-104 &lt;= Node.val &lt;= 104<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/balanced-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>还是用二叉树的框架就行，每个节点的最大深度就是左子树或右子树中的最大深度加1</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool jud = true; //判断因子
    int deep(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = deep(root-&gt;left);
        int right = deep(root-&gt;right);
        if (abs(left - right) &gt; 1) { //如果左右子树深度相差大于1将判断因子设为false;
            jud = false;
        }
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        deep(root);
        return jud;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树中的最大路径和(二叉树)(DFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-zhong-de-zui-da-lu-jing-he-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-zhong-de-zui-da-lu-jing-he-er-cha-shu/">
        </link>
        <updated>2020-12-08T13:18:54.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非空二叉树，返回其最大路径和。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非空二叉树，返回其最大路径和。<br><br></p>
<!-- more -->
<p>本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：[1,2,3]</p>
<pre><code>   1
  / \
 2   3
</code></pre>
<p>输出：6<br><br><br>
示例 2：</p>
<p>输入：[-10,9,20,null,null,15,7]</p>
<p>-10<br>
   / <br>
  9  20<br>
    /  <br>
   15   7</p>
<p>输出：42<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>每一个节点的最大路径是它左右子树中最大的路径加上它自己，这样就是先遍历左子树，再遍历右子树。<br>
这样就是树的后序遍历+DFS的思想。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int imax = INT_MIN;
    int maxpath(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }

        int left = max(0, maxpath(root-&gt;left));
        int right = max(0, maxpath(root-&gt;right));
        /*二叉树的后序遍历*/
        imax = max(imax, left + right + root-&gt;val);
        return max(left, right) + root-&gt;val;
    }
    int maxPathSum(TreeNode* root) {
        maxpath(root);
        return imax;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[杨辉三角(数组)]]></title>
        <id>https://sakuratears.cn/post/yang-hui-san-jiao/</id>
        <link href="https://sakuratears.cn/post/yang-hui-san-jiao/">
        </link>
        <updated>2020-12-07T09:18:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。<br><br></p>
<!-- more -->
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。<br><br></p>
<p>示例:<br><br></p>
<p>输入: 5<br>
输出:<br>
[<br>
[1],<br>
[1,1],<br>
[1,2,1],<br>
[1,3,3,1],<br>
[1,4,6,4,1]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/pascals-triangle<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>简单题，直接写就行，leetcode的测试用例也没啥恶心的<s>可能是这个题没法恶心了吧</s></p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; nums;
        if (numRows == 0) {  //判断0的情况下
            return nums;
        }
        vector&lt;int&gt; num;
        num.push_back(1);
        nums.push_back(num);
        for (int i = 1; i &lt; numRows; i++) {
            vector&lt;int&gt; num;
            num.push_back(1);
            for (int j = 1; j &lt; i; j++) {
                num.push_back(nums[i - 1][j - 1] + nums[i - 1][j]); //每行数组的[j]是上一个数组的[j]位置+[j - 1]位置
            }
            num.push_back(1);
            nums.push_back(num);
        }
        return nums;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[字符串转换整数 (atoi)(字符串)]]></title>
        <id>https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/</id>
        <link href="https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/">
        </link>
        <updated>2020-12-06T15:19:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。<br><br></p>
<!-- more -->
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：<br><br></p>
<p>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。<br>
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。<br>
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。<br>
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。<br><br></p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0 。<br><br></p>
<p>提示：<br><br></p>
<p>本题中的空白字符只包括空格字符 ' ' 。<br>
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。<br><br></p>
<p>示例 1:</p>
<p>输入: &quot;42&quot;<br>
输出: 42<br><br><br>
示例 2:</p>
<p>输入: &quot;   -42&quot;<br>
输出: -42<br>
解释: 第一个非空白字符为 '-', 它是一个负号。<br>
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。<br><br><br>
示例 3:</p>
<p>输入: &quot;4193 with words&quot;<br>
输出: 4193<br>
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。<br><br><br>
示例 4:</p>
<p>输入: &quot;words and 987&quot;<br>
输出: 0<br>
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。<br>
因此无法执行有效的转换。<br><br><br>
示例 5:</p>
<p>输入: &quot;-91283472332&quot;<br>
输出: -2147483648<br>
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。<br>
     因此返回 INT_MIN (−231) 。<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/string-to-integer-atoi<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<pre><code class="language-C++">class Solution {
public:
    int myAtoi(string s) {
        int i = 0, m = 0, jud = 0, n = 0, p, j = 0;
        while (s[i] == ' ') {
            i++;
        }
        if (s[i] != '-' &amp;&amp; s[i] != '+' &amp;&amp; (s[i] &gt; 57 || s[i] &lt; 48))
            return 0;
        if ((s[i] == '-' || s[i] == '+') &amp;&amp; (s[i + 1] &gt; 57 || s[i + 1] &lt; 48))
            return 0;
        while (s[i] &gt; 57 || s[i] &lt; 48) {
            i++;
        }
        if (i &gt; 0 &amp;&amp; s[i - 1] == '-') {
            jud = 1;
        }
        while (s[i] == '0') {
            i++;
        }
        if (s[i] &gt; 57 || s[i] &lt; 48) {
            return 0;
        }
        j = i;
        while (s[i] &lt;= 57 &amp;&amp; s[i] &gt;= 48) {
            i++;
            n++;//位数
        }
        if (n &gt; 10) {
            if (jud == 0)
                return pow(2, 31) - 1;
            else
                return -pow(2, 31);
        }
        p = n - 1;
        for (; j &lt; i; j++) {
            if ((m + (s[j] - 48) * pow(10, p) &gt; pow(2, 31) - 1) &amp;&amp; jud == 0) {
                return pow(2, 31) - 1;
            }
            if ((m + (s[j] - 48) * pow(10, p) &gt;= pow(2, 31)) &amp;&amp; jud == 1) {
                return -pow(2, 31);
            }
            m += (s[j] - 48) * pow(10, p);
            p--;
        }
        if (jud == 1) {
            m = -m;
        }
        return m;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[整数反转(数组)]]></title>
        <id>https://sakuratears.cn/post/zheng-shu-fan-zhuan/</id>
        <link href="https://sakuratears.cn/post/zheng-shu-fan-zhuan/">
        </link>
        <updated>2020-12-06T09:16:41.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><br></p>
<!-- more -->
<p>示例 1:</p>
<p>输入: 123<br>
输出: 321<br><br></p>
<p>示例 2:</p>
<p>输入: -123<br>
输出: -321<br><br></p>
<p>示例 3:</p>
<p>输入: 120<br>
输出: 21<br><br></p>
<p>注意:<br><br></p>
<p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/reverse-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="题解">题解</h3>
<p>多注意爆int的地方，多wa几发就过了<s>手动狗头</s></p>
<pre><code class="language-C++">class Solution {
public:
    int reverse(int x) {
        int j = 0, m = 0, num = 0, jud = 0;
        char str[1000];
        int i = 0;
        if (x &lt; 0)
        {
            if (x &lt;= -pow(2, 31)) // 负数正好没爆int，转正可能就会正好爆
                return 0;
            x = -x;
            jud = 1;
        }
        while (x &gt; 0)
        {
            str[i++] = x % 10 + 48;
            x /= 10;
        }
        str[i] = '\0';
        if (str[0] == '0')
        {
            m = 1;
        }
        for (int i = m; str[i] != '\0'; i++)
        {
            j++;
        }
        j--;
        for (int i = m; str[i] != '\0'; i++)
        {
            if ((str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) { //可能爆int的地方
                return 0;
            }
            if (num + (str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || num + (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) {  //可能爆int的地方
                return 0;
            }
            num += (str[i] - 48) * pow(10, j);
            j--;
        }
        if (jud != 0)
        {
            num = -num;
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>