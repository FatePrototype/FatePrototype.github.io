<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2021-01-20T05:51:57.974Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2021, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[《将博客搬至CSDN》]]></title>
        <id>https://sakuratears.cn/post/lesslessjiang-bo-ke-ban-zhi-csdngreatergreater/</id>
        <link href="https://sakuratears.cn/post/lesslessjiang-bo-ke-ban-zhi-csdngreatergreater/">
        </link>
        <updated>2021-01-18T04:55:07.000Z</updated>
        <content type="html"><![CDATA[<p>申请将本博客内容搬至CSDN账号Narakue</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android添加RecyclerView依赖库]]></title>
        <id>https://sakuratears.cn/post/android-tian-jia-recyclerview-yi-lai-ku/</id>
        <link href="https://sakuratears.cn/post/android-tian-jia-recyclerview-yi-lai-ku/">
        </link>
        <updated>2021-01-15T08:56:39.000Z</updated>
        <summary type="html"><![CDATA[<p>在app/build.gradle文件中<code>dependencies</code>里面添加</p>
]]></summary>
        <content type="html"><![CDATA[<p>在app/build.gradle文件中<code>dependencies</code>里面添加</p>
<!-- more -->
<pre><code>def recyclerview_version =&quot;1.1.0&quot;
implementation &quot;androidx.recyclerview:recyclerview:$recyclerview_version&quot;
// For control over item selection of both touch and mouse driven selection
implementation &quot;androidx.recyclerview:recyclerview-selection:1.1.0-alpha05&quot;
</code></pre>
<p>然后同步<br>
在xml里写<code>&lt;androidx.recyclerview.widget.RecyclerView /&gt;</code>即可</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android Toast提示]]></title>
        <id>https://sakuratears.cn/post/android-toast-ti-shi/</id>
        <link href="https://sakuratears.cn/post/android-toast-ti-shi/">
        </link>
        <updated>2021-01-07T08:56:07.000Z</updated>
        <content type="html"><![CDATA[<h3 id="默认显示方式">默认显示方式：</h3>
<p><code>Toast.makeText()</code><br>
第一个参数：当前的上下文环境。可用<code>getApplicationContext()</code>或<code>this</code><br>
第二个参数：要显示的字符串。也可是R.string中字符串ID<br>
第三个参数：显示的时间长短。Toast默认的有两个<code>Toast.LENGTH_LONG</code>(长)和<code>Toast.LENGTH_SHORT</code>(短)，也可以使用毫秒</p>
<pre><code class="language-Kotlin">Toast.makeText(this, &quot;Hello&quot;, Toast.LENGTH_SHORT).show()
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 188. 买卖股票的最佳时机 IV(动态规划)(递归)]]></title>
        <id>https://sakuratears.cn/post/leetcode-188-mai-mai-gu-piao-de-zui-jia-shi-ji-ivdong-tai-gui-hua-di-gui/</id>
        <link href="https://sakuratears.cn/post/leetcode-188-mai-mai-gu-piao-de-zui-jia-shi-ji-ivdong-tai-gui-hua-di-gui/">
        </link>
        <updated>2020-12-28T07:55:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。<br>
设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。<br>
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<!-- more -->
<p>示例 1：<br>
输入：k = 2, prices = [2,4,1]<br>
输出：2<br>
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</p>
<p>示例 2：<br>
输入：k = 2, prices = [3,2,6,5,0,3]<br>
输出：7<br>
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。<br>
随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</p>
<p>提示：</p>
<p>0 &lt;= k &lt;= 109<br>
0 &lt;= prices.length &lt;= 1000<br>
0 &lt;= prices[i] &lt;= 1000</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>可以用递归来算，从根开始，要么买入，要么保持不动。<br>
买入后可以进行的操作有卖出，保持不动<br>
保持不动后的操作有：买入，保持不动<br>
看成二叉树操作，把所有情况算出来(可以用一个备忘录记录下来已经算出来的值)</p>
<h4 id="方法1递归会超时">方法1：递归(会超时)</h4>
<pre><code class="language-C++">class Solution {
public:
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        if (k == 0 || prices.size() == 0) {
            return 0;
        }
        return DFS(0, 0, 0, k, prices);
    }
    //计算k次交易，index表示当前是哪天，status是买卖状态，coutnt为交易次数
    int DFS(int index, int status, int count, int k, vector&lt;int&gt;&amp; prices) {
        if (index == prices.size() || count == k) {
            return 0;
        }
        int keep = 0, sell = 0, buy = 0;
        //保持
        keep = DFS(index + 1, status, count, k, prices);
        if (status == 1) {
            //卖出
            sell = DFS(index + 1, 0, count + 1, k, prices) + prices[index];
        }
        else {
            //买入
            buy = DFS(index + 1, 1, count, k, prices) - prices[index];
        }
        return max(max(keep, sell), buy);
    }
};
</code></pre>
<h4 id="方法2递归记忆">方法2：递归+记忆</h4>
<pre><code class="language-Java">class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices==null || prices.length==0) {
            return 0;
        }
        int n = prices.length;
        //当k非常大时转为无限次交易
        if(k&gt;=n/2) {
            int dp0=0,dp1=-prices[0];
            for(int i=1;i&lt;n;++i) {
                int tmp = dp0;
                dp0 = Math.max(dp0,dp1+prices[i]);
                dp1 = Math.max(dp1,dp0-prices[i]);
            }
            return Math.max(dp0,dp1);
        }
        Map&lt;Key,Integer&gt; cache = new HashMap&lt;Key,Integer&gt;();
        return dfs(cache,0,0,0,k,prices);
    }

    //带记忆化的 计算k次交易，代码和递归版的一样只是前后加了缓存
    private int dfs(Map&lt;Key,Integer&gt; cache, int index, int status, int count, int k, int[] prices) {
        Key key = new Key(index,status,count);
        if(cache.containsKey(key)) {
            return cache.get(key);
        }
        if(index==prices.length || count==k) {
            return 0;
        }
        int a=0,b=0,c=0;
        a = dfs(cache,index+1,status,count,k,prices);
        if(status==1) {
            b = dfs(cache,index+1,0,count+1,k,prices)+prices[index];
        } else {
            c = dfs(cache,index+1,1,count,k,prices)-prices[index];
        }
        cache.put(key,Math.max(Math.max(a,b),c));
        return cache.get(key);
    }
    //Key对象封装了index、status、交易次数count，作为map的key
    private class Key {
        private final int index;
        private final int status;
        private final int count;
        Key(int index,int status,int count) {
            this.index = index;
            this.status = status;
            this.count = count;
        }
        //这里需要实现自定义的equals和hashCode函数
        public int hashCode() {
            return this.index + this.status + this.count;
        }
        public boolean equals(Object obj) {
            Key other = (Key)obj;
            if(index==other.index &amp;&amp; status==other.status &amp;&amp; count==other.count) {
                return true;
            }
            return false;
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 205. 同构字符串(哈希表)]]></title>
        <id>https://sakuratears.cn/post/leetcode-205-tong-gou-zi-fu-chuan-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/leetcode-205-tong-gou-zi-fu-chuan-ha-xi-biao/">
        </link>
        <updated>2020-12-27T12:13:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: s = &quot;egg&quot;, t = &quot;add&quot;<br>
输出: true<br>
示例 2:</p>
<p>输入: s = &quot;foo&quot;, t = &quot;bar&quot;<br>
输出: false<br>
示例 3:</p>
<p>输入: s = &quot;paper&quot;, t = &quot;title&quot;<br>
输出: true<br>
说明:<br>
你可以假设 s 和 t 具有相同的长度。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/isomorphic-strings<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>题意为：s中任意一个字符都在t中有唯一对应，t中任意一个字符也都在s中有唯一对应。<br>
所以用两个哈希表一一对应再判断。</p>
<pre><code class="language-C++">class Solution {
public:
    bool isIsomorphic(string s, string t) {
        unordered_map&lt;char, char&gt; map1;
        unordered_map&lt;char, char&gt; map2;
        for (int i = 0; i &lt; s.size(); i++) {
            if (map1.find(s[i]) == map1.end()) { // map1保存s[i] 到 t[j]的映射
                map1[s[i]] = t[i];
            }
            if (map2.find(t[i]) == map2.end()) { // map2保存t[j] 到 s[i]的映射
                map2[t[i]] = s[i];
            }
            // 发现映射 对应不上，立刻返回false
            if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {
                return false;
            }
        }
        return true;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 13. 罗马数字转整数(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-13-luo-ma-shu-zi-zhuan-zheng-shu-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-13-luo-ma-shu-zi-zhuan-zheng-shu-tan-xin/">
        </link>
        <updated>2020-12-26T06:16:39.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>
I             1<br>
V             5<br>
X             10<br>
L             50<br>
C             100<br>
D             500<br>
M             1000<br>
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<!-- more -->
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 <br>
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p></p>
<p>示例 1:</p>
<p>输入: &quot;III&quot;<br>
输出: 3<br>
示例 2:</p>
<p>输入: &quot;IV&quot;<br>
输出: 4<br>
示例 3:</p>
<p>输入: &quot;IX&quot;<br>
输出: 9<br>
示例 4:</p>
<p>输入: &quot;LVIII&quot;<br>
输出: 58<br>
解释: L = 50, V= 5, III = 3.<br>
示例 5:</p>
<p>输入: &quot;MCMXCIV&quot;<br>
输出: 1994<br>
解释: M = 1000, CM = 900, XC = 90, IV = 4.</p>
<p>提示：</p>
<p>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>
IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。<br>
关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/roman-to-integer<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>把罗马数字对应的整数存放到一个数组里，对s从头遍历，如果s[i] != reps[j][0]则j++，因为reps是字符串而且要判断的是首字母，所以是reps[j][0]。当s[i] == reps[j][0]时，还需要判断是不是特殊情况比如：四对应的IV，是对应的IX</p>
<p><code>if (reps[j].size() &gt; 1)</code>则说明reps当前对应的字符串属于特殊情况，<code>if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1])</code>说明s当前对应的数字与reps当前对应的数字相匹配，因为一个数占了两个字符所以要i++，j++。再把num累加。</p>
<p><code>if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1])</code>不满足的情况有可能为s对应IV，reps对应IX，这样虽然前面的I相同但是后面的字符不相同，这种情况就让i不动（因为每次循环结束都会i++，所以先i--），j往后挪一个。</p>
<p>非特殊情况即<code>reps[j].size() &lt;= 1</code>直接将num累加即可</p>
<pre><code class="language-C++">class Solution {
public:
    int romanToInt(string s) {
        if (s.size() == 0) {
            return 0;
        }
        int values[]= {1000,900,500,400,100,90,50,40,10,9,5,4,1};
		string reps[]= {&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;};
        int j = 0, num = 0;
        for (int i = 0; i &lt; s.size(); i++) {
            while (s[i] != reps[j][0]) {
                j++;
            }
            if (reps[j].size() &gt; 1) {
                if (i &lt; s.size() - 1 &amp;&amp; s[i + 1] == reps[j][1]) {
                    i++;
                    num += values[j];
                    j++;
                }
                else {
                    i--;
                    j++;
                }
            }
            else {
                num += values[j];
            }
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[堆排序(排序)]]></title>
        <id>https://sakuratears.cn/post/dui-pai-xu/</id>
        <link href="https://sakuratears.cn/post/dui-pai-xu/">
        </link>
        <updated>2020-12-25T10:02:22.000Z</updated>
        <content type="html"><![CDATA[<h3 id="定义">定义</h3>
<p><strong>堆排序</strong>：是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子节点的键值或索引总是小于（或者大于）它的父节点。</p>
<h3 id="概述">概述</h3>
<p>若以升序排序说明，把数组转换成最大堆(Max-Heap Heap)，这是一种满足最大堆性质(Max-Heap Property)的二叉树：对于除了根之外的每个节点i, A[parent(i)] ≥ A[i]。<br>
重复从最大堆取出数值最大的结点(把根结点和最后一个结点交换，把交换后的最后一个结点移出堆)，并让残余的堆维持最大堆性质。</p>
<h3 id="堆节点的访问">堆节点的访问</h3>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<p>父节点i的左子节点在位置(2i + 1);<br>
父节点i的右子节点在位置(2i + 2));<br>
子节点i的父节点在位置(i - 1) / 2;</p>
<h3 id="操作">操作</h3>
<p>在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build Max Heap）：将堆中的所有数据重新排序</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-C++">#include &lt;malloc.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void swap(int *a, int *b)
{
    int temp = *b;
    *b = *a;
    *a = temp;
}

void max_heapify(int arr[], int start, int end)
{
    // 建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son &lt;= end)
    {                                                  // 若子节点指标在范围内才做比较
        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] &gt; arr[son]) //如果父节点大于子节点代表调整完毕，直接跳出函数
            return;
        else
        { // 否则交换父子内容再继续子节点和孙节点比较
            swap(&amp;arr[dad], &amp;arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len)
{
    int i;
    // 初始化，i从最后一个父节点开始调整
    for (i = len / 2 - 1; i &gt;= 0; i--)
        max_heapify(arr, i, len - 1);
    // 先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕
    for (i = len - 1; i &gt; 0; i--)
    {
        swap(&amp;arr[0], &amp;arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main()
{
    // int arr[] = {9, 10, 5, 11, 12, 7};
    // int len = (int)sizeof(arr) / sizeof(*arr);

    int len;
    printf(&quot;输入数组长度&quot;);
    scanf(&quot;%d&quot;, &amp;len);
    int *arr = (int *)malloc(sizeof(int) * len);
    printf(&quot;输入数组：&quot;);
    for (int i = 0; i &lt; len; i++)
    {
        scanf(&quot;%d&quot;, &amp;arr[i]);
    }
    heap_sort(arr, len);
    int i;
    for (i = 0; i &lt; len; i++)
        printf(&quot;%d &quot;, arr[i]);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>(来自：维基百科)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 455. 分发饼干(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-455-fen-fa-bing-gan-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-455-fen-fa-bing-gan-tan-xin/">
        </link>
        <updated>2020-12-25T09:05:53.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<!-- more -->
<p>示例 1:<br>
输入: g = [1,2,3], s = [1,1]<br>
输出: 1<br>
解释:<br>
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>
所以你应该输出1。</p>
<p>示例 2:<br>
输入: g = [1,2], s = [1,2,3]<br>
输出: 2<br>
解释:<br>
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。<br>
你拥有的饼干数量和尺寸都足以让所有孩子满足。<br>
所以你应该输出2.<br>
 <br>
提示：</p>
<p>1 &lt;= g.length &lt;= 3 * 104<br>
0 &lt;= s.length &lt;= 3 * 104<br>
1 &lt;= g[i], s[j] &lt;= 231 - 1</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/assign-cookies<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>现将孩子胃口数组和饼干尺寸排序，然后遍历孩子胃口，如果孩子胃口大于当前饼干尺寸饼干尺寸指针后移直到当前孩子胃口小于等于当前饼干尺寸</p>
<pre><code class="language-C++">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int n = 0;
        for (int i = 0, j = 0; i &lt; g.size(); i++) {
            while (j &lt; s.size() &amp;&amp; g[i] &gt; s[j]) {
                j++;
            }
            if (j &lt; s.size() &amp;&amp; g[i] &lt;= s[j]) {
                n++;
                j++;
            }
        }
        return n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode 135. 分发糖果(贪心)]]></title>
        <id>https://sakuratears.cn/post/leetcode-135-fen-fa-tang-guo-tan-xin/</id>
        <link href="https://sakuratears.cn/post/leetcode-135-fen-fa-tang-guo-tan-xin/">
        </link>
        <updated>2020-12-24T11:14:12.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>
相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>
那么这样下来，老师至少需要准备多少颗糖果呢？</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<p>每个孩子至少分配到 1 个糖果。<br>
相邻的孩子中，评分高的孩子必须获得更多的糖果。<br>
那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: [1,0,2]<br>
输出: 5<br>
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。<br>
示例 2:</p>
<p>输入: [1,2,2]<br>
输出: 4<br>
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。<br>
第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/candy<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>根据题意得出规则：<br>
A在B左边<br>
左规则：<code>if(ratings[A] &lt; ratings[B])</code>则B获得糖比A多<br>
右规则：<code>if(ratings[A] &gt; ratings[B])</code>则A获得糖比B多</p>
<pre><code class="language-markdown">1.先从左到右遍历，将每个人得到糖果数记录到left数组中
    1.将left用1填充（给所有学生一个糖果）
    2.``if (ratings[i] &gt; ratings[i - 1])``则``left[i] = left[i - 1] + 1``
    3.``if (ratings[i] &lt; ratings[i - 1])``不变
2.再从右到左遍历，将每个人得到糖果数记录到right数组中，规则满足右规则
3.最终取left[i]和right[i]中最大值，即可同时满足左规则和右规则
</code></pre>
<pre><code class="language-C++">class Solution {
public:
    int candy(vector&lt;int&gt;&amp; ratings) {
        int num = 0;
        vector&lt;int&gt; left(ratings.size(), 1);
        vector&lt;int&gt; right(ratings.size(), 1);
        for (int i = 1; i &lt; ratings.size(); i++) {
            if (ratings[i] &gt; ratings[i - 1]) {
                left[i] = left[i - 1] + 1;
            }
        }
        for (int i = ratings.size() - 2; i &gt;= 0; i--) {
            if (ratings[i] &gt; ratings[i + 1]) {
                right[i] = right[i + 1] + 1;
            }
        }
        for (int i = 0; i &lt; ratings.size(); i++) {
            num += max(left[i], right[i]);
        }
        return num;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[切分木棒(DFS)(BFS)]]></title>
        <id>https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/</id>
        <link href="https://sakuratears.cn/post/qie-fen-mu-bang-dfsbfs/">
        </link>
        <updated>2020-12-24T09:29:49.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>假设要把长度为 n 厘米的木棒切分为 1 厘米长的小段，但是 1 根木棒只能由 1 人切分，当木棒被切分为 3 段后，可以同时由 3 个人分别切分木棒（图 2）。</p>
<!-- more -->
<p><img src="http://www.ituring.com.cn/figures/2017/ProgrammerPuzzle/07.d01z.014.png" alt="图 2　n ＝ 8，m ＝ 3 的时候" loading="lazy"><br>
求最多有 m 个人时，最少要切分几次。譬如 n ＝ 8，m＝ 3 时如图所示，切分 4 次就可以了。</p>
<p>作者：图灵教育<br>
链接：https://leetcode-cn.com/leetbook/read/interesting-algorithm-puzzles-for-programmers/90ach5/<br>
来源：力扣（LeetCode）<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1dfs">方法1：DFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	if (num &gt;= n) { //达到要求结束
		return 0;
	}
	else if (num &lt; m) { //目前段数小于人数，直接段数*2
		return 1 + sil(m, n, num * 2);
	}
	else { //目前段数大于等于人数，增加m段
		return 1 + sil(m, n, num + m);
	}
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
<h4 id="方法2bfs">方法2：BFS</h4>
<pre><code class="language-C++">#include &lt;iostream&gt;

using namespace std;

int sil(int m, int n, int num) //n要求段数  m人数 num目前段数
{
	int count = 0;
	while (num &lt; n) {
		num += num &lt; m ? num : m;
        /*
		if (num &lt; m) {
			num += num;
		}
		else {
			num += m;
		}
		count++;
		*/
		count++;
	}
	return count;
}

int main()
{
	cout&lt;&lt;sil(3, 20, 1)&lt;&lt;endl&lt;&lt;sil(5, 100, 1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>