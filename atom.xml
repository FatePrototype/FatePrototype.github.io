<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sakuratears.cn</id>
    <title>SakuraTears</title>
    <updated>2020-12-19T10:52:51.867Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sakuratears.cn"/>
    <link rel="self" href="https://sakuratears.cn/atom.xml"/>
    <subtitle>努力不一定成功，但不努力一定很轻松</subtitle>
    <logo>https://sakuratears.cn/images/avatar.png</logo>
    <icon>https://sakuratears.cn/favicon.ico</icon>
    <rights>All rights reserved 2020, SakuraTears</rights>
    <entry>
        <title type="html"><![CDATA[旋转图像(数组)]]></title>
        <id>https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/</id>
        <link href="https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/">
        </link>
        <updated>2020-12-19T10:45:03.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个 n × n 的二维矩阵表示一个图像。<br>
将图像顺时针旋转 90 度。</p>
<!-- more -->
<p>说明：</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<p>示例 1:</p>
<p>给定 matrix =<br>
[<br>
[1,2,3],<br>
[4,5,6],<br>
[7,8,9]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[7,4,1],<br>
[8,5,2],<br>
[9,6,3]<br>
]<br>
示例 2:</p>
<p>给定 matrix =<br>
[<br>
[ 5, 1, 9,11],<br>
[ 2, 4, 8,10],<br>
[13, 3, 6, 7],<br>
[15,14,12,16]<br>
],</p>
<p>原地旋转输入矩阵，使其变为:<br>
[<br>
[15,13, 2, 5],<br>
[14, 3, 4, 1],<br>
[12, 6, 8, 9],<br>
[16, 7,10,11]<br>
]</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/rotate-image<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p><strong>题目要求不要用辅助数组，此题解用了辅助数组</strong><br>
直接用一个辅助数组arr，arr的列是matrix的行，用两个循环即可</p>
<pre><code class="language-C++">class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;vector&lt;int&gt;&gt; arr = matrix;
        for (int i = 0, j = matrix.size() - 1; i &lt; matrix.size(); i++, j--) {
            for (int m = 0; m &lt; matrix[i].size(); m++) {
                arr[m][j] = matrix[i][m];
            }
        }
        matrix = arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markdown语法]]></title>
        <id>https://sakuratears.cn/post/markdown-yu-fa/</id>
        <link href="https://sakuratears.cn/post/markdown-yu-fa/">
        </link>
        <updated>2020-12-18T13:26:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="生成目录">生成目录</h1>
<p>在markdown顶部输入<code>[TOC]</code>即可生成目录</p>
<h1 id="markdown标题">Markdown标题</h1>
<p>Markdown标题有两种</p>
<h2 id="第一种标题">第一种标题</h2>
<p>使用=和-标记</p>
<pre><code class="language-markdown">我展示的是一级标题
=================

我展示的是二级标题
-----------------
</code></pre>
<h2 id="第二种标题">第二种标题</h2>
<p>使用#标记</p>
<pre><code class="language-markdown"># 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
</code></pre>
<h1 id="markdown-段落格式">Markdown 段落格式</h1>
<h2 id="markdown-段落">Markdown 段落</h2>
<p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。或者</p>
<pre><code class="language-markdown">&lt;br&gt;&lt;br&gt;
</code></pre>
<h2 id="字体">字体</h2>
<pre><code class="language-markdown">*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
</code></pre>
<p><em>斜体文本</em><br>
<em>斜体文本</em><br>
<strong>粗体文本</strong><br>
<strong>粗体文本</strong><br>
<em><strong>粗斜体文本</strong></em><br>
<em><strong>粗斜体文本</strong></em></p>
<h2 id="分隔线">分隔线</h2>
<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code class="language-markdown">***

* * *

*****

- - -

----------
</code></pre>
<h2 id="删除线">删除线</h2>
<p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 <code>~~</code> 即可，实例如下：</p>
<pre><code class="language-markdown">RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
</code></pre>
<p>RUNOOB.COM<br>
GOOGLE.COM<br>
<s>BAIDU.COM</s></p>
<h2 id="下划线">下划线</h2>
<p>下划线可以通过 HTML 的<code>&lt;u&gt;</code> 标签来实现：</p>
<pre><code class="language-markdown">&lt;u&gt;带下划线文本&lt;/u&gt;
</code></pre>
<p><u>带下划线文本</u></p>
<h2 id="脚注">脚注</h2>
<p>脚注是对文本的补充说明。</p>
<p>Markdown 脚注的格式如下:</p>
<pre><code class="language-markdown">[^要注明的文本]
</code></pre>
<p>以下实例演示了脚注的用法：</p>
<pre><code class="language-markdown">创建脚注格式类似这样 [^RUNOOB]。

[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！
</code></pre>
<p>创建脚注格式类似这样 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h1 id="markdown-列表">Markdown 列表</h1>
<h2 id="无序列表">无序列表</h2>
<p>Markdown 支持有序列表和无序列表。<br>
无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p>
<pre><code class="language-markdown">* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项

- 第一项
- 第二项
- 第三项
</code></pre>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
<h2 id="有序列表">有序列表</h2>
<p>有序列表使用数字并加上 . 号来表示，如：</p>
<pre><code class="language-markdown">1. 第一项
2. 第二项
3. 第三项
</code></pre>
<ol>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ol>
<h2 id="列表嵌套">列表嵌套</h2>
<p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p>
<pre><code class="language-markdown">1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
    - 第二项嵌套的第二个元素
   
</code></pre>
<ol>
<li>第一项：
<ul>
<li>第一项嵌套的第一个元素</li>
<li>第一项嵌套的第二个元素</li>
</ul>
</li>
<li>第二项：
<ul>
<li>第二项嵌套的第一个元素</li>
<li>第二项嵌套的第二个元素</li>
</ul>
</li>
</ol>
<h1 id="markdown-区块">Markdown 区块</h1>
<p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：</p>
<pre><code class="language-markdown">&gt; 区块引用
&gt; 菜鸟教程
&gt; 学的不仅是技术更是梦想
</code></pre>
<blockquote>
<p>区块引用<br>
菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
<p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p>
<pre><code class="language-markdown">&gt; 最外层
&gt; &gt; 第一层嵌套
&gt; &gt; &gt; 第二层嵌套
</code></pre>
<blockquote>
<p>最外层</p>
<blockquote>
<p>第一层嵌套</p>
<blockquote>
<p>第二层嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="区块中使用列表">区块中使用列表</h2>
<p>区块中使用列表实例如下:</p>
<pre><code class="language-markdown">&gt; 区块中使用列表
&gt; 1. 第一项
&gt; 2. 第二项
&gt; + 第一项
&gt; + 第二项
&gt; + 第三项
</code></pre>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>第一项</li>
<li>第二项</li>
</ol>
<ul>
<li>第一项</li>
<li>第二项</li>
<li>第三项</li>
</ul>
</blockquote>
<h2 id="列表中使用区块">列表中使用区块</h2>
<p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。<br>
区块中使用列表实例如下：</p>
<pre><code class="language-markdown">* 第一项
    &gt; 菜鸟教程
    &gt; 学的不仅是技术更是梦想
* 第二项
</code></pre>
<ul>
<li>第一项
<blockquote>
<p>菜鸟教程<br>
学的不仅是技术更是梦想</p>
</blockquote>
</li>
<li>第二项</li>
</ul>
<h1 id="markdown-代码">Markdown 代码</h1>
<p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来<code>（`）</code>，例如：</p>
<pre><code class="language-markdown">`printf()` 函数
</code></pre>
<p><code>printf()</code> 函数</p>
<h2 id="代码区块">代码区块</h2>
<p>代码区块使用 4 个空格或者一个制表符（Tab 键）。</p>
<p>实例如下：<br>
printf(&quot;hello&quot;)</p>
<p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p>
<pre><code class="language-markdown">​```javascript
$(document).ready(function () {
    alert('hello word!');
});
​```
</code></pre>
<pre><code class="language-javascript">$(document).ready(function () {
    alert('hello word!');
});
</code></pre>
<h1 id="markdown-链接">Markdown 链接</h1>
<p>链接使用方法如下：</p>
<pre><code class="language-markdown">[链接名称](链接地址)

或者

&lt;链接地址&gt;
</code></pre>
<p><a href="https://sakuratears.cn">blog</a></p>
<p>或者</p>
<p><a href="https://sakuratears.cn">https://sakuratears.cn</a></p>
<h2 id="高级链接">高级链接</h2>
<p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [Google][1]
这个链接用 sakura 作为网址变量 [sakura][sakura]
然后在文档的结尾为变量赋值（网址）

  [1]: http://www.google.com/
  [sakura]: https://sakuratears.cn/
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">Google</a><br>
这个链接用 sakura 作为网址变量 <a href="https://sakuratears.cn/">sakura</a><br>
然后在文档的结尾为变量赋值（网址）</p>
<h1 id="markdown-图片">Markdown 图片</h1>
<p>Markdown 图片语法格式如下：</p>
<pre><code class="language-markdown">![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &quot;可选标题&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB" loading="lazy"></figure>
<p>当然，你也可以像网址那样对图片网址使用变量:</p>
<pre><code class="language-markdown">这个链接用 1 作为网址变量 [RUNOOB][1].
然后在文档的结尾为变量赋值（网址）

[1]: http://static.runoob.com/images/runoob-logo.png
</code></pre>
<p>这个链接用 1 作为网址变量 <a href="http://www.google.com/">RUNOOB</a>.<br>
然后在文档的结尾为变量赋值（网址）</p>
<p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。</p>
<pre><code class="language-markdown">&lt;img src=&quot;http://static.runoob.com/images/runoob-logo.png&quot; width=&quot;50%&quot;&gt;
</code></pre>
<img src="http://static.runoob.com/images/runoob-logo.png" width="50%">
<h1 id="markdown-表格">Markdown 表格</h1>
<p>Markdown 制作表格使用 <code>|</code>来分隔不同的单元格，使用<code>-</code> 来分隔表头和其他行。<br>
语法格式如下：</p>
<pre><code class="language-markdown">|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
</code></pre>
<p>对齐方式</p>
<p>我们可以设置表格的对齐方式：</p>
<p><code>-:</code> 设置内容和标题栏居右对齐。<br>
<code>:-</code>设置内容和标题栏居左对齐。<br>
<code>:-:</code>设置内容和标题栏居中对齐。</p>
<pre><code class="language-markdown">| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">左对齐</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:center">居中对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
<tr>
<td style="text-align:left">单元格</td>
<td style="text-align:right">单元格</td>
<td style="text-align:center">单元格</td>
</tr>
</tbody>
</table>
<h1 id="markdown-高级技巧">Markdown 高级技巧</h1>
<h2 id="支持的-html-元素">支持的 HTML 元素</h2>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p>
<p>目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等 ，如：</p>
<pre><code class="language-markdown">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑
</code></pre>
<p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
<h2 id="转义">转义</h2>
<p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p>
<pre><code class="language-markdown">**文本加粗** 
\*\* 正常显示星号 \*\*
</code></pre>
<p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code class="language-markdown">\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
</code></pre>
<h2 id="公式">公式</h2>
<p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p>
<pre><code class="language-markdown">$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
</code></pre>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 248: …
\end{vmatrix}
$̲{$tep1}{\style{…'>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\
\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>菜鸟教程 -- 学的不仅是技术，更是梦想！！！ <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[找不同(位运算)(哈希表)]]></title>
        <id>https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/</id>
        <link href="https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/">
        </link>
        <updated>2020-12-18T09:38:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定两个字符串 s 和 t，它们只包含小写字母。<br>
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。<br>
请找出在 t 中被添加的字母。</p>
<!-- more -->
<p></p>
<p>示例 1：<br>
输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;<br>
输出：&quot;e&quot;<br>
解释：'e' 是那个被添加的字母。</p>
<p>示例 2：<br>
输入：s = &quot;&quot;, t = &quot;y&quot;<br>
输出：&quot;y&quot;</p>
<p>示例 3：<br>
输入：s = &quot;a&quot;, t = &quot;aa&quot;<br>
输出：&quot;a&quot;</p>
<p>示例 4：<br>
输入：s = &quot;ae&quot;, t = &quot;aea&quot;<br>
输出：&quot;a&quot;<br>
 <br>
提示：</p>
<p>0 &lt;= s.length &lt;= 1000<br>
t.length == s.length + 1<br>
s 和 t 只包含小写字母</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/find-the-difference<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1位运算">方法1：位运算</h4>
<p><sup>运算符：0与任何数ch做</sup>运算都是ch<br>
相同字符异或为0</p>
<p>因为t中的字符是s + ch，所以s与t做异或剩下的就是ch</p>
<pre><code class="language-C++">class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for(char c : s + t) {
            res ^= c;
        }
        return res;
    }
};
</code></pre>
<h4 id="方法2哈希表">方法2：哈希表</h4>
<p>把s中所有元素存到一个哈希表mpS里，t中所有元素存到一个哈希表mpT里<br>
然后比较两个哈希表每个元素个数，不一样的就是题目所求</p>
<pre><code class="language-C++">char findTheDifference(string s, string t) {
        unordered_map&lt;char, int&gt; mpS;
        unordered_map&lt;char, int&gt; mpT;
        char ch;
        for (auto ch : s) {
            mpS[ch]++;
        }
        for (auto ch : t) {
            mpT[ch]++;
        }

        for (ch = 'a'; ch &lt;= 'z'; ch++) {
            if (mpS[ch] != mpT[ch]) {
                return ch;
            }
        }
        return ch;
    }
    ```</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最长公共前缀(字符串)]]></title>
        <id>https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/</id>
        <link href="https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/">
        </link>
        <updated>2020-12-18T09:02:23.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 &quot;&quot;。</p>
<!-- more -->
<p>示例 1:</p>
<p>输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]<br>
输出: &quot;fl&quot;<br>
示例 2:</p>
<p>输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]<br>
输出: &quot;&quot;<br>
解释: 输入不存在公共前缀。<br>
说明:</p>
<p>所有输入只包含小写字母 a-z 。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-common-prefix<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>直接每个字符串从头开始元素比较，不一样直接return即可A</p>
<pre><code class="language-C++">class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        string str = &quot;&quot;;
        if (strs.size() == 0) {
            return str;
        }
        char ch;
        int i, j, min = INT_MAX;
        for (int m = 0; m &lt; strs.size(); m++) {
            if (strs[m].size() &lt; min) {
                min = strs[m].size();
            }
        }
        for (i = 0; i &lt; min; i++) {
            ch = strs[0][i];
            for (j = 0; j &lt; strs.size(); j++) {
                if (strs[j][i] != ch) {
                    return str;
                }
            }
            str += ch;
        }
        return str;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[斐波那契数列(递归)]]></title>
        <id>https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/</id>
        <link href="https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/">
        </link>
        <updated>2020-12-17T09:13:05.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：<br>
F(0) = 0,   F(1) = 1<br>
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<!-- more -->
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：n = 2<br>
输出：1<br><br><br>
示例 2：</p>
<p>输入：n = 5<br>
输出：5<br><br></p>
<p>提示：</p>
<p>0 &lt;= n &lt;= 100<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<h4 id="方法1递归">方法1：递归</h4>
<p>常规递归方法，然后愉快的超时</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }
};
</code></pre>
<h4 id="方法2带备忘录的递归自顶向下">方法2：带备忘录的递归（自顶向下）</h4>
<p>可以把递归看成一颗树，自顶向下<br>
在递归的过程中很多元素其实已经被访问过了，比如n = 20，求n = 19 + n = 18，求19的时候求n = 18 + n = 17，这里可以看到n = 18被求了两次，下面的元素还有更多次重复的所以一般的递归时间复杂度非常高。如果可以把每个元素的值记录下来，下次求的时候直接用时间可以减少很多。</p>
<pre><code class="language-C++">class Solution {
public:
    vector&lt;int&gt; arr;

    int help(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        if (arr[n] != 0) { //如果已经记录则直接用
            return arr[n];
        }
        //未记录则记录下来
        arr[n - 1] = help(n - 1) % 1000000007;
        arr[n - 2] = help(n - 2) % 1000000007;
        return arr[n - 1] + arr[n - 2];
    }

    int fib(int n) {
        for (int i = 1; i &lt;= 101; i++) {
            arr.push_back(0);
        }
        return help(n) % 1000000007;
    }
};
</code></pre>
<h4 id="方法3dp自底向上">方法3：DP（自底向上）</h4>
<p>方法2是从树的顶端到下面依次递归求值，也可以从树的底端到顶端求。<br>
还是利用一个数组，把每个值记录下来，从底到顶。</p>
<pre><code class="language-C++">class Solution {
public:
    int fib(int n) {
        int dp[101];
        dp[1] = 1;
        dp[2] = 1;
        if (n == 0) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[恢复二叉搜索树(二叉树)]]></title>
        <id>https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/">
        </link>
        <updated>2020-12-16T11:44:46.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p>
<!-- more -->
<p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？<br><br></p>
<p></p>
<p>示例 1：</p>
<p>输入：root = [1,3,null,null,2]<br>
输出：[3,1,null,null,2]<br>
解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。<br><br><br>
示例 2：</p>
<p>输入：root = [3,1,4,null,null,2]<br>
输出：[2,1,4,null,null,3]<br>
解释：2 不能在 3 的右子树中，因为 2 &lt; 3 。交换 2 和 3 使二叉搜索树有效。<br><br></p>
<p>提示：</p>
<p>树上节点的数目在范围 [2, 1000] 内<br>
-231 &lt;= Node.val &lt;= 231 - 1<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/recover-binary-search-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<p>二叉树搜索树中序遍历就是二叉搜索树元素从小到大排列，知道这个就好做了。<br>
采用中序遍历：每个节点和前一个相比，小的话就把前一个节点记录下来(只有第一次记录前一个节点，因为题目说明只有两个元素错位)，然后下一次遇到前一个元素比后面的元素大的情况把后一个元素记录下来。<br>
最后把两个记录点的val交换。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = new TreeNode(-2147483648);
    TreeNode* s = NULL;
    TreeNode* t = new TreeNode();

    void recover(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        recover(root-&gt;left);
        if (root-&gt;val &lt; pre-&gt;val) {
            s = (s == NULL) ? pre:s;
            t = root; 
        }
        pre = root;
        recover(root-&gt;right);
    }
    void recoverTree(TreeNode* root) {
        recover(root);
        int n = s-&gt;val;
        s-&gt;val = t-&gt;val;
        t-&gt;val = n;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的锯齿形层次遍历(二叉树)(BFS)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/">
        </link>
        <updated>2020-12-15T09:01:22.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。<br><br></p>
<!-- more -->
<p>例如：<br>
给定二叉树 [3,9,20,null,null,15,7],</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
<p>返回锯齿形层次遍历如下：</p>
<p>[<br>
[3],<br>
[20,9],<br>
[15,7]<br>
]<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>首先把每一行所有节点存放到一个数组中，然后再把这个数组存放到一个二维数组中，然后把一维数组清空。依次遍历，然后每遍历完一行下一行数组翻转即可。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子，判断是否翻转
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        vector&lt;vector&lt;int&gt;&gt; arr;
        vector&lt;int&gt; brr;
        if (root == NULL) {
            return arr;
        }
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        TreeNode* node;
        while (!q.empty()) { //BFS
            int n = q.size(); //记录当前队列元素数量
            for (int i = 0; i &lt; n; i++) {
                brr.push_back(q.front()-&gt;val); //把上一层所有节点加入到一维数组中
                node = q.front();
                q.pop();
                if (node-&gt;left != NULL) {
                    q.push(node-&gt;left);
                }
                if (node-&gt;right != NULL) {
                    q.push(node-&gt;right);
                }
            }
            if (jud == true) { //翻转
                reverse(brr.begin(), brr.end());
                jud = false; //更改反转因子
            }
            else { //不翻转
                jud = true; //更改反转因子
            }
            arr.push_back(brr); //把一维数组加入到二维数组
            brr.clear(); //然后把一维数组清空
        }
        return arr;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的序列化与反序列化(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/">
        </link>
        <updated>2020-12-15T00:23:20.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>
<!-- more -->
<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>
<p>示例:</p>
<p>你可以将以下二叉树：</p>
<pre><code>      1
     / \
    2   3
       / \
      4   5
</code></pre>
<p>序列化为 &quot;[1,2,3,null,null,4,5]&quot;<br>
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</p>
<p>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="思路">思路</h3>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        queue&lt;TreeNode*&gt; q;
        q.push(root);
        string str = &quot;&quot;;
        TreeNode* node;
        while (!q.empty()) {
            int n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (node == NULL) {
                    str += &quot;null,&quot;;
                    continue;
                }
                str += to_string(node-&gt;val);
                str += &quot;,&quot;;
                q.push(node-&gt;left);
                q.push(node-&gt;right);
            }
        }
        return str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data[0] == 'n') {
            return NULL;
        }
        int m = 0, n = 0;
        TreeNode* node;
        queue&lt;TreeNode*&gt; q;
        vector&lt;int&gt; arr;
        string str = &quot;&quot;;
        while (m &lt; data.size()) {
            if (data[m] == ',') {
                if (!str.empty())
                    arr.push_back(stoi(str));
                str = &quot;&quot;;
                m++;
                continue;
            }
            if (data[m] == 'n') {
                m += 4;
                if (!str.empty())
                    arr.push_back(stoi(str));
                arr.push_back(-1024);
                str = &quot;&quot;;
                continue;
            }
            str += data[m];
            m++;
        }
        TreeNode* root = new TreeNode(arr[0]);
        if (arr.size() == 1) {
            return root;
        }
        m = 1;
        q.push(root);
        while (!q.empty() &amp;&amp; m &lt; arr.size()) {
            n = q.size();
            for (int i = 0; i &lt; n; i++) {
                node = q.front();
                q.pop();
                if (arr[m] != -1024) {
                    node-&gt;left = new TreeNode(arr[m]);
                    q.push(node-&gt;left);
                }
                else {
                    node-&gt;left = nullptr;
                }
                if (arr[m + 1] != -1024) {
                    node-&gt;right = new TreeNode(arr[m+1]);
                    q.push(node-&gt;right);
                }
                else {
                    node-&gt;right = nullptr;
                }
                m += 2;
            }
        }
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树的最近公共祖先(二叉树)]]></title>
        <id>https://sakuratears.cn/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu/</id>
        <link href="https://sakuratears.cn/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu/">
        </link>
        <updated>2020-12-14T12:12:36.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<!-- more -->
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br><br></p>
<p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<figure data-type="image" tabindex="1"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt="" loading="lazy"></figure>
<p></p>
<p>示例 1:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>
输出: 3<br>
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。<br><br><br>
示例 2:</p>
<p>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>
输出: 5<br>
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。<br><br></p>
<p>说明:</p>
<p>所有节点的值都是唯一的。<br>
p、q 为不同节点且均存在于给定的二叉树中。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>递归自底向上遍历每个节点：<br>
如果此节点为空返回空；<br>
如果此节点为p或q返回该节点；<br>
如果该节点的左孩子或右孩子为p或q，返回该节点的左子树或右子树；<br>
如果该节点左子树为p右子树为q则该节点为最近公共祖先，返回该节点。</p>
<pre><code class="language-C++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
        if (left != NULL &amp;&amp; right != NULL) {
            return root;
        }
        return left ? left : right;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无重复字符的最长子串(滑动窗口)]]></title>
        <id>https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/</id>
        <link href="https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/">
        </link>
        <updated>2020-12-13T09:21:43.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="题目">题目</h3>
<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<!-- more -->
<p></p>
<p>示例 1:</p>
<p>输入: s = &quot;abcabcbb&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br><br><br>
示例 2:</p>
<p>输入: s = &quot;bbbbb&quot;<br>
输出: 1<br>
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br><br><br>
示例 3:</p>
<p>输入: s = &quot;pwwkew&quot;<br>
输出: 3<br>
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br><br><br>
示例 4:</p>
<p>输入: s = &quot;&quot;<br>
输出: 0<br><br></p>
<p>提示：</p>
<p>0 &lt;= s.length &lt;= 5 * 104<br>
s 由英文字母、数字、符号和空格组成<br><br></p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。<br><br></p>
<h3 id="思路">思路</h3>
<p>定义p为子串的头，j为尾部，p到j为一个窗口，如果新的元素i和窗口里的元素相同，则把p移动到i的后面。记录每一个窗口的长度，最后取最大</p>
<pre><code class="language-C++">class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        if (s.size() == 0)
        {
            return 0;
        }
        int i, j, max, n, p, jud = 0;
        i = 0;
        p = i;
        j = i + 1;
        max = 1;
        n = 1;
        for (; j &lt; s.size(); j++)
        {
            jud = 0;
            for (p = i; p &lt; j; p++)
            {
                if (s[p] == s[j])
                {
                    i = p + 1;
                    if (i == j)
                    {
                        n = 1;
                    }
                    else if (s[i] == s[j])
                    {
                        n = j - i;
                    }
                    else
                    {
                        n = j - i + 1;
                    }
                    jud = 1;
                    break;
                }
            }
            if (jud == 1)
            {
                continue;
            }
            n++;
            if (n &gt; max)
                max = n;
        }
        return max;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>