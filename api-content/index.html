{"posts":[{"title":"二叉树的层序遍历(二叉树)(BFS)","content":"题目 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例： 二叉树：[3,9,20,null,null,15,7], 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了 代码 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector&lt;vector&lt;int&gt;&gt; arr; void BFS(TreeNode* root) { queue&lt;TreeNode*&gt; brr; vector&lt;int&gt; crr; brr.push(root); int n = 0; while (!brr.empty()) { TreeNode* node = brr.front(); n = brr.size(); //n记录当前队列元素个数 for (int i = 0; i &lt; n; i++) { //循环n次 if (node-&gt;left != NULL) { //左孩子不为空则添加左孩子 brr.push(node-&gt;left); } if (node-&gt;right != NULL) { //右孩子不为空则添加右孩子 brr.push(node-&gt;right); } crr.push_back(brr.front()-&gt;val); //每次循环把队列的头元素的值添加到一个数组里 brr.pop(); node = brr.front(); //节点移动到下一个 } arr.push_back(crr); //把当前数组元素添加到二维数组中 crr.clear(); //当前数组清空 } } vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { if (root == NULL) { return arr; } BFS(root); return arr; } }; ","link":"https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/"},{"title":"从前序与中序遍历序列构造二叉树(二叉树)","content":"题目 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 和上一题基本一样0.0 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* build(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { TreeNode* tree = new TreeNode(preorder[0]); if (inorder.size() &lt;= 1) { return tree; } int i, m; for (i = 0; i &lt; inorder.size(); i++) { if (inorder[i] == preorder[0]) { break; } } m = i; vector&lt;int&gt; arr0, arr1, brr0, brr1; if (m == 0) { tree-&gt;left = NULL; } else { for (int j = 0, i = 1; j &lt; m; j++, i++) { arr0.push_back(preorder[i]); brr0.push_back(inorder[j]); } tree-&gt;left = build(arr0, brr0); } if (m &gt;= inorder.size() - 1) { tree-&gt;right = NULL; } else { for (int j = m + 1; j &lt; inorder.size(); j++) { arr1.push_back(preorder[j]); brr1.push_back(inorder[j]); } tree-&gt;right = build(arr1, brr1); } return tree; } TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { if (inorder.size() == 0 || preorder.size() == 0) { return NULL; } return build(preorder, inorder); } }; ","link":"https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/"},{"title":"从中序与后序遍历序列构造二叉树(二叉树)","content":"题目 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素。 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 得到结果：[3,9,20,null,null,15,7] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 二叉树的后序遍历最后一个元素是二叉树的的根节点，然后中序遍历根节点左边元素是左子树的节点，右边是右子树的节点。 知道这个这道题就很简单了，用递归调用求左子树右子树。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { TreeNode* tree = new TreeNode(postorder[postorder.size() - 1]); if (inorder.size() &lt;= 1) { return tree; } int i, m; //找到根节点m for (i = 0; i &lt; inorder.size(); i++) { if (inorder[i] == postorder[postorder.size() - 1]) { break; } } m = i; vector&lt;int&gt; arr0, arr1, brr0, brr1; if (m == 0) { //考虑左边已经空了的情况 tree-&gt;left = NULL; } else { for (int i = 0; i &lt; m; i++) { arr0.push_back(inorder[i]); brr0.push_back(postorder[i]); } tree-&gt;left = build(arr0, brr0); } if (m &gt;= inorder.size() - 1) { //考虑右边已经空了的情况 tree-&gt;right = NULL; } else { for (int i = m + 1, j = m; i &lt; inorder.size(); i++, j++) { arr1.push_back(inorder[i]); brr1.push_back(postorder[j]); } tree-&gt;right = build(arr1, brr1); } return tree; } TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) { if (inorder.size() == 0 || postorder.size() == 0) { return NULL; } return build(inorder, postorder); } }; ","link":"https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/"},{"title":"二叉树的中序遍历(二叉树)","content":"题目 给定一个二叉树的根节点 root ，返回它的 中序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[2,1] 示例 5： 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 &lt;= Node.val &lt;= 100 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 就二叉树的中序遍历，没有任何坑，直接写就行 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; arr; void traversal(TreeNode* root) { if (root == NULL) { return; } inorderTraversal(root-&gt;left); arr.push_back(root-&gt;val); inorderTraversal(root-&gt;right); } vector&lt;int&gt; inorderTraversal(TreeNode* root) { traversal(root); return arr; } }; ","link":"https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/"},{"title":"对称二叉树(二叉树)","content":"题目 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 判断二叉树是否对称可以理解为判断一个节点的两个子树的里侧和外侧是否对称，就是后序遍历。 判断外侧是否对称，传入左节点的左孩子，右节点的右孩子。 判断里侧是否对称，传入左节点的右孩子，右节点的左孩子。 可以用递归挨个判断，所以递归函数传的值就要是left,right两个，想通这一点就好做了。 判断空的情况， 左空右空 返回true 左空右不空 返回false 左不空右空 返回false 最后是都不空，判断值 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool cmp(TreeNode* left, TreeNode* right) { if (left == NULL &amp;&amp; right == NULL) { return true; } else if (left == NULL &amp;&amp; right != NULL) { return false; } else if (left != NULL &amp;&amp; right == NULL) { return false; } //都不空判断值 else if (left-&gt;val != right-&gt;val) { return false; } bool in = cmp(left-&gt;right, right-&gt;left); bool out = cmp(left-&gt;left, right-&gt;right); return in &amp;&amp; out; } bool isSymmetric(TreeNode* root) { if (root == NULL) { return true; } return cmp(root-&gt;left, root-&gt;right); } }; ","link":"https://sakuratears.cn/post/dui-cheng-er-cha-shu/"},{"title":"平衡二叉树(二叉树)","content":"题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 &lt;= Node.val &lt;= 104 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/balanced-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 还是用二叉树的框架就行，每个节点的最大深度就是左子树或右子树中的最大深度加1 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool jud = true; //判断因子 int deep(TreeNode* root) { if (root == nullptr) { return 0; } int left = deep(root-&gt;left); int right = deep(root-&gt;right); if (abs(left - right) &gt; 1) { //如果左右子树深度相差大于1将判断因子设为false; jud = false; } return max(left, right) + 1; } bool isBalanced(TreeNode* root) { if (root == nullptr) { return true; } deep(root); return jud; } }; ","link":"https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/"},{"title":"二叉树中的最大路径和(二叉树)(DFS)","content":"题目 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1： 输入：[1,2,3] 1 / \\ 2 3 输出：6 示例 2： 输入：[-10,9,20,null,null,15,7] -10 / 9 20 / 15 7 输出：42 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 每一个节点的最大路径是它左右子树中最大的路径加上它自己，这样就是先遍历左子树，再遍历右子树。 这样就是树的后序遍历+DFS的思想。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int imax = INT_MIN; int maxpath(TreeNode* root) { if (root == nullptr) { return 0; } int left = max(0, maxpath(root-&gt;left)); int right = max(0, maxpath(root-&gt;right)); /*二叉树的后序遍历*/ imax = max(imax, left + right + root-&gt;val); return max(left, right) + root-&gt;val; } int maxPathSum(TreeNode* root) { maxpath(root); return imax; } }; ","link":"https://sakuratears.cn/post/er-cha-shu-zhong-de-zui-da-lu-jing-he-er-cha-shu/"},{"title":"杨辉三角(数组)","content":"题目 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 输入: 5 输出: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pascals-triangle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 简单题，直接写就行，leetcode的测试用例也没啥恶心的可能是这个题没法恶心了吧 class Solution { public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) { vector&lt;vector&lt;int&gt;&gt; nums; if (numRows == 0) { //判断0的情况下 return nums; } vector&lt;int&gt; num; num.push_back(1); nums.push_back(num); for (int i = 1; i &lt; numRows; i++) { vector&lt;int&gt; num; num.push_back(1); for (int j = 1; j &lt; i; j++) { num.push_back(nums[i - 1][j - 1] + nums[i - 1][j]); //每行数组的[j]是上一个数组的[j]位置+[j - 1]位置 } num.push_back(1); nums.push_back(num); } return nums; } }; ","link":"https://sakuratears.cn/post/yang-hui-san-jiao/"},{"title":"字符串转换整数 (atoi)(字符串)","content":"题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下： 如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。 假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。 该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0 。 提示： 本题中的空白字符只包括空格字符 ' ' 。 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: &quot;42&quot; 输出: 42 示例 2: 输入: &quot; -42&quot; 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: &quot;4193 with words&quot; 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: &quot;words and 987&quot; 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: &quot;-91283472332&quot; 输出: -2147483648 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/string-to-integer-atoi 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 class Solution { public: int myAtoi(string s) { int i = 0, m = 0, jud = 0, n = 0, p, j = 0; while (s[i] == ' ') { i++; } if (s[i] != '-' &amp;&amp; s[i] != '+' &amp;&amp; (s[i] &gt; 57 || s[i] &lt; 48)) return 0; if ((s[i] == '-' || s[i] == '+') &amp;&amp; (s[i + 1] &gt; 57 || s[i + 1] &lt; 48)) return 0; while (s[i] &gt; 57 || s[i] &lt; 48) { i++; } if (i &gt; 0 &amp;&amp; s[i - 1] == '-') { jud = 1; } while (s[i] == '0') { i++; } if (s[i] &gt; 57 || s[i] &lt; 48) { return 0; } j = i; while (s[i] &lt;= 57 &amp;&amp; s[i] &gt;= 48) { i++; n++;//位数 } if (n &gt; 10) { if (jud == 0) return pow(2, 31) - 1; else return -pow(2, 31); } p = n - 1; for (; j &lt; i; j++) { if ((m + (s[j] - 48) * pow(10, p) &gt; pow(2, 31) - 1) &amp;&amp; jud == 0) { return pow(2, 31) - 1; } if ((m + (s[j] - 48) * pow(10, p) &gt;= pow(2, 31)) &amp;&amp; jud == 1) { return -pow(2, 31); } m += (s[j] - 48) * pow(10, p); p--; } if (jud == 1) { m = -m; } return m; } }; ","link":"https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/"},{"title":"整数反转(数组)","content":"题目 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 多注意爆int的地方，多wa几发就过了手动狗头 class Solution { public: int reverse(int x) { int j = 0, m = 0, num = 0, jud = 0; char str[1000]; int i = 0; if (x &lt; 0) { if (x &lt;= -pow(2, 31)) // 负数正好没爆int，转正可能就会正好爆 return 0; x = -x; jud = 1; } while (x &gt; 0) { str[i++] = x % 10 + 48; x /= 10; } str[i] = '\\0'; if (str[0] == '0') { m = 1; } for (int i = m; str[i] != '\\0'; i++) { j++; } j--; for (int i = m; str[i] != '\\0'; i++) { if ((str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) { //可能爆int的地方 return 0; } if (num + (str[i] - 48) * pow(10, j) &gt; pow(2, 31) - 1 || num + (str[i] - 48) * pow(10, j) &lt; -pow(2, 31)) { //可能爆int的地方 return 0; } num += (str[i] - 48) * pow(10, j); j--; } if (jud != 0) { num = -num; } return num; } }; ","link":"https://sakuratears.cn/post/zheng-shu-fan-zhuan/"},{"title":"Z 字形变换(字符串)","content":"题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2: 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 输出: &quot;LDREOEIIECIHNTSG&quot; 解释: L D R E O E I I E C I H N T S G 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/zigzag-conversion 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 代码1. 纯暴力写出来了，贴个代码算了0.0 class Solution { public: string convert(string s, int numRows) { if (numRows == 1) return s; int num = 0, m = 0, p = 1, j = 0; char arr[1000][1000]; string str; for (int i = 0; i &lt; 1000; i++) { for (int j = 0; j &lt; 1000; j++) { arr[i][j] = NULL; } } for (int i = 0; num &lt; s.size(); i++) { for (j = 0; j &lt; numRows &amp;&amp; num &lt; s.size(); j++) { if (i == 0 || i == m + numRows - 1) { m = i; for (j = 0; j &lt; numRows &amp;&amp; num &lt; s.size(); j++) { arr[j][i] = s[num]; num++; } p = 0; continue; } else { if (j != numRows - 1 &amp;&amp; arr[j + 1][i - 1] != NULL) { if (i != m + 1 &amp;&amp; i != 1) { arr[j][i] = s[num]; p = 0; num++; continue; } else { j = numRows - 2; arr[j][i] = s[num]; i++; j = -1; num++; continue; } } } } } for (int i = 0; i &lt; s.size() &amp;&amp; str.size() != s.size(); i++) { for (int j = 0; j &lt; s.size() &amp;&amp; str.size() != s.size(); j++) { if (arr[i][j] &gt;= 41 &amp;&amp; arr[i][j] &lt;= 176) { str += arr[i][j]; } } } return str; } }; 代码2 1.res[i] += c： 把每个字符 c 填入对应行 s i; 2.i += flag： 更新当前字符 c 对应的行索引； 3.flag = - flag： 在达到 Z 字形转折点时，执行反向 把每一行放到一个字符串数组里面，利用flag就行上下控制。比我那菜鸡算法好太多了 class Solution { public: string convert(string s, int numRows) { if (numRows == 1) { return s; } string str[1000]; int i = 0, flag = 1, num = 0; while (num &lt; s.size()) { str[i] += s[num]; i += flag; if (i &gt;= numRows) { flag = -flag; i += flag; i += flag; } if (i &lt; 0) { flag = -flag; i += flag; i += flag; } num++; } s = &quot;&quot;; for (i = 0; i &lt; numRows; i++) { s += str[i]; } return s; } }; ","link":"https://sakuratears.cn/post/z-zi-xing-bian-huan/"},{"title":"最长回文子串(动态规划)","content":"题目 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: &quot;babad&quot; 输出: &quot;bab&quot; 注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 输入: &quot;cbbd&quot; 输出: &quot;bb&quot; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-palindromic-substring 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 题解 暴力求解 把每个长度大于二的子串都进行验证，然后取最大，时间复杂度O(n3)，然后就愉快的超时0.0 class Solution { public: bool vali(string s, int i, int j) { while (i &lt;= j) { if (s[i] != s[j]) return false; i++; j--; } return true; } string longestPalindrome(string s) { int size = s.size(); if (size &lt; 2) return s; int max = 1; string str = s.substr(0, 1); for (int i = 0; i &lt; size - 1; i++) { for (int j = i + 1; j &lt; size; j++) { if (j - i + 1 &gt; max &amp;&amp; vali(s, i, j)) { max = j - i + 1; str = s.substr(i, max); } } } return str; } }; 动态规划 动态规划关键步骤状态转移： 一个回文去掉两头以后，剩下的部分依然是回文； 如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串； 如果一个字符串的头尾两个字符相等，才有必要继续判断下去。 如果里面的子串是回文，整体就是回文串； 如果里面的子串不是回文串，整体就不是回文串。 定义dp[i][j]表示s[i....j]是否为回文串(左闭右闭)，根据“如果里面的子串判断是否回文”，可以得到转移方程：dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1] == true 然后考虑一下边界问题： s[i + 1......j - 1]，成立的条件为长度小于2，即j - 1 - (i + 1) &lt; 2，即j - i &lt; 3. j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。 如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文； 如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。 因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。 class Solution { public: string longestPalindrome(string s) { int len = s.size(); if (len &lt; 2) return s; int begin = 0; int max = 1; //记录回文子串开始位置和长度 bool dp[len][len]; for (int i = 0; i &lt; len; i++) { dp[i][i] = true; //初始化，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true } for (int j = 1; j &lt; len; j++) { for (int i = 0; i &lt; j; i++) { if (s[i] != s[j]) { dp[i][j] = false; } else { if (j - i &lt; 3) { dp[i][j] = true; } else { dp[i][j] = dp[i + 1][j - 1]; } } if (dp[i][j] &amp;&amp; j - i + 1 &gt; max) { begin = i; max = j - i + 1; } } } string str = &quot;&quot;; for (int i = begin; i &lt; begin + max; i++) { str += s[i]; } return str; } }; 思路参考：liweiwei1419 ","link":"https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/"},{"title":"寻找两个正序数组的中位数(分治)","content":"力扣的困难题极其简单！！！ 题目 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。 进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例 3： 输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例 4： 输入：nums1 = [], nums2 = [1] 输出：1.00000 示例 5： 输入：nums1 = [2], nums2 = [] 输出：2.00000 提示： nums1.length == m nums2.length == n 0 &lt;= m &lt;= 1000 0 &lt;= n &lt;= 1000 1 &lt;= m + n &lt;= 2000 -106 &lt;= nums1[i], nums2[i] &lt;= 106 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 题目过于简单，把小的数组加到大的数组题然后sort，再找中位数。0.0 代码 class Solution { public: double median(vector&lt;int&gt; nums) { if (nums.size() % 2 == 0) { double dou0 = nums[nums.size() / 2]; double dou1 = nums[nums.size() / 2 - 1]; return (dou0 + dou1) / 2; } else { double dou0 = nums[nums.size() / 2]; return dou0; } } double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { if (nums1.size() == 0 &amp;&amp; nums2.size() == 0) return 0; if (nums1.size() &gt;= nums2.size()) { for (int i = 0; i &lt; nums2.size(); i++) { nums1.push_back(nums2[i]); } sort(nums1.begin(), nums1.end()); return median(nums1); } else { for (int i = 0; i &lt; nums1.size(); i++) { nums2.push_back(nums1[i]); } sort(nums2.begin(), nums2.end()); return median(nums2); } } }; ","link":"https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/"},{"title":"朋友圈(并查集)","content":"LeetCode547题 朋友圈 题目 班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。 给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 示例 1： 输入： [[1,1,0], [1,1,0], [0,0,1]] 输出：2 解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。 第2个学生自己在一个朋友圈。所以返回 2 。 示例 2： 输入： [[1,1,0], [1,1,1], [0,1,1]] 输出：1 解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。 提示： 1 &lt;= N &lt;= 200 M[i][i] == 1 M[i][j] == M[j][i] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/friend-circles 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路 运用并查集算出相关集合 并查集不优化代码： void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 将两棵树合并为一棵 parent[rootP] = rootQ; // parent[rootQ] = rootP 也一样 count--; // 两个分量合二为一 } /* 返回某个节点 x 的根节点 */ int find(int x) { // 根节点的 parent[x] == x while (parent[x] != x) x = parent[x]; return x; } /* 返回当前的连通分量个数 */ int count() { return count; } find函数是把一棵树直接接到另一棵树下面，这也就造成了树的退化(往链表退化)，就会使时间复杂度达到O(n)，union和connected都是要用到find，所以他们的时间复杂度也是O(n)。 优化方案 平衡优化 另外开一个数组记录每棵树的“重量”(节点数),节点数少的接到节点数多的树里面，就可以降低复杂度。 void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP == rootQ) return; // 小树接到大树下面，较平衡 if (size[rootP] &gt; size[rootQ]) { parent[rootQ] = rootP; size[rootP] += size[rootQ]; } else { parent[rootP] = rootQ; size[rootQ] += size[rootP]; } count--; } ##### 路径~~亚索~~压缩 如果我们可以进一步压缩树的高度，让树的高度始终为常数，那find的复杂度就是O(1). 压缩完是一个根节点下面都是叶子节点，这样树的高度就为常数，非常友好。 ```C++ int find(int x) { int r = x; while (parent[r] != r) r = parent[r]; //找到根节点 int i = x, j; while (i != r) { //让每个节点都练到根节点上 j = parent[i]; parent[i] = r; i = j; } return r; } ``` ### 代码 ```C++ class Solution { public: int counts; vector parent; vector size; void UF(int n) { counts = n; for (int i = 0; i < n; i++) { parent.push_back(i); size.push_back(1); } } void Union(int p, int q) { int rootp = find(p); int rootq = find(q); if (rootp == rootq) return; if (size[rootp] &gt; size[rootq]) { parent[rootq] = rootp; size[rootp] += size[rootq]; } else { parent[rootp] = rootq; size[rootq] += size[rootp]; } counts--; } int find(int x) { int r = x; while (parent[r] != r) r = parent[r]; int i = x, j; while (i != r) { j = parent[i]; parent[i] = r; i = j; } return r; } bool connected(int p, int q) { int rootp = find(p); int rootq = find(q); return rootp == rootq; } int count() { return counts; } int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; M) { UF(M[0].size()); for (int i = 0; i &lt; M.size(); i++) { for (int j = 0; j &lt; M[0].size(); j++) { if (M[i][j] == 1) { Union(i, j); } } } return counts; } }; ","link":"https://sakuratears.cn/post/bing-cha-ji/"},{"title":"Linux一些环境配置","content":"C/C++ 安装环境g++,gcc,gdb 终端命令 sudo apt-get install g++ sudo apt-get install gcc sudo apt-get install gdb Java jdk,jre ","link":"https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/"},{"title":"Linux(deepin)日常操作","content":"记录日常使用linux一些操作 deepin永远滴神！！！ 安装deb文件 在deb文件目录下终端输入sudo apt-get xx.deb(xx为文件名) 打开tag.gz文件 情况一(没有可执行文件)：解压缩后终端进入文件目录，然后cd进入/bin，执行./xxx.sh(xxx为程序名) 情况二(有可执行文件)：直接运行可执行文件即可运行 进入root身份 终端输入su然后输入密码(开机密码) 如果提示su鉴定故障可以输入sudo su 双系统切换时间问题 终端输入timedatectl set-local-rtc 1 双系统开机默认linux更改 1.ctrl+alt+T打开终端，输入sudo gedit /etc/default/grub 2.验证密码，grub配置文件被打开 3.将弹出的文件中文本“GRUB-DEFAULT=0”中的0修改为2.（我这里是2，具体数字应该和选择系统的时候win系统的位置-1相同。注意这个-1，因为它是从上到下从0开始排序，所以我这里win系统是第三位，就改成2） 4.保存文件。←这时可能会弹出警告框，但是一般情况下好像并没有什么关系 5.在终端输入sudo update-grub以更新配置 6.重启即可发现已经修改完毕 linux显示系统信息 终端执行sudo apt-get install screenfetch安装screenfetch 然后执行screenfetch -s显示系统信息 BIOS声音问题 (deepin)有时候发生错误(比如在QQ输入框没有字的情况下按退格),会出现“嘟”的一声。这是主板BIOS声音没关的问题。 执行 sudo dedit /etc/modprobe.d/alsa-base-blacklist.conf，输入 blacklist pcspkr blacklist snd_pcsp 保存后执行 sudo update-initramfs -u后重启即可。 ","link":"https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/"},{"title":"买卖股票的最佳时机 II(贪心)","content":"题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 0 &lt;= prices[i] &lt;= 10 ^ 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii 思路 第一天买入，第三天卖出的利润是prices[3] - prices[1],也就是(prices[3] - prices[2]) + (prices[2] - porces[1]) 可以发现，我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润就可以了，不需要记录区间。 这就是贪心所贪的地方，只收集正利润。 代码 class Solution { public: int maxProfit(vector&lt;int&gt;&amp; prices) { int result = 0; for (int i = 1; i &lt; prices.size(); i++) { result += max(prices[i] - prices[i - 1], 0); } return result; } }; 思路借鉴作者：carlsun-2 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/122-mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin-xi/ 来源：力扣（LeetCode） ","link":"https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/"},{"title":"C/C++如何传递二维数组？","content":"一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。 如： void Func(int array[3][10]); void Func(int array[][10]); ​ 二者都是合法而且等价，但是不能把第二维或者更高维的大小省略，如下面的定义是不合法的： void Func(int array[][]); 将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。在学编译原理这么课程的时候知道编译器是这样处理数组的： 对于数组 int p[m][n]; 如果要取p[i][j]的值(i&gt;=0 &amp;&amp; i&lt;m &amp;&amp; 0&lt;=j &amp;&amp; j &lt; n)，编译器是这样寻址的，它的地址为： p + i*n + j; 从以上可以看出，如果我们省略了第二维或者更高维的大小，编译器将不知道如何正确的寻址。但是我们在编写程序的时候却需要用到各个维数都不固定的二维数组作为参数，这就难办了，编译器不能识别阿，怎么办呢？不要着急，编译器虽然不能识别，但是我们完全可以不把它当作一个二维数组，而是把它当作一个普通的指针，再另外加上两个参数指明各个维数，然后我们为二维数组手工寻址，这样就达到了将二维数组作为函数的参数传递的目的，根据这个思想，我们可以把维数固定的参数变为维数随即的参数，例如： void Func(int array[3][10]); void Func(int array[][10]); 变为： void Func(int **array, int m, int n); 在转变后的函数中，array[i][j]这样的式子是不对的(不信，大家可以试一下)，因为编译器不能正确的为它寻址，所以我们需要模仿编译器的行为把array[i][j]这样的式子手工转变为 *((int*)array + n*i + j); ​ 在调用这样的函数的时候，需要注意一下，如下面的例子： int a[3][3] = { {1, 1, 1}, {2, 2, 2}, {3, 3, 3} }; Func(a, 3, 3); 根据不同编译器不同的设置，可能出现warning 或者error,可以进行强制转换如下调用： Func((int**)a, 3, 3); 需要(int**）的强制转换，是因为二维数组和二级指针是不同的，a实质上是一个int (a)[3]，它是一个数组指针，即a[0]是第一维数组的首个元素的地址，a[1]是第二维数组的首个元素的地址，a[2]是第三维数组的首个元素的地址，与int*是不同的类型；如果转为int*，就失去了像数组指针那样a + i = a + i3的效果了 而如果又定义一个char *p[3]，它是一个一维的指针数组，此时p是指向了一个指针，而不是数组。那么这时如果定义char **q = p，就是可以的，而且可以通过q[0]，q[1]来访问字符串。 数组和指针这种东西真是太繁琐复杂了，个人愚见，在C++里就尽量使用STL，并且可以用模板的非类型形参来解决这种灵活处理不固定行列数矩阵的函数，Effective C++里面应该有介绍，并且有对这种模板的优化。 转载自CSDN ","link":"https://sakuratears.cn/post/ccru-he-chuan-di-er-wei-shu-zu/"},{"title":"N皇后(回溯)","content":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例： 输入：4 输出：[ [&quot;.Q..&quot;, // 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, // 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;] ] 解释: 4 皇后问题存在两个不同的解法。 提示： 皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/n-queens 经典回溯+递归问题，当发现这种情况不行时就回溯到之前的点。 代码： class Solution { public: int col[12] = {};//将合适的皇后行数放入数组中 vector&lt;vector&lt;string&gt;&gt; arr; vector&lt;string&gt; brr; char crr[100][100]; int cnumber = 0; int num, number = 0, jud = 0, tot = 0; bool check(int c, int r) { int i = 0; for (i = 0; i &lt; r; i++) { if (col[i] == c || (abs(col[i] - c) == abs(i - r))) return false; } return true; } void DFS(int r) { if (r == num) { string str = &quot;&quot;; brr.clear(); for (int j = 0; j &lt; num; j++) { str = &quot;&quot;; for (int i = 0; i &lt; num; i++) { if (crr[j][i] == 'Q') str += &quot;Q&quot;; else str += &quot;.&quot;; } brr.push_back(str); } arr.push_back(brr); return; } for (int c = 0; c &lt; num; c++) { if (check(c, r) == true) { col[r] = c; int i = 0; while (i &lt; num) { if (i == c) { crr[r][i] = 'Q'; } else crr[r][i] = '.'; i++; } DFS(r + 1); } } } vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) { num = n; DFS(0); return arr; } }; ","link":"https://sakuratears.cn/post/n-huang-hou/"},{"title":"水域大小（DFS）（BFS）","content":"DFS BFS例题 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/pond-sizes-lcci 你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。 示例： 输入： [ [0,2,1,0], [0,1,0,1], [1,1,0,1], [0,1,0,1] ] 输出： [1,2,4] 提示： 0 &lt; len(land) &lt;= 1000 0 &lt; len(land[i]) &lt;= 1000 此题DFS，BFS都可以用。 (代码格式为leetcode模板格式) 代码: BFS class Solution { public: int n = 0; vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};//可以斜着所以是8个方向 struct Node {int x; int y;}; queue&lt;Node&gt; q; int BFS(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; land) { n = 1; Node start, node; start.x = i; start.y = j; land[i][j] = 1; q.push(start); while (!q.empty()) { start = q.front(); q.pop(); for (int i = 0; i &lt; 8; i++) { node.x = start.x + dirs[i][0]; node.y = start.y + dirs[i][1]; if (node.x &gt;= 0 &amp;&amp; node.x &lt; land.size() &amp;&amp; node.y &gt;= 0 &amp;&amp; node.y &lt; land[0].size() &amp;&amp; land[node.x][node.y] == 0)//判断是否为鱼塘 { q.push(node); land[node.x][node.y] = 1;//染色 n++; } } } return n; } vector&lt;int&gt; pondSizes(vector&lt;vector&lt;int&gt;&gt;&amp; land) { vector&lt;int&gt; arr; for (int i = 0; i &lt; land.size(); i++) { for (int j = 0; j &lt; land[i].size(); j++) { if (land[i][j] == 0) { arr.push_back(BFS(i, j, land)); } else { continue; } } } sort(arr.begin(), arr.end()); return arr; } }; DFS class Solution { public: vector&lt;vector&lt;int&gt;&gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}; struct Node {int x; int y;}; int DFS(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; land) { if (i &lt; 0 || i &gt;= land.size() || j &lt; 0 || j &gt;= land[0].size()) return 0; if (land[i][j] != 0) return 0;//判断是否为鱼塘 land[i][j] = 1;//染色 Node next; int n = 1; for (int m = 0; m &lt; 8; m++) { next.x = i + dirs[m][0]; next.y = j + dirs[m][1]; n += DFS(next.x, next.y, land); } return n; } vector&lt;int&gt; pondSizes(vector&lt;vector&lt;int&gt;&gt;&amp; land) { vector&lt;int&gt; arr; for (int i = 0; i &lt; land.size(); i++) { for (int j = 0; j &lt; land[i].size(); j++) { if (land[i][j] == 0) { arr.push_back(DFS(i, j, land)); } else { continue; } } } sort(arr.begin(), arr.end()); return arr; } }; ","link":"https://sakuratears.cn/post/shui-yu-da-xiao-dfsbfs/"},{"title":"四数之和（双指针）","content":"题目描述： 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 来源：力扣18题（LeetCode） 链接：https://leetcode-cn.com/problems/4sum 题目分析 此题可以用双指针法解决，先用两个for循环i, j遍历前面，两个指针left, right收缩，当nums[i] + nums[j] + nums[left] + nums[right] == target 时，入数组，然后注意一下去重。（三数之和一个for循环，四数之和用两个，五数之和用三个......） 代码题解 vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt; &amp;nums, int target) { vector&lt;vector&lt;int&gt;&gt; re; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; nums.size(); i++) { if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])//去重 continue; for (int j = i + 1; j &lt; nums.size(); j++) { if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1])//去重 continue; int left = j + 1; int right = nums.size() - 1; while (left &lt; right) { if (nums[i] + nums[j] + nums[left] + nums[right] &gt; target) { right--; } else if (nums[i] + nums[j] + nums[left] + nums[right] &lt; target) { left++; } else { re.push_back(vector&lt;int&gt;{nums[i], nums[j], nums[left], nums[right]});//下面两个循环去重 while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) { right--; } while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) { left++; } //找到一个适合的后左右指针收缩 left++; right--; } } } } return re; } ","link":"https://sakuratears.cn/post/si-shu-zhi-he/"},{"title":"PyQt5总结","content":"[TOC] 基本功能 基本操作 from PyQt5.QtWidgets import QApplication, QWidget app = QApplication(sys.argv) 每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数 w = QWidget() QWidget部件是pyqt5所有用户界面对象的基类。他为QWidget提供默认构造函数。 w.resize(250, 250) resize方法调整窗口大小 w.move(300, 300) move方法移动窗口在屏幕的位置 w.setWindowTitle('Simple') 设置窗口标题 w.show() 显示在屏幕上 self.setGeometry(300, 300, 300, 300) 设置窗口位置和大小 图标 self.setWindowIcon(QIcon('路径')) 设置窗口的图标 提示语 from PyQt5.QtWidgets import (QWidget, QToolTip, QPushButton, QApplication) from PyQt5.QtGui import QFont QToolTip.setFont(QFont('SansSerif', 10)) 这种静态的方法设置一个用于显示工具提示的字体。我们使用10px滑体字体 self.setToolTip('This is a &lt;b&gt;QWidget&lt;/b&gt; widget') 创建一个提示，我们称之为settooltip()方法。我们可以使用丰富的文本格式 btn = QPushButton('Button', self) btn.setToolTip('This is a &lt;b&gt;QPushButton&lt;/b&gt; widget') 创建一个PushButton并为他设置一个tooltip btn.resize(btn.sizeHint()) btn.sizeHint()为默认尺寸 关闭窗口 qbtn = QPushButton('Quit', self) qbtn.clicked.connect(QCoreApplication.instance().quit) 消息框 from PyQt5.QtWidgets import QWidget, QMessageBox, QApplication def closeEvent(self, event): reply = QMessageBox.question(self, 'Message', &quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore() 关闭窗口是出发QCloseEvent。我们需要重写closeEvent方法 窗口显示在屏幕的中间 #控制窗口显示在屏幕中心的方法 def center(self): #获得窗口 qr = self.frameGeometry() #获得屏幕中心点 cp = QDesktopWidget().availableGeometry().center() #显示到屏幕中心 qr.moveCenter(cp) self.move(qr.topLeft()) QtGui,QDesktopWidget类提供了用户的桌面信息,包括屏幕大小。 布局管理 绝对定位 lbl1 = QLabel('Zetcode', self) lbl1.move(15, 10) lbl2 = QLabel('tutorials', self) lbl2.move(35, 40) lbl3 = QLabel('for programmers', self) lbl3.move(55, 70) self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Absolute') self.show() 框布局 Boxlayout okButton = QPushButton(&quot;OK&quot;) cancelButton = QPushButton(&quot;Cancel&quot;) hbox = QHBoxLayout() hbox.addStretch(1) hbox.addWidget(okButton) hbox.addWidget(cancelButton) vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) self.setLayout(vbox) self.setGeometry(300, 300, 300, 150) self.setWindowTitle('Buttons') self.show() 我们使用QHBoxLayout和QVBoxLayout，来分别创建横向布局和纵向布局。 hbox = QHBoxLayout() hbox.addStretch(1) hbox.addWidget(okButton) hbox.addWidget(cancelButton) 我们创建一个水平布局和添加一个伸展因子和两个按钮。两个按钮前的伸展增加了一个可伸缩的空间。这将推动他们靠右显示。 vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) 创建一个垂直布局，并添加伸展因子，让水平布局显示在窗口底部 self.setLayout(vbox) 最后,我们设置窗口的布局界面 表格布局 QGridLayout grid = QGridLayout() self.setLayout(grid) names = ['Cls', 'Bck', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i, j) for i in range(5) for j in range(4)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) grid = QGridLayout() self.setLayout(grid) QGridLayout的实例被创建并设置应用程序窗口的布局。 names列表为这些按钮的标签 评论的例子 def initUI(self): title = QLabel('Title') author = QLabel('Author') review = QLabel('Review') titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QTextEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title, 1, 0) grid.addWidget(titleEdit, 1, 1) grid.addWidget(author, 2, 0) grid.addWidget(authorEdit, 2, 1) grid.addWidget(review, 3, 0) grid.addWidget(reviewEdit, 3, 1, 5, 1) self.setLayout(grid) self.setGeometry(300, 300, 350, 300) self.setWindowTitle('Review') self.show() 我们创建一个窗口,其中有三个标签,两个行编辑和一个文本编辑窗口小控件。然后使用QGridLayout完成布局。 grid = QGridLayout() grid.setSpacing(10) 创建一个网格布局和设置组件之间的间距。 grid.addWidget(reviewEdit, 3, 1, 5, 1) 在添加一个小的控件到网格的时候,我们可以提供小部件的行和列跨。在例子中,reviewEdit控件跨度5行。 菜单和工具栏 状态栏 def initUI(self): self.statusBar().showMessage('Ready') self.setGeometry(300, 300, 250, 150) self.setWindowTitle('Statusbar') self.show() 用QMainWindow创建状态栏的小窗口 self.statusBar().showMessage('Ready') QMainWindow类第一次调用statusBar()方法创建一个状态栏。后续调用返回的状态栏对象。showMessage()状态栏上显示一条消息。 菜单栏 菜单栏是常见的窗口应用程序的一部分。(Mac OS将菜单条不同。得到类似的结果,我们可以添加以下行:menubar.setNativeMenuBar(假)。) def initUI(self): exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(qApp.quit) self.statusBar() # 创建一个菜单栏 menubar = self.menuBar() # 添加菜单 fileMenu = menubar.addMenu('&amp;File') # 添加事件 fileMenu.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Menubar') self.show() exitAction = QAction(QIcon('exit.png'), '&amp;Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') QAction可以操作菜单栏,工具栏,或自定义键盘快捷键。上面三行,我们创建一个事件和一个特定的图标和一个“退出”的标签。然后,在定义该操作的快捷键。 第三行创建一个鼠标指针悬停在该菜单项上时的提示。 exitAction.triggered.connect(qApp.quit) 当我们点击菜单的时候，调用qApp.quit,终止应用程序。 工具栏 def initUI(self): exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) self.toolbar = self.addToolBar('Exit') self.toolbar.addAction(exitAction) self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Toolbar') self.show() 在上面的例子中,我们创建一个简单的工具栏。工具栏有有一个按钮,点击关闭窗口。 exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.triggered.connect(qApp.quit) 类似于上面的菜单栏的例子,我们创建一个QAction事件。该事件有一个标签、图标和快捷键。退出窗口的方法 把他们放在一起 import sys from PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplication from PyQt5.QtGui import QIcon class Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon('exit24.png'), 'Exit', self) exitAction.setShortcut('Ctrl+Q') exitAction.setStatusTip('Exit application') exitAction.triggered.connect(self.close) self.statusBar() menubar = self.menuBar() fileMenu = menubar.addMenu('&amp;File') fileMenu.addAction(exitAction) toolbar = self.addToolBar('Exit') toolbar.addAction(exitAction) self.setGeometry(300, 300, 350, 250) self.setWindowTitle('Main window') self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) textEdit = QTextEdit() self.setCentralWidget(textEdit) 我们创建了一个QTextEdit,并把他设置为窗口的布局 ","link":"https://sakuratears.cn/post/pyqt5-zong-jie/"},{"title":"Python实现图片转字符画","content":"首先，安装 Python 图像处理库 pillow（PIL） argparse是 Python 标准库中推荐的命令行解析模块。 具体方法可以查看官方文档是 https://docs.python.org/zh-cn/3/howto/argparse.html # -*- coding=utf-8 -*- from PIL import Image import argparse #命令行输入参数处理 parser = argparse.ArgumentParser() parser.add_argument('file') #输入文件 parser.add_argument('-o', '--output') #输出文件 parser.add_argument('--width', type = int, default = 80) #输出字符画宽 parser.add_argument('--height', type = int, default = 80) #输出字符画高 #获取参数 args = parser.parse_args() IMG = args.file WIDTH = args.width HEIGHT = args.height OUTPUT = args.output ascii_char = list(&quot;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~&lt;&gt;i!lI;:,\\&quot;^`'. &quot;) # 将256灰度映射到70个字符上 def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)] if __name__ == '__main__': # 打开并调整图片的宽和高 im = Image.open(IMG) im = im.resize((WIDTH,HEIGHT), Image.NEAREST) # 初始化输出的字符串 txt = &quot;&quot; # 遍历图片中的每一行 for i in range(HEIGHT): # 遍历该行中的每一列 for j in range(WIDTH): # 将 (j,i) 坐标的 RGB 像素转为字符后添加到 txt 字符串 txt += get_char(*im.getpixel((j,i))) # 遍历完一行后需要增加换行符 txt += '\\n' # 输出到屏幕 print(txt) # 字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open(&quot;output.txt&quot;,'w') as f: f.write(txt) 使用图片https://labfile.oss.aliyuncs.com/courses/370/ascii_dora.png 在命令行使用命令 python ascii.py ascii_dora.png 效果： ","link":"https://sakuratears.cn/post/python-shi-xian-tu-pian-zhuan-zi-fu-hua/"},{"title":"Python解决用pip装第三方库慢的方法","content":"由于政策原因使用pip(pycharm也是)装第三方库有时会很慢有时会失败，有条件的可以使用不可描述方法进行安装或者我们可以使用清华源镜像装库 链接https://mirrors.tuna.tsinghua.edu.cn/help/pypi/ ","link":"https://sakuratears.cn/post/python-jie-jue-yong-pip-zhuang-di-san-fang-ku-man-de-fang-fa/"},{"title":"KMP算法","content":"KMP算法是一种字符串匹配算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。本文将引导您学习KMP算法。 本文转载自知乎“洛谷网校 阮行止” 网址：https://www.zhihu.com/question/21923021/answer/1032665486?utm_source=qq&amp;utm_medium=social&amp;utm_oi=952480495343259648 字符串匹配问题 所谓字符串匹配，是这样一种问题：“字符串 P 是否为字符串 S 的子串？如果是，它出现在 S 的哪些位置？” 其中 S 称为主串；P 称为模式串。下面的图片展示了一个例子。 主串是莎翁那句著名的 “to be or not to be”，这里删去了空格。“no” 这个模式串的匹配结果是“出现了一次，从S[6]开始”；“ob”这个模式串的匹配结果是“出现了两次，分别从s[1]、s[10]开始”。按惯例，主串和模式串都以0开始编号。 字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。 我们先从最朴素的Brute-Force算法开始讲起。 Brute-Force 顾名思义，Brute-Force是一个纯暴力算法。说句题外话，我怀疑，“暴力”一词在算法领域表示“穷举、极低效率的实现”，可能就是源于这个英文词。 首先，我们应该如何实现两个字符串 A,B 的比较？所谓字符串比较，就是问“两个字符串是否相等”。最朴素的思想，就是从前往后逐字符比较，一旦遇到不相同的字符，就返回False；如果两个字符串都结束了，仍然没有出现不对应的字符，则返回True。实现如下： 既然我们可以知道“两个字符串是否相等”，那么最朴素的字符串匹配算法 Brute-Force 就呼之欲出了—— · 枚举 i = 0, 1, 2 ... , len(S)-len(P) · 将 S[i : i+len(P)] 与 P 作比较。如果一致，则找到了一个匹配。 现在我们来模拟 Brute-Force 算法，对主串 “AAAAAABC” 和模式串 “AAAB” 做匹配： 这是一个清晰明了的算法，实现也极其简单。下面给出Python和C++的实现： 我们成功实现了 Brute-Force 算法。现在，我们需要对它的时间复杂度做一点讨论。按照惯例，记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。 考虑“字符串比较”这个小任务的复杂度。最坏情况发生在：两个字符串唯一的差别在最后一个字符。这种情况下，字符串比较必须走完整个字符串，才能给出结果，因此复杂度是 O(len) 的。 由此，不难想到 Brute-Force 算法所面对的最坏情况：主串形如“AAAAAAAAAAA...B”，而模式串形如“AAAAA...B”。每次字符串比较都需要付出 |P| 次字符比较的代价，总共需要比较 |S| - |P| + 1次，因此总时间复杂度是 . 考虑到主串一般比模式串长很多，故 Brute-Force 的复杂度是 ，也就是 O(nm)的。这太慢了！ Brute-Force的改进思路 经过刚刚的分析，您已经看到，Brute-Force 慢得像爬一样。它最坏的情况如下图所示： 我们很难降低字符串比较的复杂度（因为比较两个字符串，真的只能逐个比较字符）。因此，我们考虑降低比较的趟数。如果比较的趟数能降到足够低，那么总的复杂度也将会下降很多。 要优化一个算法，首先要回答的问题是“我手上有什么信息？” 我们手上的信息是否足够、是否有效，决定了我们能把算法优化到何种程度。请记住：尽可能利用残余的信息，是KMP算法的思想所在。 在 Brute-Force 中，如果从 S[i] 开始的那一趟比较失败了，算法会直接开始尝试从 S[i+1] 开始比较。这种行为，属于典型的“没有从之前的错误中学到东西”。我们应当注意到，一次失败的匹配，会给我们提供宝贵的信息——如果 S[i : i+len(P)] 与 P 的匹配是在第 r 个位置失败的，那么从 S[i] 开始的 (r-1) 个连续字符，一定与 P 的前 (r-1) 个字符一模一样！ 需要实现的任务是“字符串匹配”，而每一次失败都会给我们换来一些信息——能告诉我们，主串的某一个子串等于模式串的某一个前缀。但是这又有什么用呢？ 跳过不可能成功的字符串比较 有些趟字符串比较是有可能会成功的；有些则毫无可能。我们刚刚提到过，优化 Brute-Force 的路线是“尽量减少比较的趟数”，而如果我们跳过那些绝不可能成功的字符串比较，则可以希望复杂度降低到能接受的范围。 那么，哪些字符串比较是不可能成功的？来看一个例子。已知信息如下： 模式串 P = &quot;abcabd&quot;. 和主串从S[0]开始匹配时，在 P[5] 处失配。 首先，利用上一节的结论。既然是在 P[5] 失配的，那么说明 S[0:5] 等于 P[0:5]，即&quot;abcab&quot;. 现在我们来考虑：从 S[1]、S[2]、S[3] 开始的匹配尝试，有没有可能成功？ 从 S[1] 开始肯定没办法成功，因为 S[1] = P[1] = 'b'，和 P[0] 并不相等。从 S[2] 开始也是没戏的，因为 S[2] = P[2] = 'c'，并不等于P[0]. 但是从 S[3] 开始是有可能成功的——至少按照已知的信息，我们推不出矛盾。 带着“跳过不可能成功的尝试”的思想，我们来看next数组。 next数组 next数组是对于模式串而言的。P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i] 这一个子串，使得 前k个字符恰等于后k个字符 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。 上图给出了一个例子。P=&quot;abcabd&quot;时，next[4]=2，这是因为P[0] ~ P[4] 这个子串是&quot;abcab&quot;，前两个字符与后两个字符相等，因此next[4]取2. 而next[5]=0，是因为&quot;abcabd&quot;找不到前缀与后缀相同，因此只能取0. 如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是每次失配之后，移很多位，跳过那些不可能匹配成功的位置。但是该如何确定要移多少位呢？ 在 S[0] 尝试匹配，失配于 S[3] &lt;=&gt; P[3] 之后，我们直接把模式串往右移了两位，让 S[3] 对准 P[1]. 接着继续匹配，失配于 S[8] &lt;=&gt; P[6], 接下来我们把 P 往右平移了三位，把 S[8] 对准 P[3]. 此后继续匹配直到成功。 我们应该如何移动这把标尺？很明显，如图中蓝色箭头所示，旧的后缀要与新的前缀一致（如果不一致，那就肯定没法匹配上了）！ 回忆next数组的性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，前next[r-1]个字符恰好和后next[r-1]个字符相等——也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去！ 您可以验证一下上面的匹配例子：P[3]失配后，把P[next[3-1]]也就是P[1]对准了主串刚刚失配的那一位；P[6]失配后，把P[next[6-1]]也就是P[3]对准了主串刚刚失配的那一位。 如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，其长度为next[右端]. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，next数组为我们如何移动标尺提供了依据。接下来，我们实现这个优化的算法。 利用next数组进行匹配 了解了利用next数组加速字符串匹配的原理，我们接下来代码实现之。分为两个部分：建立next数组、利用next数组进行匹配。 首先是建立next数组。我们暂且用最朴素的做法，以后再回来优化： 如上图代码所示，直接根据next数组的定义来建立next数组。不难发现它的复杂度是 的。 接下来，实现利用next数组加速字符串匹配。代码如下： 如何分析这个字符串匹配的复杂度呢？乍一看，pos值可能不停地变成next[pos-1]，代价会很高；但我们使用摊还分析，显然pos值一共顶多自增len(S)次，因此pos值减少的次数不会高于len(S)次。由此，复杂度是可以接受的，不难分析出整个匹配算法的时间复杂度：O(n+m). 快速求next数组 终于来到了我们最后一个问题——如何快速构建next数组。 首先说一句：快速构建next数组，是KMP算法的精髓所在，核心思想是“P自己与自己做匹配”。 为什么这样说呢？回顾next数组的完整定义： 定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。 next[x] 定义为： P[0]~P[x] 这一段字符串，使得k-前缀恰等于k-后缀的最大的k. 这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], ... next[x-1]均已知，那么如何求出 next[x] 呢？ 来分情况讨论。首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1. 图示如下。 刚刚解决了 P[x] = P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？ 如图。长度为 now 的子串 A 和子串 B 是 P[0]~P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该缩短这个now，把它改成小一点的值，再来试试 P[x] 是否等于 P[now]. now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]~P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 A的k-前缀等于B的k-后缀 的最大的k. 您应该已经注意到了一个非常强的性质——串A和串B是相同的！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！ 来看上面的例子。当P[now]与P[x]不相等的时候，我们需要缩小now——把now变成next[now-1]，直到P[now]=P[x]为止。P[now]=P[x]时，就可以直接向右扩展了。 代码实现如下： 应用摊还分析，不难证明构建next数组的时间复杂度是O(m)的。至此，我们以O(n+m)的时间复杂度，实现了构建next数组、利用next数组进行字符串匹配。 以上就是KMP算法。它于1977年被提出，全称 Knuth–Morris–Pratt 算法。让我们记住前辈们的名字：Donald Knuth(K), James H. Morris(M), Vaughan Pratt(P). 作者：阮行止 链接：https://www.zhihu.com/question/21923021/answer/1032665486 来源：知乎 ","link":"https://sakuratears.cn/post/kmp-suan-fa/"},{"title":"希尔排序","content":"为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。 对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要№1次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。 实现希尔排序的一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插人排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插人排序但使用不同增量的过程。 希尔排序为插入排序高级版，先把几个部分的数组用插入排序排好，然后再把这几个分散数组排序成有序数组。 确定一个增量h（h可以是数组总长/3 or /2），每次循环完增量变小直到为1，每次把分散的数组整合成一个大的有序数组，直到增量为1时，整个数组排序完成。 void shellsort(int a[], int m) { int h = m / 2; //确定增量h for (h; h &gt;= 1; h /= 2) //每次增量变小 { for (int i = h; i &lt; m; i += h) { for (int j = i; j &gt;= 0 &amp;&amp; j - h &gt;= 0 &amp;&amp; a[j] &lt; a[j - h]; j -= h) { int temp = a[j]; a[j] = a[j - h]; a[j - h] = temp; } } } for (int i = 0; i &lt; m; i++) { cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; } } ","link":"https://sakuratears.cn/post/xi-er-pai-xu/"},{"title":"快速排序","content":"快速排序的特点是他是原地排序（只需要一个很小的辅助栈），且长度为N的数组时间复杂度为NlgN。 快速排序是一种分治的算法，他将一个数组分成两个数组，将两部分独立排序，在快排中切分的位置取决于数组的内容。 取首元素为切分元素，比切分元素小的放到左边，比切分元素大的放到右边，再把两个数组切分，最后有序 void qsort(int a[], int lo, int hi) { if (lo &gt;= hi) return; int i, j, m, temp, mid; m = a[lo]; //切分元素 i = lo; //下面循环时i和j就会先自增/自减1再判断，所以i为头元素，j为尾元素 - 1 j = hi + 1; while (true) { while (a[++i] &lt; m) { if (i == hi)//直到循环到右边界也没有找到比切分元素大的元素 break; } while (a[--j] &gt; m) { if (j == lo)//直到循环到左边界也没有找到比切分元素小的元素 break; } if (i &gt;= j)//当i的位置在j的右边，a[i] &gt; a[j],不可以交换 break; int temp = a[i]; a[i] = a[j]; a[j] = temp; } temp = a[lo]; a[lo] = a[j]; a[j] = temp; mid = j; qsort(a, lo, mid - 1); qsort(a, mid + 1, hi); } ","link":"https://sakuratears.cn/post/kuai-su-pai-xu/"},{"title":"归并排序","content":"归并排序将两个有序的排列归并为一个有序的排列。 归并算法都基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来：你将会看到，归并排序最 吸引人的性质是它能够保证将任意长度为，的数组排序所需时间和，成正比；它的主要缺点则是它所需的额外空间。简单的归并排序如图所示。 原地归并 先创建一个数组aux将a的元素全部赋给aux。然后开始将两个有序的数组归并成一个有序的数组。 将a[lo, mid]和a[mid + 1, hi]两个有序数组归并为一个有序数组 void merge(int a[], int lo, int mid, int hi) { int i, j; i = lo; j = mid + 1; int aux[hi + 1]; for (int k = lo; k &lt;= hi; k++) { aux[k] = a[k]; } for (int k = lo; k &lt;= hi; k++) { if (i &gt; mid) { a[k] = aux[j++]; } else if (j &gt; hi) { a[k] = aux[i++]; } else if (aux[j] &lt; aux[i]) { a[k] = aux[j++]; } else { a[k] = aux[i++]; } } } 当左边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑左边元素，直接把右边剩余元素全部赋值给a即可 if(i &gt; mid) 当右边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑右边元素，直接把左边剩余元素全部赋值给a即可 if(j &gt; hi) 如果右边当前元素小于左边当前元素则将右边当前元素赋给a,(aux[j] &lt; aux[i]) 右边当前元素大于等于左边当前元素，最后一个else 自上向下 自顶向下归并将一个数组先中间拆分，再把拆分的数组拆分，直到只有一个元素的数组，然后将每两个数组就行归并。最后归并为一个有序数组。 void gbsort(int a[], int lo, int hi) { if (hi &lt;= lo) { return; } int mid; mid = lo + (hi - lo) / 2; gbsort(a, lo, mid); gbsort(a, mid + 1, hi); merge(a, lo, mid, hi); } 自底向上 自底向上归并第一次每两个元素的数组归并，然后每四个，八个......归并，最终归并成一个有序数组 void gbsort(int a[], int lo, int hi) { int n = hi + 1; //n为数组长度 for (int i = 1; i &lt; n; i += i)//每次循环完了归并前一次翻倍的数组元素个数 { for (int j = 0; j &lt; n - i; j += i * 2) { if (j + i * 2 - 1 &lt; hi) { merge(a, j, j + i - 1, j + i * 2 - 1); } else { merge(a, j, j + i - 1, hi); } } } } ","link":"https://sakuratears.cn/post/gui-bing-pai-xu/"},{"title":"负进制","content":"题目描述 输入格式 输入的每行有两个输入数据。 第一个是十进制数 n。 第二个是负进制数的基数 −R。 输出格式 输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。 输入输出样例 输入 3000 -2 输出 30000=11011010101110000(base-2) 输入 -20000 -2 输出 -20000=1111011000100000(base-2) 输入 28800 -16 输出 28800=19180(base-16) 输入 -25000 -16 输出 -25000=7FB8(base-16) 说明 【数据范围】 对于 100% 的数据,−20≤R≤−2,∣n∣≤37336。 NOIp2000提高组第一题 题解： 正常情况下-7 % -2 商4 余1 但是C语言（或者说所有语言）这里是商3 余-1 这就很明显了，只需要把商+1，被除数+1就和正常计算情况一样了 代码为： #include &lt;stdio.h&gt; void zh(int a, int b) { if (a == 0) { return; } int m = a % b; if (m &lt; 0) { m -= b; a += b; } if (m &gt; 9) { m = 'A' + m - 10; } else m += '0'; zh(a / b, b); printf(&quot;%c&quot;, m); } int main() { int a, b; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); printf(&quot;%d=&quot;, a); zh(a, b); printf(&quot;(base%d)&quot;, b); return 0; } ","link":"https://sakuratears.cn/post/fu-jin-zhi/"},{"title":"带备忘录和dp的递归","content":"备忘录算法 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int helper(vector&lt;int&gt; &amp;m, int n); int fib(int n); int fib(int n) { if(n &lt; 1) { return 0; } vector&lt;int&gt; m(n + 1, 0); return helper(m, n); } int helper(vector&lt;int&gt;&amp;m, int n) { if(n == 1 || n == 2) { return 1; } if (m[n] != 0) { return m[n]; } m[n] = helper(m, n - 1) + helper(m, n - 2); return m[n]; } int main() { int n; cin &gt;&gt; n; cout &lt;&lt; fib(n); return 0; } dp数组迭代 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int fib(int n); int fib(int n) { if(n &lt; 1) { return 0; } vector&lt;int&gt; dp(n + 1, 0); dp[1] = dp[2] = 1; for (int i = 3; i &lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } int main() { int n; cin &gt;&gt; n; cout &lt;&lt; fib(n); return 0; } 空间优化 #include &lt;iostream&gt; using namespace std; int fib(int n); int fib(int n) { if (n == 1 || n == 2) { return 1; } int a, b, sum; a = b = 1; for (int i = 3; i &lt;= n; i++) { sum = a + b; a = b; b = sum; } return sum; } int main() { int n; cin &gt;&gt; n; cout &lt;&lt; fib(n); return 0; } ","link":"https://sakuratears.cn/post/dai-bei-wang-lu-he-dp-de-di-gui/"},{"title":"凑零钱问题","content":"#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;limits.h&gt; #define INT_MAX 2147483647; using namespace std; int coinchange(int coin, vector&lt;int&gt; &amp;coins, int amount, vector&lt;int&gt; &amp;bwl) { if (amount &lt; 0) return -1; if (amount == 0) return 0; if (bwl[amount] != 0) return bwl[amount]; int res, i, j, dp = 0, m; m = INT_MAX; j = 0; res = INT_MAX; while (j &lt; coin) { i = coins[j]; dp = coinchange(coin, coins, amount - i, bwl); if (dp == -1) { j++; continue; } if (res &gt; 1 + dp) { res = 1 + dp; } j++; } if (res != m) { bwl[amount] = res; } else { bwl[amount] = -1; } return bwl[amount]; } int coinChange(vector&lt;int&gt;&amp; coins, int amount) { int coin = coins.size(); vector&lt;int&gt; bwl(amount + 1, 0); return coinchange(coin, coins, amount, bwl); } int main() { vector&lt;int&gt; coins; int a, n, i = 0, amount, m; cin &gt;&gt; n; coins.clear(); while (i &lt; n) { cin &gt;&gt; a; coins.push_back(a); i++; } cin &gt;&gt; amount; m = coinChange(coins, amount); cout &lt;&lt; m; return 0; } #include &lt;iostream&gt; #include &lt;limits.h&gt; #include &lt;vector&gt; #define INT_MAX 2147483647; using namespace std; int coinChange(vector&lt;int&gt; &amp;coins, int amount) { vector&lt;int&gt; dp(amount + 1, amount + 1); dp[0] = 0; int i, j; for (i = 0; i &lt; dp.size(); i++) { for (j = 0; j &lt; coins.size(); j++) { if (i &lt; coins[j]) { continue; } if (dp[i] &gt; dp[i - coins[j]]) { dp[i] = 1 + dp[i - coins[j]]; } } } return (dp[amount] == amount + 1) ? -1 : dp[amount]; } int main() { vector&lt;int&gt; coins; int a, n, i = 0, amount, m; cin &gt;&gt; n; coins.clear(); while (i &lt; n) { cin &gt;&gt; a; coins.push_back(a); i++; } cin &gt;&gt; amount; m = coinChange(coins, amount); cout &lt;&lt; m; return 0; } ","link":"https://sakuratears.cn/post/cou-ling-qian-wen-ti/"},{"title":"C语言实现链表基本操作（交换第i个和第j个节点）","content":"C语言实现链表基本操作（交换第i个和第j个节点） 当i或者j为1时，需要让链表的表头指向j。 代码为 /*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/ if (i == 1) { t1 = *L; for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == j) { *L = temp-&gt;Next; t2 = temp-&gt;Next-&gt;Next; temp-&gt;Next-&gt;Next = t1-&gt;Next; t1-&gt;Next = t2; temp-&gt;Next = t1; } } } 当i和j都不为1时。 节点相邻与不相邻也是不一样的。 不相邻的情况下就是让i前面的节点指向j，然后让j前面的节点指向i。如果两个节点相邻（假设i &lt; j）j前面的节点就是i，j前面的节点指向i就是指向了自己，所以要分开写。 不相邻节点时： 代码为： if ((i - j) != 1 &amp;&amp; (j- i) != 1) {//非相邻结点之间交换 for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == i) { t1 = temp; } if (m + 1 == j) { t2 = temp; } } t5 = t1-&gt;Next-&gt;Next; t3 = t1-&gt;Next; t4 = t2-&gt;Next; t1-&gt;Next = t4; t2-&gt;Next = t3; t3-&gt;Next = t4-&gt;Next; t4-&gt;Next = t5; } 最后一种情况，两个节点相邻： 代码为： for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == i) { t1 = temp; } if (m == j) { t2 = temp; } } temp = t2-&gt;Next; t3 = t1-&gt;Next; t1-&gt;Next = t2; t3-&gt;Next = temp; t2-&gt;Next = t3; } 全部代码： #include &lt;stdio.h&gt; #include &lt;malloc.h&gt; typedef struct node { int Score; struct node * Next; }Node, * List; void Insert(List *L, Node e) { List temp = *L; List n = (List)malloc(sizeof(Node)); n-&gt;Score = e.Score; if (temp == NULL) { *L = n; } else { while (temp-&gt;Next != NULL) { temp = temp-&gt;Next; } temp-&gt;Next = n; } n-&gt;Next = NULL; } void Swap(List * L, int i, int j) { List temp = *L; List t1; List t2; List t3; List t4; List t5; int m; /*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/ if (i == 1) { t1 = *L; for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == j) { *L = temp-&gt;Next; t2 = temp-&gt;Next-&gt;Next; temp-&gt;Next-&gt;Next = t1-&gt;Next; t1-&gt;Next = t2; temp-&gt;Next = t1; } } } if (j == 1) { t1 = *L; for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == i) { *L = temp-&gt;Next; t2 = temp-&gt;Next-&gt;Next; temp-&gt;Next-&gt;Next = t1-&gt;Next; t1-&gt;Next = t2; temp-&gt;Next = t1; } } } /*相邻节点之间交换和非相邻结点之间交换不一样*/ else { if ((i - j) != 1 &amp;&amp; (j- i) != 1) {//非相邻结点之间交换 for (m = 1; temp-&gt;Next != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == i) { t1 = temp; } if (m + 1 == j) { t2 = temp; } } t5 = t1-&gt;Next-&gt;Next; t3 = t1-&gt;Next; t4 = t2-&gt;Next; t1-&gt;Next = t4; t2-&gt;Next = t3; t3-&gt;Next = t4-&gt;Next; t4-&gt;Next = t5; } else if (i &lt; j) {//相邻节点之间交换 for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == i) { t1 = temp; } if (m == j) { t2 = temp; } } temp = t2-&gt;Next; t3 = t1-&gt;Next; t1-&gt;Next = t2; t3-&gt;Next = temp; t2-&gt;Next = t3; } else if (i &gt; j) { for (m = 1; temp != NULL; m++, temp = temp-&gt;Next) { if (m + 1 == j) { t1 = temp; } if (m == i) { t2 = temp; } } temp = t2-&gt;Next; t3 = t1-&gt;Next; t1-&gt;Next = t2; t3-&gt;Next = temp; t2-&gt;Next = t3; } } } void printflist(List list) { List temp; for (temp = list; temp != NULL; temp = temp-&gt;Next) { printf(&quot;%d\\n&quot;, temp-&gt;Score); } } void freelist(List *list) { List temp = *list, del; while (temp != NULL) { del = temp; temp = temp-&gt;Next; free(del); } } int main() { List list = NULL; Node n1, n2, n3, n4, e;//定义5个节点 e.Score = 5; n1.Score = 1; n2.Score = 2; n3.Score = 3; n4.Score = 4; Insert(&amp;list, n1); Insert(&amp;list, n2); Insert(&amp;list, n3); Insert(&amp;list, n4); Insert(&amp;list, e); // dellist(&amp;list, 8); Swap(&amp;list, 5, 4); printflist(list); freelist(&amp;list); return 0; } ","link":"https://sakuratears.cn/post/c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian/"},{"title":"C语言链表基本操作（头插法及其逆置）","content":"#include &lt;stdio.h&gt; #include &lt;malloc.h&gt; typedef struct Node { char data; struct Node *next; }SN; SN * create(int n) { int i; SN *h,*p; h = NULL; for(i = 0; i&lt;n; i++) { p=(SN*)malloc(sizeof(SN)); printf(&quot;请输入第%d个字符：&quot;,i+1); p-&gt;data = getchar(); fflush(stdin); p-&gt;next = h; h=p; } return h; } SN * def(SN * h) { SN * n1, *n2; n1 = h; n2 = NULL; while(n1 != NULL) { SN *temp; temp = n1; n1 = n1-&gt;next; temp-&gt;next = n2; n2 = temp; } h = n2; return h; } void visit(SN * h) { while(h != NULL) { printf(&quot;%c&quot;, h-&gt;data); h = h-&gt;next; } printf(&quot;\\n&quot;); } void freelist(SN *h) { SN *temp = h; SN *del; while (temp != NULL) { del = temp; temp = temp-&gt;next; free(del); } } int main() { int n; SN *h; printf(&quot;请输入字符个数：\\n&quot;); scanf(&quot;%d&quot;, &amp;n); fflush(stdin); h = create(n); printf(&quot;链表创建成功，对其遍历\\n&quot;); visit(h); printf(&quot;链表逆置成功，对其遍历\\n&quot;); h = def(h); visit(h); freelist(h); return 0; } ","link":"https://sakuratears.cn/post/c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://sakuratears.cn/post/hello-gridea/"}]}