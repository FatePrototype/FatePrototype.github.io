<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="name=&#34;baidu-site-verification&#34; content=&#34;code-A1cWhYOwgT&#34; ">
<meta name="description" content="努力不一定成功，但不努力一定很轻松">
<meta name="theme-color" content="#000">
<title>SakuraTears</title>
<link rel="shortcut icon" href="/favicon.ico?v=1608375355387">
<link rel="stylesheet" href="/media/css/mist.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/an-old-hope.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>






</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="mist">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="">
              <span class="logo-line-before">
                <i class=""></i>
              </span>
              <span class="main-title">SakuraTears</span>
              <span class="logo-line-after">
                <i class=""></i>
              </span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://sakuratears.cn/post/ji-lu-xue-xi-de-ri-zi/" target="_self">
                  <i class="fa fa-globe"></i> 生活
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://sakuratears.cn/post/about/" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout bg-color mist">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">SakuraTears</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">一只没有感情的菜鸡</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">47</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">24</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">24</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201023220702.png">
              <i class="fa fa-qq" title="QQ"></i>
            </a>
          
            <a href="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201023220242.jpg">
              <i class="fa fa-wechat" title="WeChat"></i>
            </a>
          
            <a href="https://github.com/ZSakuraTears">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
      </div>
    </div>
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'mist';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          数据结构
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://sakuratears.cn/post/c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              10/23
              <small>C语言实现链表基本操作（交换第i个和第j个节点）</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      <a href="https://sakuratears.cn/post/c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              10/23
              <small>C语言链表基本操作（头插法及其逆置）</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">ZYZ</a>
    </div>
  </footer>
  
  
  <div class="drawer-box left" id="drawer_box">
    <span class="muse-line muse-line-first"></span>
    <span class="muse-line muse-line-middle"></span>
    <span class="muse-line muse-line-last"></span>
  </div>
  
  <div class="mist back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
  </div>
  
  
  
  <div class="bg-img">
    <img src="https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/vKXn1oIoZi.jpg" />
  </div>
  
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 1210px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'rem'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
  
  <script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://player.lmih.cn/player/js/player.js" id="myhk" key="demo" m="1"></script>


  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "别走呀0.0";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = '';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.appendChild(aelem);
  })
</script>
  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/xuan-zhuan-tu-xiang-shu-zu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个 n × n 的二维矩阵表示一个图像。&lt;br&gt;
将图像顺时针旋转 90 度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;给定 matrix =&lt;br&gt;
[&lt;br&gt;
[1,2,3],&lt;br&gt;
[4,5,6],&lt;br&gt;
[7,8,9]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;
[&lt;br&gt;
[7,4,1],&lt;br&gt;
[8,5,2],&lt;br&gt;
[9,6,3]&lt;br&gt;
]&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;给定 matrix =&lt;br&gt;
[&lt;br&gt;
[ 5, 1, 9,11],&lt;br&gt;
[ 2, 4, 8,10],&lt;br&gt;
[13, 3, 6, 7],&lt;br&gt;
[15,14,12,16]&lt;br&gt;
],&lt;/p&gt;
&lt;p&gt;原地旋转输入矩阵，使其变为:&lt;br&gt;
[&lt;br&gt;
[15,13, 2, 5],&lt;br&gt;
[14, 3, 4, 1],&lt;br&gt;
[12, 6, 8, 9],&lt;br&gt;
[16, 7,10,11]&lt;br&gt;
]&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/rotate-image&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;题目要求不要用辅助数组，此题解用了辅助数组&lt;/strong&gt;&lt;br&gt;
直接用一个辅助数组arr，arr的列是matrix的行，用两个循环即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr = matrix;
        for (int i = 0, j = matrix.size() - 1; i &amp;lt; matrix.size(); i++, j--) {
            for (int m = 0; m &amp;lt; matrix[i].size(); m++) {
                arr[m][j] = matrix[i][m];
            }
        }
        matrix = arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">旋转图像(数组)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/markdown-yu-fa/"" data-c="
          &lt;h1 id=&#34;生成目录&#34;&gt;生成目录&lt;/h1&gt;
&lt;p&gt;在markdown顶部输入&lt;code&gt;[TOC]&lt;/code&gt;即可生成目录&lt;/p&gt;
&lt;h1 id=&#34;markdown标题&#34;&gt;Markdown标题&lt;/h1&gt;
&lt;p&gt;Markdown标题有两种&lt;/p&gt;
&lt;h2 id=&#34;第一种标题&#34;&gt;第一种标题&lt;/h2&gt;
&lt;p&gt;使用=和-标记&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;我展示的是一级标题
=================

我展示的是二级标题
-----------------
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二种标题&#34;&gt;第二种标题&lt;/h2&gt;
&lt;p&gt;使用#标记&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;markdown-段落格式&#34;&gt;Markdown 段落格式&lt;/h1&gt;
&lt;h2 id=&#34;markdown-段落&#34;&gt;Markdown 段落&lt;/h2&gt;
&lt;p&gt;Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。或者&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字体&#34;&gt;字体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;*斜体文本*
_斜体文本_
**粗体文本**
__粗体文本__
***粗斜体文本***
___粗斜体文本___
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;斜体文本&lt;/em&gt;&lt;br&gt;
&lt;em&gt;斜体文本&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;粗斜体文本&lt;/strong&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;&lt;strong&gt;粗斜体文本&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;分隔线&#34;&gt;分隔线&lt;/h2&gt;
&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;***

* * *

*****

- - -

----------
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;删除线&#34;&gt;删除线&lt;/h2&gt;
&lt;p&gt;如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 &lt;code&gt;~~&lt;/code&gt; 即可，实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;RUNOOB.COM
GOOGLE.COM
~~BAIDU.COM~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RUNOOB.COM&lt;br&gt;
GOOGLE.COM&lt;br&gt;
&lt;s&gt;BAIDU.COM&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;下划线&#34;&gt;下划线&lt;/h2&gt;
&lt;p&gt;下划线可以通过 HTML 的&lt;code&gt;&amp;lt;u&amp;gt;&lt;/code&gt; 标签来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;u&amp;gt;带下划线文本&amp;lt;/u&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;带下划线文本&lt;/u&gt;&lt;/p&gt;
&lt;h2 id=&#34;脚注&#34;&gt;脚注&lt;/h2&gt;
&lt;p&gt;脚注是对文本的补充说明。&lt;/p&gt;
&lt;p&gt;Markdown 脚注的格式如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[^要注明的文本]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下实例演示了脚注的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;创建脚注格式类似这样 [^RUNOOB]。

[^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建脚注格式类似这样 &lt;sup class=&#34;footnote-ref&#34;&gt;&lt;a href=&#34;#fn1&#34; id=&#34;fnref1&#34;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h1 id=&#34;markdown-列表&#34;&gt;Markdown 列表&lt;/h1&gt;
&lt;h2 id=&#34;无序列表&#34;&gt;无序列表&lt;/h2&gt;
&lt;p&gt;Markdown 支持有序列表和无序列表。&lt;br&gt;
无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* 第一项
* 第二项
* 第三项

+ 第一项
+ 第二项
+ 第三项

- 第一项
- 第二项
- 第三项
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有序列表&#34;&gt;有序列表&lt;/h2&gt;
&lt;p&gt;有序列表使用数字并加上 . 号来表示，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. 第一项
2. 第二项
3. 第三项
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h2&gt;
&lt;p&gt;列表嵌套只需在子列表中的选项前面添加四个空格即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
    - 第二项嵌套的第二个元素
   
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第一项：
&lt;ul&gt;
&lt;li&gt;第一项嵌套的第一个元素&lt;/li&gt;
&lt;li&gt;第一项嵌套的第二个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二项：
&lt;ul&gt;
&lt;li&gt;第二项嵌套的第一个元素&lt;/li&gt;
&lt;li&gt;第二项嵌套的第二个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;markdown-区块&#34;&gt;Markdown 区块&lt;/h1&gt;
&lt;p&gt;Markdown 区块引用是在段落开头使用 &amp;gt; 符号 ，然后后面紧跟一个空格符号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; 区块引用
&amp;gt; 菜鸟教程
&amp;gt; 学的不仅是技术更是梦想
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;区块引用&lt;br&gt;
菜鸟教程&lt;br&gt;
学的不仅是技术更是梦想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外区块是可以嵌套的，一个 &amp;gt; 符号是最外层，两个 &amp;gt; 符号是第一层嵌套，以此类推：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; 最外层
&amp;gt; &amp;gt; 第一层嵌套
&amp;gt; &amp;gt; &amp;gt; 第二层嵌套
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;最外层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一层嵌套&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二层嵌套&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;区块中使用列表&#34;&gt;区块中使用列表&lt;/h2&gt;
&lt;p&gt;区块中使用列表实例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; 区块中使用列表
&amp;gt; 1. 第一项
&amp;gt; 2. 第二项
&amp;gt; + 第一项
&amp;gt; + 第二项
&amp;gt; + 第三项
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;区块中使用列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;li&gt;第三项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;列表中使用区块&#34;&gt;列表中使用区块&lt;/h2&gt;
&lt;p&gt;如果要在列表项目内放进区块，那么就需要在 &amp;gt; 前添加四个空格的缩进。&lt;br&gt;
区块中使用列表实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* 第一项
    &amp;gt; 菜鸟教程
    &amp;gt; 学的不仅是技术更是梦想
* 第二项
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一项
&lt;blockquote&gt;
&lt;p&gt;菜鸟教程&lt;br&gt;
学的不仅是技术更是梦想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;markdown-代码&#34;&gt;Markdown 代码&lt;/h1&gt;
&lt;p&gt;如果是段落上的一个函数或片段的代码可以用反引号把它包起来&lt;code&gt;（`）&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;`printf()` 函数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printf()&lt;/code&gt; 函数&lt;/p&gt;
&lt;h2 id=&#34;代码区块&#34;&gt;代码区块&lt;/h2&gt;
&lt;p&gt;代码区块使用 4 个空格或者一个制表符（Tab 键）。&lt;/p&gt;
&lt;p&gt;实例如下：&lt;br&gt;
printf(&amp;quot;hello&amp;quot;)&lt;/p&gt;
&lt;p&gt;你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;​```javascript
$(document).ready(function () {
    alert(&#39;hello word!&#39;);
});
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$(document).ready(function () {
    alert(&#39;hello word!&#39;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;markdown-链接&#34;&gt;Markdown 链接&lt;/h1&gt;
&lt;p&gt;链接使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[链接名称](链接地址)

或者

&amp;lt;链接地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://sakuratears.cn&#34;&gt;blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sakuratears.cn&#34;&gt;https://sakuratears.cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;高级链接&#34;&gt;高级链接&lt;/h2&gt;
&lt;p&gt;我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;这个链接用 1 作为网址变量 [Google][1]
这个链接用 sakura 作为网址变量 [sakura][sakura]
然后在文档的结尾为变量赋值（网址）

  [1]: http://www.google.com/
  [sakura]: https://sakuratears.cn/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个链接用 1 作为网址变量 &lt;a href=&#34;http://www.google.com/&#34;&gt;Google&lt;/a&gt;&lt;br&gt;
这个链接用 sakura 作为网址变量 &lt;a href=&#34;https://sakuratears.cn/&#34;&gt;sakura&lt;/a&gt;&lt;br&gt;
然后在文档的结尾为变量赋值（网址）&lt;/p&gt;
&lt;h1 id=&#34;markdown-图片&#34;&gt;Markdown 图片&lt;/h1&gt;
&lt;p&gt;Markdown 图片语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;![alt 属性文本](图片地址)

![alt 属性文本](图片地址 &amp;quot;可选标题&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://static.runoob.com/images/runoob-logo.png&#34; alt=&#34;RUNOOB 图标&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;http://static.runoob.com/images/runoob-logo.png&#34; alt=&#34;RUNOOB 图标&#34; title=&#34;RUNOOB&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当然，你也可以像网址那样对图片网址使用变量:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;这个链接用 1 作为网址变量 [RUNOOB][1].
然后在文档的结尾为变量赋值（网址）

[1]: http://static.runoob.com/images/runoob-logo.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个链接用 1 作为网址变量 &lt;a href=&#34;http://www.google.com/&#34;&gt;RUNOOB&lt;/a&gt;.&lt;br&gt;
然后在文档的结尾为变量赋值（网址）&lt;/p&gt;
&lt;p&gt;Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;img src=&amp;quot;http://static.runoob.com/images/runoob-logo.png&amp;quot; width=&amp;quot;50%&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;http://static.runoob.com/images/runoob-logo.png&#34; width=&#34;50%&#34;&gt;
&lt;h1 id=&#34;markdown-表格&#34;&gt;Markdown 表格&lt;/h1&gt;
&lt;p&gt;Markdown 制作表格使用 &lt;code&gt;|&lt;/code&gt;来分隔不同的单元格，使用&lt;code&gt;-&lt;/code&gt; 来分隔表头和其他行。&lt;br&gt;
语法格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对齐方式&lt;/p&gt;
&lt;p&gt;我们可以设置表格的对齐方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-:&lt;/code&gt; 设置内容和标题栏居右对齐。&lt;br&gt;
&lt;code&gt;:-&lt;/code&gt;设置内容和标题栏居左对齐。&lt;br&gt;
&lt;code&gt;:-:&lt;/code&gt;设置内容和标题栏居中对齐。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;左对齐&lt;/th&gt;
&lt;th style=&#34;text-align:right&#34;&gt;右对齐&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;居中对齐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:right&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;markdown-高级技巧&#34;&gt;Markdown 高级技巧&lt;/h1&gt;
&lt;h2 id=&#34;支持的-html-元素&#34;&gt;支持的 HTML 元素&lt;/h2&gt;
&lt;p&gt;不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。&lt;/p&gt;
&lt;p&gt;目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;使用 &amp;lt;kbd&amp;gt;Ctrl&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Alt&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Del&amp;lt;/kbd&amp;gt; 重启电脑
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑&lt;/p&gt;
&lt;h2 id=&#34;转义&#34;&gt;转义&lt;/h2&gt;
&lt;p&gt;Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;**文本加粗** 
\*\* 正常显示星号 \*\*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;公式&#34;&gt;公式&lt;/h2&gt;
&lt;p&gt;当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp;amp; \mathbf{j} &amp;amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;amp;  \frac{\partial Y}{\partial u} &amp;amp; 0 \\
\frac{\partial X}{\partial v} &amp;amp;  \frac{\partial Y}{\partial v} &amp;amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&#39;katex-block katex-error&#39; title=&#39;ParseError: KaTeX parse error: Can&amp;#039;t use function &amp;#039;$&amp;#039; in math mode at position 248: …
\end{vmatrix}
$̲{$tep1}{\style{…&#39;&gt;\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix} 
\mathbf{i} &amp;amp; \mathbf{j} &amp;amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;amp;  \frac{\partial Y}{\partial u} &amp;amp; 0 \\
\frac{\partial X}{\partial v} &amp;amp;  \frac{\partial Y}{\partial v} &amp;amp; 0 \\
\end{vmatrix}
${$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
&lt;/p&gt;
&lt;hr class=&#34;footnotes-sep&#34;&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;ol class=&#34;footnotes-list&#34;&gt;
&lt;li id=&#34;fn1&#34; class=&#34;footnote-item&#34;&gt;&lt;p&gt;菜鸟教程 -- 学的不仅是技术，更是梦想！！！ &lt;a href=&#34;#fnref1&#34; class=&#34;footnote-backref&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
">Markdown语法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/zhao-bu-tong-wei-yun-suan-ha-xi-biao/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定两个字符串 s 和 t，它们只包含小写字母。&lt;br&gt;
字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。&lt;br&gt;
请找出在 t 中被添加的字母。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
输入：s = &amp;quot;abcd&amp;quot;, t = &amp;quot;abcde&amp;quot;&lt;br&gt;
输出：&amp;quot;e&amp;quot;&lt;br&gt;
解释：&#39;e&#39; 是那个被添加的字母。&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;
输入：s = &amp;quot;&amp;quot;, t = &amp;quot;y&amp;quot;&lt;br&gt;
输出：&amp;quot;y&amp;quot;&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;
输入：s = &amp;quot;a&amp;quot;, t = &amp;quot;aa&amp;quot;&lt;br&gt;
输出：&amp;quot;a&amp;quot;&lt;/p&gt;
&lt;p&gt;示例 4：&lt;br&gt;
输入：s = &amp;quot;ae&amp;quot;, t = &amp;quot;aea&amp;quot;&lt;br&gt;
输出：&amp;quot;a&amp;quot;&lt;br&gt;
 &lt;br&gt;
提示：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= s.length &amp;lt;= 1000&lt;br&gt;
t.length == s.length + 1&lt;br&gt;
s 和 t 只包含小写字母&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/find-the-difference&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;h4 id=&#34;方法1位运算&#34;&gt;方法1：位运算&lt;/h4&gt;
&lt;p&gt;&lt;sup&gt;运算符：0与任何数ch做&lt;/sup&gt;运算都是ch&lt;br&gt;
相同字符异或为0&lt;/p&gt;
&lt;p&gt;因为t中的字符是s + ch，所以s与t做异或剩下的就是ch&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    char findTheDifference(string s, string t) {
        char res = 0;
        for(char c : s + t) {
            res ^= c;
        }
        return res;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法2哈希表&#34;&gt;方法2：哈希表&lt;/h4&gt;
&lt;p&gt;把s中所有元素存到一个哈希表mpS里，t中所有元素存到一个哈希表mpT里&lt;br&gt;
然后比较两个哈希表每个元素个数，不一样的就是题目所求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;char findTheDifference(string s, string t) {
        unordered_map&amp;lt;char, int&amp;gt; mpS;
        unordered_map&amp;lt;char, int&amp;gt; mpT;
        char ch;
        for (auto ch : s) {
            mpS[ch]++;
        }
        for (auto ch : t) {
            mpT[ch]++;
        }

        for (ch = &#39;a&#39;; ch &amp;lt;= &#39;z&#39;; ch++) {
            if (mpS[ch] != mpT[ch]) {
                return ch;
            }
        }
        return ch;
    }
    ```&lt;/code&gt;&lt;/pre&gt;
">找不同(位运算)(哈希表)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/zui-chang-gong-gong-qian-zhui-zi-fu-chuan/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &amp;quot;&amp;quot;。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;]&lt;br&gt;
输出: &amp;quot;fl&amp;quot;&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;输入: [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;]&lt;br&gt;
输出: &amp;quot;&amp;quot;&lt;br&gt;
解释: 输入不存在公共前缀。&lt;br&gt;
说明:&lt;/p&gt;
&lt;p&gt;所有输入只包含小写字母 a-z 。&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/longest-common-prefix&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;直接每个字符串从头开始元素比较，不一样直接return即可A&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) {
        string str = &amp;quot;&amp;quot;;
        if (strs.size() == 0) {
            return str;
        }
        char ch;
        int i, j, min = INT_MAX;
        for (int m = 0; m &amp;lt; strs.size(); m++) {
            if (strs[m].size() &amp;lt; min) {
                min = strs[m].size();
            }
        }
        for (i = 0; i &amp;lt; min; i++) {
            ch = strs[0][i];
            for (j = 0; j &amp;lt; strs.size(); j++) {
                if (strs[j][i] != ch) {
                    return str;
                }
            }
            str += ch;
        }
        return str;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">最长公共前缀(字符串)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/fei-bo-na-qi-shu-lie-di-gui/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：&lt;br&gt;
F(0) = 0,   F(1) = 1&lt;br&gt;
F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1.&lt;br&gt;
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：n = 2&lt;br&gt;
输出：1&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2：&lt;/p&gt;
&lt;p&gt;输入：n = 5&lt;br&gt;
输出：5&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= n &amp;lt;= 100&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;h4 id=&#34;方法1递归&#34;&gt;方法1：递归&lt;/h4&gt;
&lt;p&gt;常规递归方法，然后愉快的超时&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int fib(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        return fib(n - 1) + fib(n - 2);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法2带备忘录的递归自顶向下&#34;&gt;方法2：带备忘录的递归（自顶向下）&lt;/h4&gt;
&lt;p&gt;可以把递归看成一颗树，自顶向下&lt;br&gt;
在递归的过程中很多元素其实已经被访问过了，比如n = 20，求n = 19 + n = 18，求19的时候求n = 18 + n = 17，这里可以看到n = 18被求了两次，下面的元素还有更多次重复的所以一般的递归时间复杂度非常高。如果可以把每个元素的值记录下来，下次求的时候直接用时间可以减少很多。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; arr;

    int help(int n) {
        if (n == 0) return 0;
        if (n == 1 || n == 2) {
            return 1;
        }
        if (arr[n] != 0) { //如果已经记录则直接用
            return arr[n];
        }
        //未记录则记录下来
        arr[n - 1] = help(n - 1) % 1000000007;
        arr[n - 2] = help(n - 2) % 1000000007;
        return arr[n - 1] + arr[n - 2];
    }

    int fib(int n) {
        for (int i = 1; i &amp;lt;= 101; i++) {
            arr.push_back(0);
        }
        return help(n) % 1000000007;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法3dp自底向上&#34;&gt;方法3：DP（自底向上）&lt;/h4&gt;
&lt;p&gt;方法2是从树的顶端到下面依次递归求值，也可以从树的底端到顶端求。&lt;br&gt;
还是利用一个数组，把每个值记录下来，从底到顶。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int fib(int n) {
        int dp[101];
        dp[1] = 1;
        dp[2] = 1;
        if (n == 0) {
            return 0;
        }
        if (n == 1 || n == 2) {
            return 1;
        }
        for (int i = 3; i &amp;lt;= n; i++) {
            dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n];
    }
};
&lt;/code&gt;&lt;/pre&gt;
">斐波那契数列(递归)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/hui-fu-er-cha-sou-suo-shu-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root = [1,3,null,null,2]&lt;br&gt;
输出：[3,1,null,null,2]&lt;br&gt;
解释：3 不能是 1 左孩子，因为 3 &amp;gt; 1 。交换 1 和 3 使二叉搜索树有效。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2：&lt;/p&gt;
&lt;p&gt;输入：root = [3,1,4,null,null,2]&lt;br&gt;
输出：[2,1,4,null,null,3]&lt;br&gt;
解释：2 不能在 3 的右子树中，因为 2 &amp;lt; 3 。交换 2 和 3 使二叉搜索树有效。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;树上节点的数目在范围 [2, 1000] 内&lt;br&gt;
-231 &amp;lt;= Node.val &amp;lt;= 231 - 1&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/recover-binary-search-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;二叉树搜索树中序遍历就是二叉搜索树元素从小到大排列，知道这个就好做了。&lt;br&gt;
采用中序遍历：每个节点和前一个相比，小的话就把前一个节点记录下来(只有第一次记录前一个节点，因为题目说明只有两个元素错位)，然后下一次遇到前一个元素比后面的元素大的情况把后一个元素记录下来。&lt;br&gt;
最后把两个记录点的val交换。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = new TreeNode(-2147483648);
    TreeNode* s = NULL;
    TreeNode* t = new TreeNode();

    void recover(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        recover(root-&amp;gt;left);
        if (root-&amp;gt;val &amp;lt; pre-&amp;gt;val) {
            s = (s == NULL) ? pre:s;
            t = root; 
        }
        pre = root;
        recover(root-&amp;gt;right);
    }
    void recoverTree(TreeNode* root) {
        recover(root);
        int n = s-&amp;gt;val;
        s-&amp;gt;val = t-&amp;gt;val;
        t-&amp;gt;val = n;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">恢复二叉搜索树(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-ju-chi-xing-ceng-ci-bian-li-er-cha-shu-bfs/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;例如：&lt;br&gt;
给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    3
   / \
  9  20
    /  \
   15   7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回锯齿形层次遍历如下：&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[3],&lt;br&gt;
[20,9],&lt;br&gt;
[15,7]&lt;br&gt;
]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;首先把每一行所有节点存放到一个数组中，然后再把这个数组存放到一个二维数组中，然后把一维数组清空。依次遍历，然后每遍历完一行下一行数组翻转即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子，判断是否翻转
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode* root) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr;
        vector&amp;lt;int&amp;gt; brr;
        if (root == NULL) {
            return arr;
        }
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);
        TreeNode* node;
        while (!q.empty()) { //BFS
            int n = q.size(); //记录当前队列元素数量
            for (int i = 0; i &amp;lt; n; i++) {
                brr.push_back(q.front()-&amp;gt;val); //把上一层所有节点加入到一维数组中
                node = q.front();
                q.pop();
                if (node-&amp;gt;left != NULL) {
                    q.push(node-&amp;gt;left);
                }
                if (node-&amp;gt;right != NULL) {
                    q.push(node-&amp;gt;right);
                }
            }
            if (jud == true) { //翻转
                reverse(brr.begin(), brr.end());
                jud = false; //更改反转因子
            }
            else { //不翻转
                jud = true; //更改反转因子
            }
            arr.push_back(brr); //把一维数组加入到二维数组
            brr.clear(); //然后把一维数组清空
        }
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树的锯齿形层次遍历(二叉树)(BFS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;你可以将以下二叉树：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      1
     / \
    2   3
       / \
      4   5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;序列化为 &amp;quot;[1,2,3,null,null,4,5]&amp;quot;&lt;br&gt;
提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。&lt;/p&gt;
&lt;p&gt;说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        queue&amp;lt;TreeNode*&amp;gt; q;
        q.push(root);
        string str = &amp;quot;&amp;quot;;
        TreeNode* node;
        while (!q.empty()) {
            int n = q.size();
            for (int i = 0; i &amp;lt; n; i++) {
                node = q.front();
                q.pop();
                if (node == NULL) {
                    str += &amp;quot;null,&amp;quot;;
                    continue;
                }
                str += to_string(node-&amp;gt;val);
                str += &amp;quot;,&amp;quot;;
                q.push(node-&amp;gt;left);
                q.push(node-&amp;gt;right);
            }
        }
        return str;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data[0] == &#39;n&#39;) {
            return NULL;
        }
        int m = 0, n = 0;
        TreeNode* node;
        queue&amp;lt;TreeNode*&amp;gt; q;
        vector&amp;lt;int&amp;gt; arr;
        string str = &amp;quot;&amp;quot;;
        while (m &amp;lt; data.size()) {
            if (data[m] == &#39;,&#39;) {
                if (!str.empty())
                    arr.push_back(stoi(str));
                str = &amp;quot;&amp;quot;;
                m++;
                continue;
            }
            if (data[m] == &#39;n&#39;) {
                m += 4;
                if (!str.empty())
                    arr.push_back(stoi(str));
                arr.push_back(-1024);
                str = &amp;quot;&amp;quot;;
                continue;
            }
            str += data[m];
            m++;
        }
        TreeNode* root = new TreeNode(arr[0]);
        if (arr.size() == 1) {
            return root;
        }
        m = 1;
        q.push(root);
        while (!q.empty() &amp;amp;&amp;amp; m &amp;lt; arr.size()) {
            n = q.size();
            for (int i = 0; i &amp;lt; n; i++) {
                node = q.front();
                q.pop();
                if (arr[m] != -1024) {
                    node-&amp;gt;left = new TreeNode(arr[m]);
                    q.push(node-&amp;gt;left);
                }
                else {
                    node-&amp;gt;left = nullptr;
                }
                if (arr[m + 1] != -1024) {
                    node-&amp;gt;right = new TreeNode(arr[m+1]);
                    q.push(node-&amp;gt;right);
                }
                else {
                    node-&amp;gt;right = nullptr;
                }
                m += 2;
            }
        }
        return root;
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
&lt;/code&gt;&lt;/pre&gt;
">二叉树的序列化与反序列化(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-zui-jin-gong-gong-zu-xian-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1&lt;br&gt;
输出: 3&lt;br&gt;
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4&lt;br&gt;
输出: 5&lt;br&gt;
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;说明:&lt;/p&gt;
&lt;p&gt;所有节点的值都是唯一的。&lt;br&gt;
p、q 为不同节点且均存在于给定的二叉树中。&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;递归自底向上遍历每个节点：&lt;br&gt;
如果此节点为空返回空；&lt;br&gt;
如果此节点为p或q返回该节点；&lt;br&gt;
如果该节点的左孩子或右孩子为p或q，返回该节点的左子树或右子树；&lt;br&gt;
如果该节点左子树为p右子树为q则该节点为最近公共祖先，返回该节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == NULL || root == p || root == q) {
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root-&amp;gt;left, p, q);
        TreeNode* right = lowestCommonAncestor(root-&amp;gt;right, p, q);
        if (left != NULL &amp;amp;&amp;amp; right != NULL) {
            return root;
        }
        return left ? left : right;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树的最近公共祖先(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/wu-chong-fu-zi-fu-de-zui-chang-zi-chuan-hua-dong-chuang-kou/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;quot;abcabcbb&amp;quot;&lt;br&gt;
输出: 3&lt;br&gt;
解释: 因为无重复字符的最长子串是 &amp;quot;abc&amp;quot;，所以其长度为 3。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;quot;bbbbb&amp;quot;&lt;br&gt;
输出: 1&lt;br&gt;
解释: 因为无重复字符的最长子串是 &amp;quot;b&amp;quot;，所以其长度为 1。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 3:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;quot;pwwkew&amp;quot;&lt;br&gt;
输出: 3&lt;br&gt;
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。&lt;br&gt;
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 4:&lt;/p&gt;
&lt;p&gt;输入: s = &amp;quot;&amp;quot;&lt;br&gt;
输出: 0&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;0 &amp;lt;= s.length &amp;lt;= 5 * 104&lt;br&gt;
s 由英文字母、数字、符号和空格组成&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;定义p为子串的头，j为尾部，p到j为一个窗口，如果新的元素i和窗口里的元素相同，则把p移动到i的后面。记录每一个窗口的长度，最后取最大&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        if (s.size() == 0)
        {
            return 0;
        }
        int i, j, max, n, p, jud = 0;
        i = 0;
        p = i;
        j = i + 1;
        max = 1;
        n = 1;
        for (; j &amp;lt; s.size(); j++)
        {
            jud = 0;
            for (p = i; p &amp;lt; j; p++)
            {
                if (s[p] == s[j])
                {
                    i = p + 1;
                    if (i == j)
                    {
                        n = 1;
                    }
                    else if (s[i] == s[j])
                    {
                        n = j - i;
                    }
                    else
                    {
                        n = j - i + 1;
                    }
                    jud = 1;
                    break;
                }
            }
            if (jud == 1)
            {
                continue;
            }
            n++;
            if (n &amp;gt; max)
                max = n;
        }
        return max;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">无重复字符的最长子串(滑动窗口)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/tian-chong-mei-ge-jie-dian-de-xia-yi-ge-you-ce-jie-dian-zhi-zhen-er-cha-shu-bfs/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;struct Node {&lt;br&gt;
int val;&lt;br&gt;
Node *left;&lt;br&gt;
Node *right;&lt;br&gt;
Node *next;&lt;br&gt;
}&lt;br&gt;
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。&lt;/p&gt;
&lt;p&gt;初始状态下，所有 next 指针都被设置为 NULL。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;p&gt;你只能使用常量级额外空间。&lt;br&gt;
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;输入：root = [1,2,3,4,5,6,7]&lt;br&gt;
输出：[1,#,2,3,#,4,5,6,7,#]&lt;br&gt;
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;树中节点的数量少于 4096&lt;br&gt;
-1000 &amp;lt;= node.val &amp;lt;= 1000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;每次循环用队列存储每一行的节点，每存储一个节点让前一个节点指向现在的节点。&lt;br&gt;
每次循环队列弹一个，进两个。这样每次循环完队列把上一层的节点全部弹出，把新一层的节点全部加入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if (root == NULL) {
            return NULL;
        }
        int num = 0;
        queue&amp;lt;Node*&amp;gt; q;
        q.push(root);
        while (!q.empty()) {
            Node* node;
            Node* front;
            front = NULL;
            num = q.size();
            for (int j = 0; j &amp;lt; num; j++) {
                node = q.front();
                q.pop();
                if (node-&amp;gt;left != NULL)
                    q.push(node-&amp;gt;left);
                if (node-&amp;gt;right != NULL) 
                    q.push(node-&amp;gt;right);
                if (front == NULL) {
                    front = node;
                }
                else {
                    front-&amp;gt;next = node;
                    front = front-&amp;gt;next;
                }
            };
        }
        return root;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">填充每个节点的下一个右侧节点指针(二叉树)(BFS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/lu-jing-zong-he-er-cha-shu-dfs/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;说明: 叶子节点是指没有子节点的节点。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例: &lt;br&gt;
给定如下二叉树，以及目标和 sum = 22，&lt;br&gt;
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&amp;gt;4-&amp;gt;11-&amp;gt;2&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/path-sum&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;从根节点开始遍历每个节点，每次递归将此根节点和前面路径的节点传入，然后当时叶子结点时判断总路径是否相等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool jud = false; //判断因子
    int num;
    void path(TreeNode* root, int n) {
        if (root == NULL) { //根为空的情况
            return;
        }
        //判断路径和是否相等，并且判断是否为叶子结点
        if (root-&amp;gt;val + n == num &amp;amp;&amp;amp; root-&amp;gt;left == NULL &amp;amp;&amp;amp; root-&amp;gt;right == NULL) { 
            jud = true;
            return;
        }
        //递归遍历每个节点
        path(root-&amp;gt;left, root-&amp;gt;val + n);
        path(root-&amp;gt;right, root-&amp;gt;val + n);
    }
    bool hasPathSum(TreeNode* root, int sum) {
        //判断两者中特殊情况
        if (root == NULL &amp;amp;&amp;amp; sum == 0) {
            return false;
        }
        if (root == NULL &amp;amp;&amp;amp; sum != 0) {
            return false;
        }
        num = sum;
        path(root, 0);
        return jud;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">路径总和(二叉树)(DFS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-zui-xiao-zui-da-lu-jing-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，找出其最小深度。&lt;br&gt;
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。&lt;br&gt;
说明：叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;示例 1：&lt;br&gt;
输入：root = [3,9,20,null,null,15,7]&lt;br&gt;
输出：2&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;
输入：root = [2,null,3,null,4,null,5,null,6]&lt;br&gt;
输出：5&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;
树中节点数的范围在 [0, 105] 内&lt;br&gt;
-1000 &amp;lt;= Node.val &amp;lt;= 1000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;二叉树每个节点的路径最小(最大)为左子树和右子树中最小(最大)路径加上它自己&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = minDepth(root-&amp;gt;left);
        int right = minDepth(root-&amp;gt;right);
        if (left == 0) {
            return right + 1;
        }
        if (right == 0) {
            return left + 1;
        }
        return min(left, right) + 1;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树的最小(最大)路径(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-ceng-xu-bian-li-er-cha-shu-bfs/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
二叉树：[3,9,20,null,null,15,7],&lt;br&gt;
&lt;img src=&#34;https://sakuratears.cn/post-images/1607763983990.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;返回其层次遍历结果：&lt;/p&gt;
&lt;p&gt;[&lt;br&gt;
[3],&lt;br&gt;
[9,20],&lt;br&gt;
[15,7]&lt;br&gt;
]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;解题思路&#34;&gt;解题思路&lt;/h3&gt;
&lt;p&gt;在用BFS循环遍历时。先记录现在队列里面的元素个数n，n就是此二叉树这一深度拥有的节点数，然后循环n次，把n个节点的左右孩子都添加到队列里面，每次循环完把队列前面的元素pop到一个动态数组里，这样就能实现一个深度的节点为一个数组了&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; arr;

    void BFS(TreeNode* root) {
        queue&amp;lt;TreeNode*&amp;gt; brr;
        vector&amp;lt;int&amp;gt; crr;
        brr.push(root);
        int n = 0;
        while (!brr.empty()) {
            TreeNode* node = brr.front();
            n = brr.size(); //n记录当前队列元素个数
            for (int i = 0; i &amp;lt; n; i++) { //循环n次
                if (node-&amp;gt;left != NULL) { //左孩子不为空则添加左孩子
                    brr.push(node-&amp;gt;left);
                }
                if (node-&amp;gt;right != NULL) { //右孩子不为空则添加右孩子
                    brr.push(node-&amp;gt;right);
                }
                crr.push_back(brr.front()-&amp;gt;val); //每次循环把队列的头元素的值添加到一个数组里
                brr.pop();
                node = brr.front(); //节点移动到下一个
            }
            arr.push_back(crr); //把当前数组元素添加到二维数组中
            crr.clear(); //当前数组清空
        }
    }

    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; levelOrder(TreeNode* root) {
        if (root == NULL) {
            return arr;
        }
        BFS(root);
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树的层序遍历(二叉树)(BFS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;根据一棵树的前序遍历与中序遍历构造二叉树。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;注意:&lt;br&gt;
你可以假设树中没有重复的元素。&lt;/p&gt;
&lt;p&gt;例如，给出&lt;/p&gt;
&lt;p&gt;前序遍历 preorder = [3,9,20,15,7]&lt;br&gt;
中序遍历 inorder = [9,3,15,20,7]&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;和上一题基本一样0.0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) {
        TreeNode* tree = new TreeNode(preorder[0]);
        if (inorder.size() &amp;lt;= 1) {
            return tree;
        }
        int i, m;
        for (i = 0; i &amp;lt; inorder.size(); i++) {
            if (inorder[i] == preorder[0]) {
                break;
            }
        }
        m = i;
        vector&amp;lt;int&amp;gt; arr0, arr1, brr0, brr1;
        if (m == 0) {
            tree-&amp;gt;left = NULL;
        }
        else {
            for (int j = 0, i = 1; j &amp;lt; m; j++, i++) {
                arr0.push_back(preorder[i]);
                brr0.push_back(inorder[j]);
            }
            tree-&amp;gt;left = build(arr0, brr0);
        }
        if (m &amp;gt;= inorder.size() - 1) {
            tree-&amp;gt;right = NULL;
        }
        else {
            for (int j = m + 1; j &amp;lt; inorder.size(); j++) {
                arr1.push_back(preorder[j]);
                brr1.push_back(inorder[j]);
            }
            tree-&amp;gt;right = build(arr1, brr1);
        }
        return tree;
    }

    TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) {
        if (inorder.size() == 0 || preorder.size() == 0) {
            return NULL;
        }
        return build(preorder, inorder);
    }
};
&lt;/code&gt;&lt;/pre&gt;
">从前序与中序遍历序列构造二叉树(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/cong-zhong-xu-yu-hou-xu-bian-li-xu-lie-gou-zao-er-cha-shu-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;根据一棵树的中序遍历与后序遍历构造二叉树。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;注意:&lt;br&gt;
你可以假设树中没有重复的元素。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;例如，给出&lt;br&gt;
中序遍历 inorder = [9,3,15,20,7]&lt;br&gt;
后序遍历 postorder = [9,15,7,20,3]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;得到结果：[3,9,20,null,null,15,7]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;二叉树的后序遍历最后一个元素是二叉树的的根节点，然后中序遍历根节点左边元素是左子树的节点，右边是右子树的节点。&lt;br&gt;
知道这个这道题就很简单了，用递归调用求左子树右子树。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* build(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) {
        TreeNode* tree = new TreeNode(postorder[postorder.size() - 1]);
        if (inorder.size() &amp;lt;= 1) {
            return tree;
        }
        int i, m; //找到根节点m
        for (i = 0; i &amp;lt; inorder.size(); i++) {
            if (inorder[i] == postorder[postorder.size() - 1]) {
                break;
            }
        }
        m = i;
        vector&amp;lt;int&amp;gt; arr0, arr1, brr0, brr1;
        if (m == 0) { //考虑左边已经空了的情况
            tree-&amp;gt;left = NULL;
        }
        else {
            for (int i = 0; i &amp;lt; m; i++) {
                arr0.push_back(inorder[i]);
                brr0.push_back(postorder[i]);
            }
            tree-&amp;gt;left = build(arr0, brr0);
        }
        if (m &amp;gt;= inorder.size() - 1) {  //考虑右边已经空了的情况
            tree-&amp;gt;right = NULL;
        }
        else {
            for (int i = m + 1, j = m; i &amp;lt; inorder.size(); i++, j++) {
                arr1.push_back(inorder[i]);
                brr1.push_back(postorder[j]);
            }
            tree-&amp;gt;right = build(arr1, brr1);
        }
        return tree;
    }
    TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) {
            return NULL;
        }
        return build(inorder, postorder);
    }
};
&lt;/code&gt;&lt;/pre&gt;
">从中序与后序遍历序列构造二叉树(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-de-zhong-xu-bian-li/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树的根节点 root ，返回它的 中序 遍历。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：root = [1,null,2,3]&lt;br&gt;
输出：[1,3,2]&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2：&lt;/p&gt;
&lt;p&gt;输入：root = []&lt;br&gt;
输出：[]&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 3：&lt;/p&gt;
&lt;p&gt;输入：root = [1]&lt;br&gt;
输出：[1]&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 4：&lt;/p&gt;
&lt;p&gt;输入：root = [1,2]&lt;br&gt;
输出：[2,1]&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 5：&lt;/p&gt;
&lt;p&gt;输入：root = [1,null,2]&lt;br&gt;
输出：[1,2]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;树中节点数目在范围 [0, 100] 内&lt;br&gt;
-100 &amp;lt;= Node.val &amp;lt;= 100&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;就二叉树的中序遍历，没有任何坑，直接写就行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&amp;lt;int&amp;gt; arr;
    void traversal(TreeNode* root) {
        if (root == NULL) {
            return;
        }
        inorderTraversal(root-&amp;gt;left);
        arr.push_back(root-&amp;gt;val);
        inorderTraversal(root-&amp;gt;right);
    }
    vector&amp;lt;int&amp;gt; inorderTraversal(TreeNode* root) {
        traversal(root);
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树的中序遍历(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/dui-cheng-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_35r5gAjUVn.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_BIOlXHyv1p.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;p&gt;你可以运用递归和迭代两种方法解决这个问题吗？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/symmetric-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;判断二叉树是否对称可以理解为判断一个节点的两个子树的里侧和外侧是否对称，就是后序遍历。&lt;br&gt;
判断外侧是否对称，传入左节点的左孩子，右节点的右孩子。&lt;br&gt;
判断里侧是否对称，传入左节点的右孩子，右节点的左孩子。&lt;br&gt;
可以用递归挨个判断，所以递归函数传的值就要是left,right两个，想通这一点就好做了。&lt;br&gt;
判断空的情况，&lt;br&gt;
左空右空       返回true&lt;br&gt;
左空右不空    返回false&lt;br&gt;
左不空右空    返回false&lt;br&gt;
最后是都不空，判断值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool cmp(TreeNode* left, TreeNode* right) {
        if (left == NULL &amp;amp;&amp;amp; right == NULL) {
            return true;
        }
        else if (left == NULL &amp;amp;&amp;amp; right != NULL) {
            return false;
        }
        else if (left != NULL &amp;amp;&amp;amp; right == NULL) {
            return false;
        }
        //都不空判断值
        else if (left-&amp;gt;val != right-&amp;gt;val) {
            return false;
        }

        bool in = cmp(left-&amp;gt;right, right-&amp;gt;left);
        bool out = cmp(left-&amp;gt;left, right-&amp;gt;right);
        return in &amp;amp;&amp;amp; out;
    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) {
            return true;
        }
        return cmp(root-&amp;gt;left, root-&amp;gt;right);
    }
};
&lt;/code&gt;&lt;/pre&gt;
">对称二叉树(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/ping-heng-er-cha-shu-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个二叉树，判断它是否是高度平衡的二叉树。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;本题中，一棵高度平衡二叉树定义为：&lt;/p&gt;
&lt;p&gt;一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;输入：root = [3,9,20,null,null,15,7]&lt;br&gt;
输出：true&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2：&lt;br&gt;
&lt;img src=&#34;https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;输入：root = [1,2,2,3,3,null,null,4,4]&lt;br&gt;
输出：false&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 3：&lt;/p&gt;
&lt;p&gt;输入：root = []&lt;br&gt;
输出：true&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;树中的节点数在范围 [0, 5000] 内&lt;br&gt;
-104 &amp;lt;= Node.val &amp;lt;= 104&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/balanced-binary-tree&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;还是用二叉树的框架就行，每个节点的最大深度就是左子树或右子树中的最大深度加1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool jud = true; //判断因子
    int deep(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int left = deep(root-&amp;gt;left);
        int right = deep(root-&amp;gt;right);
        if (abs(left - right) &amp;gt; 1) { //如果左右子树深度相差大于1将判断因子设为false;
            jud = false;
        }
        return max(left, right) + 1;
    }
    bool isBalanced(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }
        deep(root);
        return jud;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">平衡二叉树(二叉树)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/er-cha-shu-zhong-de-zui-da-lu-jing-he-er-cha-shu/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个非空二叉树，返回其最大路径和。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;本题中，路径被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：[1,2,3]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   1
  / \
 2   3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：6&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2：&lt;/p&gt;
&lt;p&gt;输入：[-10,9,20,null,null,15,7]&lt;/p&gt;
&lt;p&gt;-10&lt;br&gt;
   / &lt;br&gt;
  9  20&lt;br&gt;
    /  &lt;br&gt;
   15   7&lt;/p&gt;
&lt;p&gt;输出：42&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;每一个节点的最大路径是它左右子树中最大的路径加上它自己，这样就是先遍历左子树，再遍历右子树。&lt;br&gt;
这样就是树的后序遍历+DFS的思想。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int imax = INT_MIN;
    int maxpath(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }

        int left = max(0, maxpath(root-&amp;gt;left));
        int right = max(0, maxpath(root-&amp;gt;right));
        /*二叉树的后序遍历*/
        imax = max(imax, left + right + root-&amp;gt;val);
        return max(left, right) + root-&amp;gt;val;
    }
    int maxPathSum(TreeNode* root) {
        maxpath(root);
        return imax;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">二叉树中的最大路径和(二叉树)(DFS)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/yang-hui-san-jiao/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例:&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;输入: 5&lt;br&gt;
输出:&lt;br&gt;
[&lt;br&gt;
[1],&lt;br&gt;
[1,1],&lt;br&gt;
[1,2,1],&lt;br&gt;
[1,3,3,1],&lt;br&gt;
[1,4,6,4,1]&lt;br&gt;
]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/pascals-triangle&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;简单题，直接写就行，leetcode的测试用例也没啥恶心的&lt;s&gt;可能是这个题没法恶心了吧&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; generate(int numRows) {
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; nums;
        if (numRows == 0) {  //判断0的情况下
            return nums;
        }
        vector&amp;lt;int&amp;gt; num;
        num.push_back(1);
        nums.push_back(num);
        for (int i = 1; i &amp;lt; numRows; i++) {
            vector&amp;lt;int&amp;gt; num;
            num.push_back(1);
            for (int j = 1; j &amp;lt; i; j++) {
                num.push_back(nums[i - 1][j - 1] + nums[i - 1][j]); //每行数组的[j]是上一个数组的[j]位置+[j - 1]位置
            }
            num.push_back(1);
            nums.push_back(num);
        }
        return nums;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">杨辉三角(数组)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/zi-fu-chuan-zhuan-huan-zheng-shu-atoi/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;请你来实现一个 atoi 函数，使其能将字符串转换成整数。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。&lt;br&gt;
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。&lt;br&gt;
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。&lt;br&gt;
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;在任何情况下，若函数不能进行有效的转换时，请返回 0 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;本题中的空白字符只包括空格字符 &#39; &#39; 。&lt;br&gt;
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: &amp;quot;42&amp;quot;&lt;br&gt;
输出: 42&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;输入: &amp;quot;   -42&amp;quot;&lt;br&gt;
输出: -42&lt;br&gt;
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。&lt;br&gt;
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 3:&lt;/p&gt;
&lt;p&gt;输入: &amp;quot;4193 with words&amp;quot;&lt;br&gt;
输出: 4193&lt;br&gt;
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 4:&lt;/p&gt;
&lt;p&gt;输入: &amp;quot;words and 987&amp;quot;&lt;br&gt;
输出: 0&lt;br&gt;
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。&lt;br&gt;
因此无法执行有效的转换。&lt;br&gt;&lt;br&gt;&lt;br&gt;
示例 5:&lt;/p&gt;
&lt;p&gt;输入: &amp;quot;-91283472332&amp;quot;&lt;br&gt;
输出: -2147483648&lt;br&gt;
解释: 数字 &amp;quot;-91283472332&amp;quot; 超过 32 位有符号整数范围。&lt;br&gt;
     因此返回 INT_MIN (−231) 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/string-to-integer-atoi&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int myAtoi(string s) {
        int i = 0, m = 0, jud = 0, n = 0, p, j = 0;
        while (s[i] == &#39; &#39;) {
            i++;
        }
        if (s[i] != &#39;-&#39; &amp;amp;&amp;amp; s[i] != &#39;+&#39; &amp;amp;&amp;amp; (s[i] &amp;gt; 57 || s[i] &amp;lt; 48))
            return 0;
        if ((s[i] == &#39;-&#39; || s[i] == &#39;+&#39;) &amp;amp;&amp;amp; (s[i + 1] &amp;gt; 57 || s[i + 1] &amp;lt; 48))
            return 0;
        while (s[i] &amp;gt; 57 || s[i] &amp;lt; 48) {
            i++;
        }
        if (i &amp;gt; 0 &amp;amp;&amp;amp; s[i - 1] == &#39;-&#39;) {
            jud = 1;
        }
        while (s[i] == &#39;0&#39;) {
            i++;
        }
        if (s[i] &amp;gt; 57 || s[i] &amp;lt; 48) {
            return 0;
        }
        j = i;
        while (s[i] &amp;lt;= 57 &amp;amp;&amp;amp; s[i] &amp;gt;= 48) {
            i++;
            n++;//位数
        }
        if (n &amp;gt; 10) {
            if (jud == 0)
                return pow(2, 31) - 1;
            else
                return -pow(2, 31);
        }
        p = n - 1;
        for (; j &amp;lt; i; j++) {
            if ((m + (s[j] - 48) * pow(10, p) &amp;gt; pow(2, 31) - 1) &amp;amp;&amp;amp; jud == 0) {
                return pow(2, 31) - 1;
            }
            if ((m + (s[j] - 48) * pow(10, p) &amp;gt;= pow(2, 31)) &amp;amp;&amp;amp; jud == 1) {
                return -pow(2, 31);
            }
            m += (s[j] - 48) * pow(10, p);
            p--;
        }
        if (jud == 1) {
            m = -m;
        }
        return m;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">字符串转换整数 (atoi)(字符串)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/zheng-shu-fan-zhuan/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 123&lt;br&gt;
输出: 321&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;p&gt;输入: -123&lt;br&gt;
输出: -321&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: 120&lt;br&gt;
输出: 21&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;注意:&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/reverse-integer&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;p&gt;多注意爆int的地方，多wa几发就过了&lt;s&gt;手动狗头&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int reverse(int x) {
        int j = 0, m = 0, num = 0, jud = 0;
        char str[1000];
        int i = 0;
        if (x &amp;lt; 0)
        {
            if (x &amp;lt;= -pow(2, 31)) // 负数正好没爆int，转正可能就会正好爆
                return 0;
            x = -x;
            jud = 1;
        }
        while (x &amp;gt; 0)
        {
            str[i++] = x % 10 + 48;
            x /= 10;
        }
        str[i] = &#39;\0&#39;;
        if (str[0] == &#39;0&#39;)
        {
            m = 1;
        }
        for (int i = m; str[i] != &#39;\0&#39;; i++)
        {
            j++;
        }
        j--;
        for (int i = m; str[i] != &#39;\0&#39;; i++)
        {
            if ((str[i] - 48) * pow(10, j) &amp;gt; pow(2, 31) - 1 || (str[i] - 48) * pow(10, j) &amp;lt; -pow(2, 31)) { //可能爆int的地方
                return 0;
            }
            if (num + (str[i] - 48) * pow(10, j) &amp;gt; pow(2, 31) - 1 || num + (str[i] - 48) * pow(10, j) &amp;lt; -pow(2, 31)) {  //可能爆int的地方
                return 0;
            }
            num += (str[i] - 48) * pow(10, j);
            j--;
        }
        if (jud != 0)
        {
            num = -num;
        }
        return num;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">整数反转(数组)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/z-zi-xing-bian-huan/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;比如输入字符串为 &amp;quot;LEETCODEISHIRING&amp;quot; 行数为 3 时，排列如下：&lt;br&gt;&lt;/p&gt;
&lt;p&gt;L   C   I   R&lt;br&gt;
E T O E S I I G&lt;br&gt;
E   D   H   N&lt;br&gt;
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&amp;quot;LCIRETOESIIGEDHN&amp;quot;。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;请你实现这个将字符串进行指定行数变换的函数：&lt;br&gt;&lt;/p&gt;
&lt;p&gt;string convert(string s, int numRows);&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;
输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 3&lt;br&gt;
输出: &amp;quot;LCIRETOESIIGEDHN&amp;quot;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;
输入: s = &amp;quot;LEETCODEISHIRING&amp;quot;, numRows = 4&lt;br&gt;
输出: &amp;quot;LDREOEIIECIHNTSG&amp;quot;&lt;br&gt;
解释:&lt;br&gt;&lt;/p&gt;
&lt;p&gt;L     D     R&lt;br&gt;
E   O E   I I&lt;br&gt;
E C   I H   N&lt;br&gt;
T     S     G&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/zigzag-conversion&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;h4 id=&#34;代码1&#34;&gt;代码1.&lt;/h4&gt;
&lt;p&gt;纯暴力写出来了，贴个代码算了0.0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1)
            return s;
        int num = 0, m = 0, p = 1, j = 0;
        char arr[1000][1000];
        string str;
        for (int i = 0; i &amp;lt; 1000; i++)
        {
            for (int j = 0; j &amp;lt; 1000; j++)
            {
                arr[i][j] = NULL;
            }
        }
        for (int i = 0; num &amp;lt; s.size(); i++)
        {
            for (j = 0; j &amp;lt; numRows &amp;amp;&amp;amp; num &amp;lt; s.size(); j++)
            {
                if (i == 0 || i == m + numRows - 1)
                {
                    m = i;
                    for (j = 0; j &amp;lt; numRows &amp;amp;&amp;amp; num &amp;lt; s.size(); j++)
                    {
                        arr[j][i] = s[num];
                        num++;
                    }
                    p = 0;
                    continue;
                }
                else
                {
                    if (j != numRows - 1 &amp;amp;&amp;amp; arr[j + 1][i - 1] != NULL)
                    {
                        if (i != m + 1 &amp;amp;&amp;amp; i != 1)
                        {
                            arr[j][i] = s[num];
                            p = 0;
                            num++;
                            continue;
                        }
                        else
                        {
                            j = numRows - 2;
                            arr[j][i] = s[num];
                            i++;
                            j = -1;
                            num++;
                            continue;
                        }
                    }
                }
            }
        }
        for (int i = 0; i &amp;lt; s.size() &amp;amp;&amp;amp; str.size() != s.size(); i++)
        {
            for (int j = 0; j &amp;lt; s.size() &amp;amp;&amp;amp; str.size() != s.size(); j++)
            {
                if (arr[i][j] &amp;gt;= 41 &amp;amp;&amp;amp; arr[i][j] &amp;lt;= 176)
                {
                    str += arr[i][j];
                }
            }
        }
        return str;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;代码2&#34;&gt;代码2&lt;/h4&gt;
&lt;p&gt;1.res[i] += c： 把每个字符 c 填入对应行 s i;&lt;br&gt;
2.i += flag： 更新当前字符 c 对应的行索引；&lt;br&gt;
3.flag = - flag： 在达到 Z 字形转折点时，执行反向&lt;br&gt;&lt;/p&gt;
&lt;p&gt;把每一行放到一个字符串数组里面，利用flag就行上下控制。&lt;s&gt;比我那菜鸡算法好太多了&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    string convert(string s, int numRows)
    {
        if (numRows == 1) {
            return s;
        }
        string str[1000];
        int i = 0, flag = 1, num = 0;
        while (num &amp;lt; s.size())
        {

            str[i] += s[num];
            i += flag;
            if (i &amp;gt;= numRows)
            {
                flag = -flag;
                i += flag;
                i += flag;
            }
            if (i &amp;lt; 0)
            {
                flag = -flag;
                i += flag;
                i += flag;
            }
            num++;
        }
        s = &amp;quot;&amp;quot;;
        for (i = 0; i &amp;lt; numRows; i++) {
            s += str[i];
        }
        return s;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">Z 字形变换(字符串)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/zui-chang-hui-wen-zi-chuan-dong-tai-gui-hua/"" data-c="
          &lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;示例 1：&lt;br&gt;
输入: &amp;quot;babad&amp;quot;&lt;br&gt;
输出: &amp;quot;bab&amp;quot;&lt;br&gt;
注意: &amp;quot;aba&amp;quot; 也是一个有效答案。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;
输入: &amp;quot;cbbd&amp;quot;&lt;br&gt;
输出: &amp;quot;bb&amp;quot;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/longest-palindromic-substring&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;h4 id=&#34;暴力求解&#34;&gt;暴力求解&lt;/h4&gt;
&lt;p&gt;把每个长度大于二的子串都进行验证，然后取最大，时间复杂度O(n3)，然后就愉快的超时0.0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    bool vali(string s, int i, int j)
    {
        while (i &amp;lt;= j) {
            if (s[i] != s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }
    string longestPalindrome(string s) {
        int size = s.size();
        if (size &amp;lt; 2)
            return s;
        int max = 1;
        string str = s.substr(0, 1);
        for (int i = 0; i &amp;lt; size - 1; i++) {
            for (int j = i + 1; j &amp;lt; size; j++) {
                if (j - i + 1 &amp;gt; max &amp;amp;&amp;amp; vali(s, i, j)) {
                    max = j - i + 1;
                    str = s.substr(i, max);
                }
            }
        }
        return str;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;动态规划&#34;&gt;动态规划&lt;/h4&gt;
&lt;p&gt;动态规划关键步骤状态转移：&lt;br&gt;
一个回文去掉两头以后，剩下的部分依然是回文；&lt;br&gt;
如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；&lt;br&gt;
如果一个字符串的头尾两个字符相等，才有必要继续判断下去。&lt;br&gt;
如果里面的子串是回文，整体就是回文串；&lt;br&gt;
如果里面的子串不是回文串，整体就不是回文串。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;定义dp[i][j]表示s[i....j]是否为回文串(左闭右闭)，根据“如果里面的子串判断是否回文”，可以得到转移方程：dp[i][j] = (s[i] == s[j]) &amp;amp;&amp;amp; dp[i + 1][j - 1] == true&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;然后考虑一下边界问题：&lt;br&gt;&lt;br&gt;&lt;br&gt;
s[i + 1......j - 1]，成立的条件为长度小于2，即j - 1 - (i + 1) &amp;lt; 2，即j - i &amp;lt; 3.&lt;br&gt;
j - i &amp;lt; 3 等价于 j - i + 1 &amp;lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 1 个字符，显然是回文；&lt;br&gt;
如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;因此，在 s[i] == s[j] 成立和 j - i &amp;lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        if (len &amp;lt; 2)
            return s;
        int begin = 0;
        int max = 1; //记录回文子串开始位置和长度
        bool dp[len][len];
        for (int i = 0; i &amp;lt; len; i++) {
            dp[i][i] = true; //初始化，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 
        }
        for (int j = 1; j &amp;lt; len; j++) {
            for (int i = 0; i &amp;lt; j; i++) {
                if (s[i] != s[j]) {
                    dp[i][j] = false;
                }
                else {
                    if (j - i &amp;lt; 3) {
                        dp[i][j] = true;
                    }
                    else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                if (dp[i][j] &amp;amp;&amp;amp; j - i + 1 &amp;gt; max) {
                    begin = i;
                    max = j - i + 1;
                }
            }
        }
        string str = &amp;quot;&amp;quot;;
        for (int i = begin; i &amp;lt; begin + max; i++) {
            str += s[i];
        }
        return str;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;思路参考：liweiwei1419&lt;/p&gt;
">最长回文子串(动态规划)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/xun-zhao-liang-ge-zheng-xu-shu-zu-de-zhong-wei-shu-fen-zhi/"" data-c="
          &lt;p&gt;力扣的困难题&lt;s&gt;极其简单！！！&lt;/s&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;
输入：nums1 = [1,3], nums2 = [2]&lt;br&gt;
输出：2.00000&lt;br&gt;
解释：合并数组 = [1,2,3] ，中位数 2&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;
输入：nums1 = [1,2], nums2 = [3,4]&lt;br&gt;
输出：2.50000&lt;br&gt;
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 3：&lt;br&gt;
输入：nums1 = [0,0], nums2 = [0,0]&lt;br&gt;
输出：0.00000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 4：&lt;br&gt;
输入：nums1 = [], nums2 = [1]&lt;br&gt;
输出：1.00000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 5：&lt;br&gt;
输入：nums1 = [2], nums2 = []&lt;br&gt;
输出：2.00000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;nums1.length == m&lt;br&gt;
nums2.length == n&lt;br&gt;
0 &amp;lt;= m &amp;lt;= 1000&lt;br&gt;
0 &amp;lt;= n &amp;lt;= 1000&lt;br&gt;
1 &amp;lt;= m + n &amp;lt;= 2000&lt;br&gt;
-106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;题目过于简单，把小的数组加到大的数组题然后sort，再找中位数。0.0&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    double median(vector&amp;lt;int&amp;gt; nums) {
        if (nums.size() % 2 == 0) {
            double dou0 = nums[nums.size() / 2];
            double dou1 = nums[nums.size() / 2 - 1];
            return (dou0 + dou1) / 2;
        }
        else {
            double dou0 = nums[nums.size() / 2];
            return dou0;
        }
    } 
    double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) {
        if (nums1.size() == 0 &amp;amp;&amp;amp; nums2.size() == 0)
            return 0;
        if (nums1.size() &amp;gt;= nums2.size()) {
            for (int i = 0; i &amp;lt; nums2.size(); i++) {
                nums1.push_back(nums2[i]);
            }
            sort(nums1.begin(), nums1.end());
            return median(nums1);
        }
        else {
            for (int i = 0; i &amp;lt; nums1.size(); i++) {
                nums2.push_back(nums1[i]);
            }
            sort(nums2.begin(), nums2.end());
            return median(nums2);
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
">寻找两个正序数组的中位数(分治)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/bing-cha-ji/"" data-c="
          &lt;p&gt;LeetCode547题 朋友圈&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;题目&#34;&gt;题目&lt;/h3&gt;
&lt;p&gt;班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例 1：&lt;br&gt;&lt;br&gt;
输入：&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,0],&lt;br&gt;
[0,0,1]]&lt;br&gt;&lt;br&gt;&lt;br&gt;
输出：2&lt;br&gt;
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。&lt;br&gt;
第2个学生自己在一个朋友圈。所以返回 2 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2：&lt;br&gt;&lt;br&gt;
输入：&lt;br&gt;
[[1,1,0],&lt;br&gt;
[1,1,1],&lt;br&gt;
[0,1,1]]&lt;br&gt;&lt;br&gt;&lt;br&gt;
输出：1&lt;br&gt;
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= N &amp;lt;= 200&lt;br&gt;
M[i][i] == 1&lt;br&gt;
M[i][j] == M[j][i]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/friend-circles&lt;br&gt;
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;运用并查集算出相关集合&lt;/p&gt;
&lt;h4 id=&#34;并查集不优化代码&#34;&gt;并查集不优化代码：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
int count() { 
    return count;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;find函数是把一棵树直接接到另一棵树下面，这也就造成了树的退化(往链表退化)，就会使时间复杂度达到O(n)，union和connected都是要用到find，所以他们的时间复杂度也是O(n)。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&#34;优化方案&#34;&gt;优化方案&lt;/h4&gt;
&lt;h5 id=&#34;平衡优化&#34;&gt;平衡优化&lt;/h5&gt;
&lt;p&gt;另外开一个数组记录每棵树的“重量”(节点数),节点数少的接到节点数多的树里面，就可以降低复杂度。&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    
    // 小树接到大树下面，较平衡
    if (size[rootP] &amp;gt; size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ];
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    count--;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
##### 路径~~亚索~~压缩
如果我们可以进一步压缩树的高度，让树的高度始终为常数，那find的复杂度就是O(1).
压缩完是一个根节点下面都是叶子节点，这样树的高度就为常数，非常友好。&lt;br&gt;&lt;br&gt;
```C++
int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r]; //找到根节点
    int i = x, j;
    while (i != r) { //让每个节点都练到根节点上
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}
```
&lt;br&gt;&lt;br&gt;
### 代码
```C++
class Solution {
public:
    int counts;
    vector&lt;int&gt; parent;
    vector&lt;int&gt; size;
    void UF(int n) {
        counts = n;
        for (int i = 0; i &lt; n; i++) {
            parent.push_back(i);
            size.push_back(1);
        }
    }
&lt;pre&gt;&lt;code&gt;void Union(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    if (rootp == rootq)
        return;
    if (size[rootp] &amp;gt; size[rootq]) {
        parent[rootq] = rootp;
        size[rootp] += size[rootq];
    }
    else {
        parent[rootp] = rootq;
        size[rootq] += size[rootp];
    }
    counts--;
}

int find(int x) {
    int r = x;
    while (parent[r] != r)
        r = parent[r];
    int i = x, j;
    while (i != r) {
        j = parent[i];
        parent[i] = r;
        i = j;
    }
    return r;
}

bool connected(int p, int q) {
    int rootp = find(p);
    int rootq = find(q);
    return rootp == rootq;
}

int count() {
    return counts;
}

int findCircleNum(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; M) {
    UF(M[0].size());
    for (int i = 0; i &amp;lt; M.size(); i++) {
        for (int j = 0; j &amp;lt; M[0].size(); j++) {
            if (M[i][j] == 1) {
                Union(i, j);
            }
        }
    }
    return counts;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;
">朋友圈(并查集)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/linux-yi-xie-huan-jing-pei-zhi/"" data-c="
          &lt;h2 id=&#34;cc&#34;&gt;C/C++&lt;/h2&gt;
&lt;p&gt;安装环境g++,gcc,gdb&lt;br&gt;
终端命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install g++
sudo apt-get install gcc
sudo apt-get install gdb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;java&#34;&gt;Java&lt;/h2&gt;
&lt;p&gt;jdk,jre&lt;/p&gt;
">Linux一些环境配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/linuxdeepinri-chang-cao-zuo/"" data-c="
          &lt;p&gt;记录日常使用linux一些操作&lt;br&gt;
deepin永远滴神！！！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;安装deb文件&#34;&gt;安装deb文件&lt;/h3&gt;
&lt;p&gt;在deb文件目录下终端输入&lt;code&gt;sudo apt-get xx.deb&lt;/code&gt;(xx为文件名)&lt;/p&gt;
&lt;h3 id=&#34;打开taggz文件&#34;&gt;打开tag.gz文件&lt;/h3&gt;
&lt;p&gt;情况一(没有可执行文件)：解压缩后终端进入文件目录，然后cd进入/bin，执行./xxx.sh(xxx为程序名)&lt;br&gt;
情况二(有可执行文件)：直接运行可执行文件即可运行&lt;/p&gt;
&lt;h3 id=&#34;进入root身份&#34;&gt;进入root身份&lt;/h3&gt;
&lt;p&gt;终端输入&lt;code&gt;su&lt;/code&gt;然后输入密码(开机密码)&lt;br&gt;
如果提示su鉴定故障可以输入&lt;code&gt;sudo su&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;双系统切换时间问题&#34;&gt;双系统切换时间问题&lt;/h3&gt;
&lt;p&gt;终端输入&lt;code&gt;timedatectl set-local-rtc 1&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;双系统开机默认linux更改&#34;&gt;双系统开机默认linux更改&lt;/h3&gt;
&lt;p&gt;1.ctrl+alt+T打开终端，输入&lt;code&gt;sudo gedit /etc/default/grub&lt;/code&gt;&lt;br&gt;
2.验证密码，grub配置文件被打开&lt;br&gt;
3.将弹出的文件中文本“GRUB-DEFAULT=0”中的0修改为2.（我这里是2，具体数字应该和选择系统的时候win系统的位置-1相同。注意这个-1，因为它是从上到下从0开始排序，所以我这里win系统是第三位，就改成2）&lt;br&gt;
4.保存文件。←这时可能会弹出警告框，但是一般情况下好像并没有什么关系&lt;br&gt;
5.在终端输入&lt;code&gt;sudo update-grub&lt;/code&gt;以更新配置&lt;br&gt;
6.重启即可发现已经修改完毕&lt;/p&gt;
&lt;h3 id=&#34;linux显示系统信息&#34;&gt;linux显示系统信息&lt;/h3&gt;
&lt;p&gt;终端执行&lt;code&gt;sudo apt-get install screenfetch&lt;/code&gt;安装screenfetch&lt;br&gt;
然后执行&lt;code&gt;screenfetch -s&lt;/code&gt;显示系统信息&lt;/p&gt;
&lt;h3 id=&#34;bios声音问题&#34;&gt;BIOS声音问题&lt;/h3&gt;
&lt;p&gt;(deepin)有时候发生错误(比如在QQ输入框没有字的情况下按退格),会出现“嘟”的一声。这是主板BIOS声音没关的问题。&lt;br&gt;
执行 &lt;code&gt;sudo dedit /etc/modprobe.d/alsa-base-blacklist.conf&lt;/code&gt;，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blacklist pcspkr
blacklist snd_pcsp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存后执行 &lt;code&gt;sudo update-initramfs -u&lt;/code&gt;后重启即可。&lt;/p&gt;
">Linux(deepin)日常操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/ji-lu-xue-xi-de-ri-zi/"" data-c="
          &lt;!-- # 2020 --&gt;
&lt;h2 id=&#34;12&#34;&gt;12&lt;/h2&gt;
&lt;h3 id=&#34;1219&#34;&gt;12/19&lt;/h3&gt;
&lt;p&gt;今日水题：旋转图像&lt;br&gt;
不让我用辅助数组，我就用😏，反正能过&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_SlewcqsOkT.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
做完恶心的测试，中途还不能登录了&lt;s&gt;不知道这算不算bug&lt;/s&gt;，我真是被恶心到了&lt;/p&gt;
&lt;h3 id=&#34;1218&#34;&gt;12/18&lt;/h3&gt;
&lt;p&gt;大早上醒来一看epic，好家伙城市天际线外加10刀券，我直接好家伙，E宝永远滴神！！！&lt;br&gt;
今日水题：. 最长公共前缀&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_MxdrMrNJra.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
水题2：找不同&lt;br&gt;
本来想用哈希表做，但是不会用C++的map，想在题解里找找map的操作，然后找到了位运算的题解，位运算不咋会用但着实好用&lt;br&gt;
写了几个小时把可恶的Web大作业终于弄完了，引用js捣鼓半天，百度了半天都是错的，可恶啊&lt;/p&gt;
&lt;h3 id=&#34;1217&#34;&gt;12/17&lt;/h3&gt;
&lt;p&gt;今日水题：斐波那契数列&lt;br&gt;
本来以为是愉快的通过+1，然后没注意范围递归超时了0.0&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_bPSuU2dO1m.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1216&#34;&gt;12/16&lt;/h3&gt;
&lt;p&gt;今日做题：恢复二叉搜索树&lt;br&gt;
发现二叉树还有个例题没做，看了书上思路写出来的，二叉搜索树中序遍历就是从小到大遍历所有节点，学到了。不过还是被不讲武德的力扣坑了一发&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_9P0V6UUHaj.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1215&#34;&gt;12/15&lt;/h3&gt;
&lt;p&gt;今日做题：二叉树的序列化与反序列化&lt;br&gt;
本来想昨天把二叉树专题最后一题给A了，但是昨天感觉脑子不太行了，留到今天才完成。&lt;br&gt;
难度：Hard。但是感觉还是中规中矩&lt;s&gt;leetcode的难度真是个谜&lt;/s&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_ZwRAZOss7o.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
水题：二叉树的锯齿形层次遍历&lt;br&gt;
在二叉树层次遍历的基础上每遍历完一层把数组翻转即可，马虎WA了一发&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_coyCqKYeTU.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
二叉树系列共做16道题，这个专题就先告一段落了，准备开启新的篇章了&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_X5XTBVnaFF.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
水题三数之和，可能~~我又困了？~~写了半天，双指针忘了咋写了&lt;/p&gt;
&lt;h3 id=&#34;1214&#34;&gt;12/14&lt;/h3&gt;
&lt;p&gt;今日做题：填充每个节点的下一个右侧节点指针（二）&lt;br&gt;
和一差不多，多了一个非完全二叉树，判一下空就行&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_3vKIFv2LKO.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
带牙套是真别扭0.0，这一下说话都不利索了&lt;br&gt;
做题二：二叉树的最近公共祖先&lt;br&gt;
虽然难度是Easy，但FW的我还是做不出来。卡在公共祖先问题上了&lt;br&gt;
这大佬们写的代码就是牛！&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_HuVaSySO9t.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1213&#34;&gt;12/13&lt;/h3&gt;
&lt;p&gt;两道水题：二叉树的最大（最小）路径&lt;br&gt;
&lt;img src=&#34;https://sakuratears.cn/post-images/1607838820563.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sakuratears.cn/post-images/1607838826179.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第三道水题：路径之和，没仔细看题是到叶子结点的距离WA了一发&lt;br&gt;
&lt;img src=&#34;https://sakuratears.cn/post-images/1607845910595.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
第四道：填充每个节点的下一个右侧节点指针&lt;br&gt;
感觉不是很难，但是想了很长时间，&lt;s&gt;可能是困的&lt;/s&gt;&lt;br&gt;
&lt;img src=&#34;https://sakuratears.cn/post-images/1607850506115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1212&#34;&gt;12/12&lt;/h3&gt;
&lt;p&gt;今日做题：从前序与中序遍历序列构造二叉树&lt;br&gt;
和昨天题基本相同，因为没思考照抄昨天代码WA一发&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_YKK2ZFll5b.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后水一发前序遍历，后序遍历。&lt;br&gt;
然后是二叉树的层序遍历&lt;br&gt;
这题用BFS思路很简单&lt;br&gt;
&lt;img src=&#34;https://sakuratears.cn/post-images/1607763916321.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
姜子牙挺好看，从动画效果来看国漫已经很强了，甚至不输日漫，但是这个剧情0.0，有点不太行&lt;/p&gt;
&lt;h3 id=&#34;1211&#34;&gt;12/11&lt;/h3&gt;
&lt;p&gt;今日做题：从中序与后序遍历序列构造二叉树&lt;br&gt;
难度：Medium&lt;br&gt;
掌握了三种遍历方法这个题不算复杂。没考虑左或右空了的情况WA了一发。&lt;br&gt;
不会用vector的切片导致这道题浪费大量时间。&lt;br&gt;
没弄清楚C++的构造函数弄出来的空指针浪费大量时间。&lt;br&gt;
总体来看还算轻松&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_fs9F1heOwA.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1210&#34;&gt;12/10&lt;/h3&gt;
&lt;p&gt;今日做题：对称二叉树&lt;br&gt;
难度：Easy&lt;br&gt;
做了半天，动态数组，静态数组，队列都用过了，还是不好处理空指针问题，还是用递归好处理&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_Yr4zHVXkCu.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后水一道二叉树中序遍历，这应该是我有史以来做leetcode最快的一次&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_Ui69vsVsk0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1209&#34;&gt;12/09&lt;/h3&gt;
&lt;p&gt;今日做题：平衡二叉树&lt;br&gt;
难度：Easy&lt;br&gt;
学会了二叉树的框架做二叉树的题确实简单很多。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_5oMdVu3xhq.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1208&#34;&gt;12/08&lt;/h3&gt;
&lt;p&gt;今日做题：二叉树中的最大路径和&lt;br&gt;
难度：Hard&lt;br&gt;
思路大概就是二叉树的后序遍历，DFS&lt;br&gt;
我估计要是不看二叉树的框架我得做上一阵子，laluladong永远滴神！！！&lt;br&gt;
的确用二叉树的思想来做递归题清晰很多&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_NBCfNuqIMe.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1207&#34;&gt;12/07&lt;/h3&gt;
&lt;p&gt;今日水题：杨辉三角0.0&lt;br&gt;
本来不想水这个题，没啥意义，但是可恶的web作业逼我不得不放弃leetcode写web&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_jh7Ksgpvtc.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1206&#34;&gt;12/06&lt;/h3&gt;
&lt;p&gt;今日水题1：整数反转&lt;br&gt;
简单题，但是挺多地方爆int，多注意一下方可过题&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_VOi7eJIxTP.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
今日水题2：字符串转换整数 (atoi)&lt;br&gt;
也不难，和上题一样，各种问题0.0，真是给我恶心到了&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_W7OK5HQTq7.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1205&#34;&gt;12/05&lt;/h3&gt;
&lt;p&gt;把大多数文章排版了一下，都怪这markdown的换行还要加&lt;br&gt;😑&lt;br&gt;
今日水题：Z 字形变换&lt;br&gt;
看到这题标签没写任何算法，我就开始徒手暴力拆家。然后.......&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_VdGDBQfZm5.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后一个用例1288ms过了，当一道题不涉及算法时，我的代码就开始不优美了&lt;s&gt;虽然本来也不优美😒&lt;/s&gt;&lt;br&gt;
这么一道水题给我整这么半天.&lt;br&gt;
学习一下大佬的们代码&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_mwqB7RYZdm.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
论学习别人代码&lt;s&gt;和一个好的脑子&lt;/s&gt;的重要性&lt;/p&gt;
&lt;h3 id=&#34;1204&#34;&gt;12/04&lt;/h3&gt;
&lt;p&gt;今日水题：寻找两个正序数组的中位数，极其简单0.0，力扣的难度标签一直就很离谱&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/%E6%88%AA%E5%9B%BE%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20201204145131.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
外加一道动态规划的题，前一阵子我记得还看过动态规划，然后就不会状态转移了0.0，还好，经过不懈的努力&lt;s&gt;抄答案&lt;/s&gt;终于给过了&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/%E6%88%AA%E5%9B%BE%E5%BD%95%E5%B1%8F_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20201204201004.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1203&#34;&gt;12/03&lt;/h3&gt;
&lt;p&gt;上午简单复习一下数据结构，树和图基本复习完了。&lt;br&gt;
图也没啥东西，依旧是存储，遍历，BFS DFS，最短路径(迪杰斯特拉)，最小生成树(普利姆)(克鲁斯卡尔)，拓扑排序。也没啥了。然后考试森林转二叉树就忘了，还好做对了&lt;s&gt;蒙对了&lt;/s&gt;。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201203205112.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
接着撸算法&lt;br&gt;
撸一道并查集的题，并查集这个算法听着是真有点高大上&lt;s&gt;主要是简单&lt;/s&gt;，并查集的优化确实很优美0.0&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/0.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1202&#34;&gt;12/02&lt;/h3&gt;
&lt;p&gt;学习了一下并查集算法，这个算法还是挺友好的。不优化复杂度O(n),经过合并优化查找优化复杂度O(log2n)&lt;s&gt;不会latex的菜鸡&lt;/s&gt;&lt;br&gt;
代码过几天再写吧，复习一下数据结构&lt;br&gt;
树基本上看完了，感觉也没多少东西，存储，遍历，哈弗曼树回溯。也没啥了&lt;/p&gt;
&lt;h3 id=&#34;1201&#34;&gt;12/01&lt;/h3&gt;
&lt;p&gt;今天又是被js折磨的一天，前端真是究极折磨王啊，（&lt;s&gt;看来选安卓是对的&lt;/s&gt;），然后又是一天没咋学习，12的开头不太行啊。&lt;br&gt;
准备准备算法，迎接一下应该是我的最后一次比赛了。加油！&lt;/p&gt;
&lt;h2 id=&#34;11&#34;&gt;11&lt;/h2&gt;
&lt;h3 id=&#34;1130&#34;&gt;11/30&lt;/h3&gt;
&lt;p&gt;11月的最后一天．也愿天堂没有文本框和........&lt;s&gt;乌迪尔?&lt;/s&gt;&lt;br&gt;
终于连抄带改把js整完了，这玩意真.....无语&lt;br&gt;
汇编看得有点慢，还差100页，争取一个星期看完吧，时间实在是太紧了&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/0.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
有一说一，deepin的bug是有点多0.0&lt;/p&gt;
&lt;h3 id=&#34;1129&#34;&gt;11/29&lt;/h3&gt;
&lt;p&gt;挺好一周日放假有没咋学习．上午LOL．下午睡觉＋数据结构作业，普利姆算法看了半天，还是写不出来代码(&lt;s&gt;一定是最近学汇编导致的&lt;/s&gt;)，寒假之前还得补补数据结构，本以为今天不会再写代码了，没想到晚上给我来个Ｃ的大作业．&lt;s&gt;我人傻了&lt;/s&gt;0.0&lt;/p&gt;
&lt;h3 id=&#34;1128&#34;&gt;11/28&lt;/h3&gt;
&lt;p&gt;挺好一下午没咋学习.由于Ubuntu安装软件实在麻烦(typora!!!),QQ微信也不方便,终于,折腾半天还是换了deepin.有一说一deepin做的真的好,完全可以当做日常使用系统,win10就当LOL启动器了😙.&lt;br&gt;
人生苦短,我选deepin!&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/screenFetch-2020-11-29_13-20-11.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1127&#34;&gt;11/27&lt;/h3&gt;
&lt;p&gt;开始记录学习的生活，争取早日成为大佬！&lt;/p&gt;
">记录学习的日子</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin/"" data-c="
          &lt;h4 id=&#34;题目&#34;&gt;题目&lt;/h4&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;br&gt;
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;
输入: [7,1,5,3,6,4]&lt;br&gt;
输出: 7&lt;br&gt;
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 2:&lt;br&gt;
输入: [1,2,3,4,5]&lt;br&gt;
输出: 4&lt;br&gt;
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例 3:&lt;br&gt;
输入: [7,6,4,3,1]&lt;br&gt;
输出: 0&lt;br&gt;
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;1 &amp;lt;= prices.length &amp;lt;= 3 * 10 ^ 4&lt;br&gt;
0 &amp;lt;= prices[i] &amp;lt;= 10 ^ 4&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&#34;思路&#34;&gt;思路&lt;/h4&gt;
&lt;p&gt;第一天买入，第三天卖出的利润是prices[3] - prices[1],也就是(prices[3] - prices[2]) + (prices[2] - porces[1])&lt;br&gt;
可以发现，我们需要收集每天的正利润就可以，收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润就可以了，不需要记录区间。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是贪心所贪的地方，只收集正利润。&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/1604803105-SzWZhG-122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;代码&#34;&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) {
        int result = 0;
        for (int i = 1; i &amp;lt; prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;思路借鉴作者：carlsun-2&lt;br&gt;
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/122-mai-mai-gu-piao-de-zui-jia-shi-ji-iitan-xin-xi/&lt;br&gt;
来源：力扣（LeetCode）&lt;/p&gt;
">买卖股票的最佳时机 II(贪心)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/ccru-he-chuan-di-er-wei-shu-zu/"" data-c="
          &lt;p&gt;一般传递二维数组的基本规则好像是这样的：可以用二维数组名作为实参或者形参，在被调用函数中对形参数组定义时可以可以指定所有维数的大小，也可以省略第一维的大小说明。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;如：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void Func(int array[3][10]);

void Func(int array[][10]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
​&lt;/p&gt;
&lt;p&gt;二者都是合法而且等价，但是不能把第二维或者更高维的大小省略，如下面的定义是不合法的：&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void Func(int array[][]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
将二维数组当作参数的时候，必须指明所有维数大小或者省略第一维的，但是不能省略第二维或者更高维的大小，这是由编译器原理限制的。在学编译原理这么课程的时候知道编译器是这样处理数组的：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;对于数组 int p[m][n]; 如果要取p[i][j]的值(i&amp;gt;=0 &amp;amp;&amp;amp; i&amp;lt;m &amp;amp;&amp;amp; 0&amp;lt;=j &amp;amp;&amp;amp; j &amp;lt; n)，编译器是这样寻址的，它的地址为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;p + i*n + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;从以上可以看出，如果我们省略了第二维或者更高维的大小，编译器将不知道如何正确的寻址。但是我们在编写程序的时候却需要用到各个维数都不固定的二维数组作为参数，这就难办了，编译器不能识别阿，怎么办呢？不要着急，编译器虽然不能识别，但是我们完全可以不把它当作一个二维数组，而是把它当作一个普通的指针，再另外加上两个参数指明各个维数，然后我们为二维数组手工寻址，这样就达到了将二维数组作为函数的参数传递的目的，根据这个思想，我们可以把维数固定的参数变为维数随即的参数，例如：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void Func(int array[3][10]); 

void Func(int array[][10]);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;变为：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void Func(int **array, int m, int n);
&lt;/code&gt;&lt;/pre&gt;
&lt;br&gt;
&lt;p&gt;在转变后的函数中，array[i][j]这样的式子是不对的(不信，大家可以试一下)，因为编译器不能正确的为它寻址，所以我们需要模仿编译器的行为把array[i][j]这样的式子手工转变为&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;*((int*)array + n*i + j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​    &lt;br&gt;&lt;/p&gt;
&lt;p&gt;在调用这样的函数的时候，需要注意一下，如下面的例子：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int a[3][3] = 

    {
{1, 1, 1},
{2, 2, 2},
{3, 3, 3}
};

Func(a, 3, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;根据不同编译器不同的设置，可能出现warning 或者error,可以进行强制转换如下调用：  &lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;Func((int**)a, 3, 3);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;需要(int**）的强制转换，是因为二维数组和二级指针是不同的，a实质上是一个int (&lt;em&gt;a)[3]，它是一个数组指针，即a[0]是第一维数组的首个元素的地址，a[1]是第二维数组的首个元素的地址，a[2]是第三维数组的首个元素的地址，与int*&lt;em&gt;是不同的类型；如果转为int*&lt;/em&gt;，就失去了像数组指针那样a + i = a + i&lt;/em&gt;3的效果了&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;而如果又定义一个char *p[3]，它是一个一维的指针数组，此时p是指向了一个指针，而不是数组。那么这时如果定义char **q = p，就是可以的，而且可以通过q[0]，q[1]来访问字符串。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;数组和指针这种东西真是太繁琐复杂了，个人愚见，在C++里就尽量使用STL，并且可以用模板的非类型形参来解决这种灵活处理不固定行列数矩阵的函数，Effective C++里面应该有介绍，并且有对这种模板的优化。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;转载自CSDN&lt;/p&gt;
">C/C++如何传递二维数组？</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/n-huang-hou/"" data-c="
          &lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/8-queens.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上图为 8 皇后问题的一种解法。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;输入：4&lt;br&gt;
输出：[&lt;br&gt;
[&amp;quot;.Q..&amp;quot;,  // 解法 1&lt;br&gt;
&amp;quot;...Q&amp;quot;,&lt;br&gt;
&amp;quot;Q...&amp;quot;,&lt;br&gt;
&amp;quot;..Q.&amp;quot;],&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;[&amp;quot;..Q.&amp;quot;,  // 解法 2&lt;br&gt;
&amp;quot;Q...&amp;quot;,&lt;br&gt;
&amp;quot;...Q&amp;quot;,&lt;br&gt;
&amp;quot;.Q..&amp;quot;]&lt;br&gt;
]&lt;br&gt;
解释: 4 皇后问题存在两个不同的解法。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/n-queens&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;经典回溯+递归问题，当发现这种情况不行时就回溯到之前的点。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int col[12] = {};//将合适的皇后行数放入数组中
    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; arr;
    vector&amp;lt;string&amp;gt; brr;
    char crr[100][100];
    int cnumber = 0;
    int num, number = 0, jud = 0, tot = 0;
    bool check(int c, int r)
    {
        int i = 0;
        for (i = 0; i &amp;lt; r; i++)
        {
            if (col[i] == c || (abs(col[i] - c) == abs(i - r)))
                return false;
        }
        return true;
    }

    void DFS(int r)
    {
        if (r == num)
        {
            string str = &amp;quot;&amp;quot;;
            brr.clear();
            for (int j = 0; j &amp;lt; num; j++)
            {
                str = &amp;quot;&amp;quot;;
                
                for (int i = 0; i &amp;lt; num; i++)
                {
                    if (crr[j][i] == &#39;Q&#39;)
                        str += &amp;quot;Q&amp;quot;;
                    else
                        str += &amp;quot;.&amp;quot;;
                }
                brr.push_back(str);
            }
            arr.push_back(brr);
            return;
        }
        for (int c = 0; c &amp;lt; num; c++)
        {
            if (check(c, r) == true)
            {
                col[r] = c;
                int i = 0;
                while (i &amp;lt; num)
                {
                    if (i == c)
                    {
                        crr[r][i] = &#39;Q&#39;;
                    }
                    else
                        crr[r][i] = &#39;.&#39;;
                    i++;
                }
                DFS(r + 1);
            }
        }
    }

    vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; solveNQueens(int n)
    {
        num = n;
        DFS(0);
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">N皇后(回溯)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/shui-yu-da-xiao-dfsbfs/"" data-c="
          &lt;p&gt;DFS BFS例题&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/pond-sizes-lcci&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;输入：&lt;br&gt;
[&lt;br&gt;
[0,2,1,0],&lt;br&gt;
[0,1,0,1],&lt;br&gt;
[1,1,0,1],&lt;br&gt;
[0,1,0,1]&lt;br&gt;
]&lt;br&gt;
输出： [1,2,4]&lt;br&gt;
提示：&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;0 &amp;lt; len(land) &amp;lt;= 1000&lt;br&gt;
0 &amp;lt; len(land[i]) &amp;lt;= 1000&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;此题DFS，BFS都可以用。&lt;br&gt;
(代码格式为leetcode模板格式)&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;代码:&lt;/p&gt;
&lt;h5 id=&#34;bfs&#34;&gt;BFS&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int n = 0;
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};//可以斜着所以是8个方向
    struct Node {int x; int y;};
    queue&amp;lt;Node&amp;gt; q;
    int BFS(int i, int j, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; land)
    {
        n = 1;
        Node start, node;
        start.x = i;
        start.y = j;
        land[i][j] = 1;
        q.push(start);
        while (!q.empty()) {
            start = q.front();
            q.pop();
            for (int i = 0; i &amp;lt; 8; i++)
            {
                node.x = start.x + dirs[i][0];
                node.y = start.y + dirs[i][1];
                if (node.x &amp;gt;= 0 &amp;amp;&amp;amp; node.x &amp;lt; land.size() &amp;amp;&amp;amp; node.y &amp;gt;= 0 &amp;amp;&amp;amp; node.y &amp;lt; land[0].size() &amp;amp;&amp;amp; land[node.x][node.y] == 0)//判断是否为鱼塘
                {
                    q.push(node);
                    land[node.x][node.y] = 1;//染色
                    n++;
                }
            }
        }
        return n;
    }

    vector&amp;lt;int&amp;gt; pondSizes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; land) {
        vector&amp;lt;int&amp;gt; arr;
        for (int i = 0; i &amp;lt; land.size(); i++)
        {
            for (int j = 0; j &amp;lt; land[i].size(); j++)
            {
                if (land[i][j] == 0)
                {
                    arr.push_back(BFS(i, j, land));
                }
                else 
                {
                    continue;
                }
            }
        }
        sort(arr.begin(), arr.end());
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h5 id=&#34;dfs&#34;&gt;DFS&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};
    struct Node {int x; int y;};
    
    int DFS(int i, int j, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; land)
    {
        if (i &amp;lt; 0 || i &amp;gt;= land.size() || j &amp;lt; 0 || j &amp;gt;= land[0].size()) return 0;
        if (land[i][j] != 0) return 0;//判断是否为鱼塘
        land[i][j] = 1;//染色
        Node next;
        int n = 1;
        for (int m = 0; m &amp;lt; 8; m++)
        {
            next.x = i + dirs[m][0];
            next.y = j + dirs[m][1];
            n += DFS(next.x, next.y, land);
        }
        return n;
    }

    vector&amp;lt;int&amp;gt; pondSizes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; land) {
        vector&amp;lt;int&amp;gt; arr;
        for (int i = 0; i &amp;lt; land.size(); i++)
        {
            for (int j = 0; j &amp;lt; land[i].size(); j++)
            {
                if (land[i][j] == 0)
                {
                    arr.push_back(DFS(i, j, land));
                }
                else 
                {
                    continue;
                }
            }
        }
        sort(arr.begin(), arr.end());
        return arr;
    }
};
&lt;/code&gt;&lt;/pre&gt;
">水域大小（DFS）（BFS）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/si-shu-zhi-he/"" data-c="
          &lt;h4 id=&#34;题目描述&#34;&gt;题目描述：&lt;/h4&gt;
&lt;p&gt;给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;答案中不可以包含重复的四元组。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。&lt;/p&gt;
&lt;p&gt;满足要求的四元组集合为：&lt;br&gt;
[&lt;br&gt;
[-1,  0, 0, 1],&lt;br&gt;
[-2, -1, 1, 2],&lt;br&gt;
[-2,  0, 0, 2]&lt;br&gt;
]&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;来源：力扣18题（LeetCode）&lt;br&gt;
链接：https://leetcode-cn.com/problems/4sum&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&#34;题目分析&#34;&gt;题目分析&lt;/h4&gt;
&lt;p&gt;此题可以用双指针法解决，先用两个for循环i, j遍历前面，两个指针left, right收缩，当nums[i] + nums[j] + nums[left] + nums[right] == target 时，入数组，然后注意一下去重。（三数之和一个for循环，四数之和用两个，五数之和用三个......）&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&#34;代码题解&#34;&gt;代码题解&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt; &amp;amp;nums, int target)
{
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; re;
    sort(nums.begin(), nums.end());
    for (int i = 0; i &amp;lt; nums.size(); i++)
    {
        if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i - 1])//去重
            continue;
        for (int j = i + 1; j &amp;lt; nums.size(); j++)
        {
            if (j &amp;gt; i + 1 &amp;amp;&amp;amp; nums[j] == nums[j - 1])//去重
                continue;
            int left = j + 1;
            int right = nums.size() - 1;
            while (left &amp;lt; right)
            {
                if (nums[i] + nums[j] + nums[left] + nums[right] &amp;gt; target)
                {
                    right--;
                }
                else if (nums[i] + nums[j] + nums[left] + nums[right] &amp;lt; target)
                {
                    left++;
                }
                else
                {
                    re.push_back(vector&amp;lt;int&amp;gt;{nums[i], nums[j], nums[left], nums[right]});//下面两个循环去重
                    while (right &amp;gt; left &amp;amp;&amp;amp; nums[right] == nums[right - 1])
                    {
                        right--;
                    }
                    while (right &amp;gt; left &amp;amp;&amp;amp; nums[left] == nums[left + 1])
                    {
                        left++;
                    }
                    //找到一个适合的后左右指针收缩
                    left++;
                    right--;
                }
            }
        }
    }
    return re;
}
&lt;/code&gt;&lt;/pre&gt;
">四数之和（双指针）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/pyqt5-zong-jie/"" data-c="
          &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;基本功能&#34;&gt;基本功能&lt;/h1&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from PyQt5.QtWidgets import QApplication, QWidget
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;app = QApplication(sys.argv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每一pyqt5应用程序必须创建一个应用程序对象。sys.argv参数是一个列表，从命令行输入参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w = QWidget()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QWidget部件是pyqt5所有用户界面对象的基类。他为QWidget提供默认构造函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w.resize(250, 250)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;resize方法调整窗口大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w.move(300, 300)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;move方法移动窗口在屏幕的位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w.setWindowTitle(&#39;Simple&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置窗口标题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显示在屏幕上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.setGeometry(300, 300, 300, 300)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置窗口位置和大小&lt;/p&gt;
&lt;h2 id=&#34;图标&#34;&gt;图标&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.setWindowIcon(QIcon(&#39;路径&#39;))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置窗口的图标&lt;/p&gt;
&lt;h2 id=&#34;提示语&#34;&gt;提示语&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from PyQt5.QtWidgets import (QWidget, QToolTip, 
    QPushButton, QApplication)
from PyQt5.QtGui import QFont   
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;QToolTip.setFont(QFont(&#39;SansSerif&#39;, 10))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种静态的方法设置一个用于显示工具提示的字体。我们使用10px滑体字体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.setToolTip(&#39;This is a &amp;lt;b&amp;gt;QWidget&amp;lt;/b&amp;gt; widget&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个提示，我们称之为settooltip()方法。我们可以使用丰富的文本格式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;btn = QPushButton(&#39;Button&#39;, self)
btn.setToolTip(&#39;This is a &amp;lt;b&amp;gt;QPushButton&amp;lt;/b&amp;gt; widget&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个PushButton并为他设置一个tooltip&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;btn.resize(btn.sizeHint())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;btn.sizeHint()为默认尺寸&lt;/p&gt;
&lt;h2 id=&#34;关闭窗口&#34;&gt;关闭窗口&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;qbtn = QPushButton(&#39;Quit&#39;, self)
qbtn.clicked.connect(QCoreApplication.instance().quit)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;消息框&#34;&gt;消息框&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from PyQt5.QtWidgets import QWidget, QMessageBox, QApplication
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def closeEvent(self, event):
        
        reply = QMessageBox.question(self, &#39;Message&#39;,
            &amp;quot;Are you sure to quit?&amp;quot;, QMessageBox.Yes | 
            QMessageBox.No, QMessageBox.No)
 
        if reply == QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关闭窗口是出发QCloseEvent。我们需要重写closeEvent方法&lt;/p&gt;
&lt;h2 id=&#34;窗口显示在屏幕的中间&#34;&gt;窗口显示在屏幕的中间&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#控制窗口显示在屏幕中心的方法    
    def center(self):
        #获得窗口
        qr = self.frameGeometry()
        #获得屏幕中心点
        cp = QDesktopWidget().availableGeometry().center()
        #显示到屏幕中心
        qr.moveCenter(cp)
        self.move(qr.topLeft())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QtGui,QDesktopWidget类提供了用户的桌面信息,包括屏幕大小。&lt;/p&gt;
&lt;h1 id=&#34;布局管理&#34;&gt;布局管理&lt;/h1&gt;
&lt;h2 id=&#34;绝对定位&#34;&gt;绝对定位&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;lbl1 = QLabel(&#39;Zetcode&#39;, self)
lbl1.move(15, 10)
 
lbl2 = QLabel(&#39;tutorials&#39;, self)
lbl2.move(35, 40)
        
lbl3 = QLabel(&#39;for programmers&#39;, self)
lbl3.move(55, 70)        
        
self.setGeometry(300, 300, 250, 150)
self.setWindowTitle(&#39;Absolute&#39;)    
self.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;框布局-boxlayout&#34;&gt;框布局 Boxlayout&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;okButton = QPushButton(&amp;quot;OK&amp;quot;)
cancelButton = QPushButton(&amp;quot;Cancel&amp;quot;)
 
hbox = QHBoxLayout()
hbox.addStretch(1)
hbox.addWidget(okButton)
hbox.addWidget(cancelButton)
 
vbox = QVBoxLayout()
vbox.addStretch(1)
vbox.addLayout(hbox)
        
self.setLayout(vbox)    
        
self.setGeometry(300, 300, 300, 150)
self.setWindowTitle(&#39;Buttons&#39;)    
self.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用QHBoxLayout和QVBoxLayout，来分别创建横向布局和纵向布局。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hbox = QHBoxLayout()
hbox.addStretch(1)
hbox.addWidget(okButton)
hbox.addWidget(cancelButton)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们创建一个水平布局和添加一个伸展因子和两个按钮。两个按钮前的伸展增加了一个可伸缩的空间。这将推动他们靠右显示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;vbox = QVBoxLayout()
vbox.addStretch(1)
vbox.addLayout(hbox)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个垂直布局，并添加伸展因子，让水平布局显示在窗口底部&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.setLayout(vbox)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后,我们设置窗口的布局界面&lt;/p&gt;
&lt;h2 id=&#34;表格布局-qgridlayout&#34;&gt;表格布局 QGridLayout&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grid = QGridLayout()
self.setLayout(grid)

names = [&#39;Cls&#39;, &#39;Bck&#39;, &#39;&#39;, &#39;Close&#39;,
          &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;/&#39;,
           &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;*&#39;,
          &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;-&#39;,
             &#39;0&#39;, &#39;.&#39;, &#39;=&#39;, &#39;+&#39;]

 positions = [(i, j) for i in range(5) for j in range(4)]

  for position, name in zip(positions, names):

       if name == &#39;&#39;:
            continue
        button = QPushButton(name)
        grid.addWidget(button, *position)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grid = QGridLayout()
self.setLayout(grid)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QGridLayout的实例被创建并设置应用程序窗口的布局。&lt;/p&gt;
&lt;p&gt;names列表为这些按钮的标签&lt;/p&gt;
&lt;h2 id=&#34;评论的例子&#34;&gt;评论的例子&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def initUI(self):

    title = QLabel(&#39;Title&#39;)
    author = QLabel(&#39;Author&#39;)
    review = QLabel(&#39;Review&#39;)

    titleEdit = QLineEdit()
    authorEdit = QLineEdit()
    reviewEdit = QTextEdit()

    grid = QGridLayout()
    grid.setSpacing(10)

    grid.addWidget(title, 1, 0)
    grid.addWidget(titleEdit, 1, 1)

    grid.addWidget(author, 2, 0)
    grid.addWidget(authorEdit, 2, 1)

    grid.addWidget(review, 3, 0)
    grid.addWidget(reviewEdit, 3, 1, 5, 1)

    self.setLayout(grid)

    self.setGeometry(300, 300, 350, 300)
    self.setWindowTitle(&#39;Review&#39;)
    self.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们创建一个窗口,其中有三个标签,两个行编辑和一个文本编辑窗口小控件。然后使用QGridLayout完成布局。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grid = QGridLayout()
grid.setSpacing(10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个网格布局和设置组件之间的间距。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grid.addWidget(reviewEdit, 3, 1, 5, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在添加一个小的控件到网格的时候,我们可以提供小部件的行和列跨。在例子中,reviewEdit控件跨度5行。&lt;/p&gt;
&lt;h1 id=&#34;菜单和工具栏&#34;&gt;菜单和工具栏&lt;/h1&gt;
&lt;h2 id=&#34;状态栏&#34;&gt;状态栏&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def initUI(self):

    self.statusBar().showMessage(&#39;Ready&#39;)

    self.setGeometry(300, 300, 250, 150)
    self.setWindowTitle(&#39;Statusbar&#39;)
    self.show()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用QMainWindow创建状态栏的小窗口&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.statusBar().showMessage(&#39;Ready&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QMainWindow类第一次调用statusBar()方法创建一个状态栏。后续调用返回的状态栏对象。showMessage()状态栏上显示一条消息。&lt;/p&gt;
&lt;h2 id=&#34;菜单栏&#34;&gt;菜单栏&lt;/h2&gt;
&lt;p&gt;菜单栏是常见的窗口应用程序的一部分。(Mac OS将菜单条不同。得到类似的结果,我们可以添加以下行:menubar.setNativeMenuBar(假)。)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def initUI(self):

    exitAction = QAction(QIcon(&#39;exit.png&#39;), &#39;&amp;amp;Exit&#39;, self)
    exitAction.setShortcut(&#39;Ctrl+Q&#39;)
    exitAction.setStatusTip(&#39;Exit application&#39;)
    exitAction.triggered.connect(qApp.quit)

    self.statusBar()

    # 创建一个菜单栏
    menubar = self.menuBar()
    # 添加菜单
    fileMenu = menubar.addMenu(&#39;&amp;amp;File&#39;)
    # 添加事件
    fileMenu.addAction(exitAction)

    self.setGeometry(300, 300, 300, 200)
    self.setWindowTitle(&#39;Menubar&#39;)
    self.show()

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;exitAction = QAction(QIcon(&#39;exit.png&#39;), &#39;&amp;amp;Exit&#39;, self)        
exitAction.setShortcut(&#39;Ctrl+Q&#39;)
exitAction.setStatusTip(&#39;Exit application&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;QAction可以操作菜单栏,工具栏,或自定义键盘快捷键。上面三行,我们创建一个事件和一个特定的图标和一个“退出”的标签。然后,在定义该操作的快捷键。&lt;br&gt;
第三行创建一个鼠标指针悬停在该菜单项上时的提示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;exitAction.triggered.connect(qApp.quit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当我们点击菜单的时候，调用qApp.quit,终止应用程序。&lt;/p&gt;
&lt;h2 id=&#34;工具栏&#34;&gt;工具栏&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def initUI(self):

    exitAction = QAction(QIcon(&#39;exit24.png&#39;), &#39;Exit&#39;, self)
    exitAction.setShortcut(&#39;Ctrl+Q&#39;)
    exitAction.triggered.connect(qApp.quit)

    self.toolbar = self.addToolBar(&#39;Exit&#39;)
    self.toolbar.addAction(exitAction)

    self.setGeometry(300, 300, 300, 200)
    self.setWindowTitle(&#39;Toolbar&#39;)
    self.show()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在上面的例子中,我们创建一个简单的工具栏。工具栏有有一个按钮,点击关闭窗口。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;exitAction = QAction(QIcon(&#39;exit24.png&#39;), &#39;Exit&#39;, self)
exitAction.setShortcut(&#39;Ctrl+Q&#39;)
exitAction.triggered.connect(qApp.quit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似于上面的菜单栏的例子,我们创建一个QAction事件。该事件有一个标签、图标和快捷键。退出窗口的方法&lt;/p&gt;
&lt;h2 id=&#34;把他们放在一起&#34;&gt;把他们放在一起&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
from PyQt5.QtWidgets import QMainWindow, QTextEdit, QAction, QApplication
from PyQt5.QtGui import QIcon
 
 
class Example(QMainWindow):
    
    def __init__(self):
        super().__init__()
        
        self.initUI()
        
        
    def initUI(self):               
        
        textEdit = QTextEdit()
        self.setCentralWidget(textEdit)
 
        exitAction = QAction(QIcon(&#39;exit24.png&#39;), &#39;Exit&#39;, self)
        exitAction.setShortcut(&#39;Ctrl+Q&#39;)
        exitAction.setStatusTip(&#39;Exit application&#39;)
        exitAction.triggered.connect(self.close)
 
        self.statusBar()
 
        menubar = self.menuBar()
        fileMenu = menubar.addMenu(&#39;&amp;amp;File&#39;)
        fileMenu.addAction(exitAction)
 
        toolbar = self.addToolBar(&#39;Exit&#39;)
        toolbar.addAction(exitAction)
        
        self.setGeometry(300, 300, 350, 250)
        self.setWindowTitle(&#39;Main window&#39;)    
        self.show()
        
        
if __name__ == &#39;__main__&#39;:
    
    app = QApplication(sys.argv)
    ex = Example()
    sys.exit(app.exec_())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;textEdit = QTextEdit()
self.setCentralWidget(textEdit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们创建了一个QTextEdit,并把他设置为窗口的布局&lt;/p&gt;
">PyQt5总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/python-shi-xian-tu-pian-zhuan-zi-fu-hua/"" data-c="
          &lt;p&gt;首先，安装 Python 图像处理库 pillow（PIL）&lt;br&gt;
argparse是 Python 标准库中推荐的命令行解析模块。&lt;br&gt;
具体方法可以查看官方文档是 https://docs.python.org/zh-cn/3/howto/argparse.html&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# -*- coding=utf-8 -*-

from PIL import Image
import argparse

#命令行输入参数处理
parser = argparse.ArgumentParser()

parser.add_argument(&#39;file&#39;)     #输入文件
parser.add_argument(&#39;-o&#39;, &#39;--output&#39;)   #输出文件
parser.add_argument(&#39;--width&#39;, type = int, default = 80) #输出字符画宽
parser.add_argument(&#39;--height&#39;, type = int, default = 80) #输出字符画高

#获取参数
args = parser.parse_args()

IMG = args.file
WIDTH = args.width
HEIGHT = args.height
OUTPUT = args.output

ascii_char = list(&amp;quot;$@B%8&amp;amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&amp;lt;&amp;gt;i!lI;:,\&amp;quot;^`&#39;. &amp;quot;)

# 将256灰度映射到70个字符上
def get_char(r,g,b,alpha = 256):
    if alpha == 0:
        return &#39; &#39;
    length = len(ascii_char)
    gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b)

    unit = (256.0 + 1)/length
    return ascii_char[int(gray/unit)]

if __name__ == &#39;__main__&#39;:

    # 打开并调整图片的宽和高
    im = Image.open(IMG)
    im = im.resize((WIDTH,HEIGHT), Image.NEAREST)

    # 初始化输出的字符串
    txt = &amp;quot;&amp;quot;

    # 遍历图片中的每一行
    for i in range(HEIGHT):
        # 遍历该行中的每一列
        for j in range(WIDTH):
            # 将 (j,i) 坐标的 RGB 像素转为字符后添加到 txt 字符串
            txt += get_char(*im.getpixel((j,i)))
        # 遍历完一行后需要增加换行符
        txt += &#39;\n&#39;
    # 输出到屏幕
    print(txt)

    # 字符画输出到文件
    if OUTPUT:
        with open(OUTPUT,&#39;w&#39;) as f:
            f.write(txt)
    else:
        with open(&amp;quot;output.txt&amp;quot;,&#39;w&#39;) as f:
            f.write(txt)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用图片https://labfile.oss.aliyuncs.com/courses/370/ascii_dora.png&lt;br&gt;
在命令行使用命令&lt;br&gt;
&lt;code&gt;python ascii.py ascii_dora.png&lt;/code&gt;&lt;br&gt;
效果：&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/notepad_DvSgM1djjf.png&#34; alt=&#34;效果图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Python实现图片转字符画</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/python-jie-jue-yong-pip-zhuang-di-san-fang-ku-man-de-fang-fa/"" data-c="
          &lt;p&gt;由于政策原因使用pip(pycharm也是)装第三方库有时会很慢有时会失败，有条件的可以使用不可描述方法进行安装或者我们可以使用清华源镜像装库&lt;br&gt;
链接https://mirrors.tuna.tsinghua.edu.cn/help/pypi/&lt;/p&gt;
&lt;!-- more --&gt;">Python解决用pip装第三方库慢的方法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;在使用一段时间hexo后还是放弃了hexo选择了简单方便的Gridea（其实就是不会用hexo）&lt;/p&gt;
&lt;h2 id=&#34;关于博主&#34;&gt;👨‍💻 关于博主&lt;/h2&gt;
&lt;p&gt;一枚啥也不会的菜鸡程序猿&lt;br&gt;
主攻Java开发，Android开发（狗头保命！）&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;QQ：2538598846&lt;br&gt;
微信：2538598846&lt;br&gt;
欢迎好友交流😎&lt;/p&gt;
">奇妙的自我描述</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/kmp-suan-fa/"" data-c="
          &lt;p&gt;KMP算法是一种&lt;strong&gt;字符串匹配&lt;/strong&gt;算法，可以在 O(n+m) 的时间复杂度内实现两个字符串的匹配。本文将引导您学习KMP算法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;本文转载自知乎“洛谷网校 阮行止”&lt;/p&gt;
&lt;p&gt;网址：https://www.zhihu.com/question/21923021/answer/1032665486?utm_source=qq&amp;amp;utm_medium=social&amp;amp;utm_oi=952480495343259648&lt;/p&gt;
&lt;h4 id=&#34;字符串匹配问题&#34;&gt;字符串匹配问题&lt;/h4&gt;
&lt;p&gt;所谓字符串匹配，是这样一种问题：“字符串 P 是否为字符串 S 的子串？如果是，它出现在 S 的哪些位置？” 其中 S 称为&lt;strong&gt;主串&lt;/strong&gt;；P 称为&lt;strong&gt;模式串&lt;/strong&gt;。下面的图片展示了一个例子。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/v2-2967e415f490e03a2a9400a92b185310_r.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;主串是莎翁那句著名的 “to be or not to be”，这里删去了空格。“no” 这个模式串的匹配结果是“出现了一次，从S[6]开始”；“ob”这个模式串的匹配结果是“出现了两次，分别从s[1]、s[10]开始”。按惯例，主串和模式串都以0开始编号。&lt;br&gt;
　　字符串匹配是一个非常频繁的任务。例如，今有一份名单，你急切地想知道自己在不在名单上；又如，假设你拿到了一份文献，你希望快速地找到某个关键字（keyword）所在的章节……凡此种种，不胜枚举。&lt;br&gt;
　　我们先从最朴素的Brute-Force算法开始讲起。&lt;/p&gt;
&lt;h4 id=&#34;brute-force&#34;&gt;Brute-Force&lt;/h4&gt;
&lt;p&gt;顾名思义，Brute-Force是一个纯暴力算法。说句题外话，我怀疑，“暴力”一词在算法领域表示“穷举、极低效率的实现”，可能就是源于这个英文词。&lt;br&gt;
　　首先，我们应该如何实现两个字符串 A,B 的比较？所谓&lt;strong&gt;字符串比较&lt;/strong&gt;，就是问“两个字符串是否相等”。最朴素的思想，就是从前往后逐字符比较，一旦遇到不相同的字符，就返回False；如果两个字符串都结束了，仍然没有出现不对应的字符，则返回True。实现如下：&lt;br&gt;
&lt;img src=&#34;https://pic2.zhimg.com/80/v2-f9a7d55f60e346529f70c409dfcda786_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然我们可以知道“两个字符串是否相等”，那么最朴素的字符串匹配算法 Brute-Force 就呼之欲出了——&lt;br&gt;
· 枚举 i = 0, 1, 2 ... , len(S)-len(P)&lt;br&gt;
· 将 S[i : i+len(P)] 与 P 作比较。如果一致，则找到了一个匹配。&lt;/p&gt;
&lt;p&gt;现在我们来模拟 Brute-Force 算法，对主串 “AAAAAABC” 和模式串 “AAAB” 做匹配：&lt;br&gt;
&lt;img src=&#34;https://pic3.zhimg.com/80/v2-1892c7f6bee02e0fc7baf22aaef7151f_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这是一个清晰明了的算法，实现也极其简单。下面给出Python和C++的实现：&lt;br&gt;
&lt;img src=&#34;https://pic4.zhimg.com/80/v2-36589bc0279263ec8641a295aea66a0c_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://pic4.zhimg.com/80/v2-ed28c8d60516720cc38c48d135091a58_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们成功实现了 Brute-Force 算法。现在，我们需要对它的时间复杂度做一点讨论。按照惯例，记 n = |S| 为串 S 的长度，m = |P| 为串 P 的长度。&lt;br&gt;
　　考虑“字符串比较”这个小任务的复杂度。最坏情况发生在：两个字符串唯一的差别在最后一个字符。这种情况下，字符串比较必须走完整个字符串，才能给出结果，因此复杂度是 O(len) 的。&lt;/p&gt;
&lt;p&gt;由此，不难想到 Brute-Force 算法所面对的最坏情况：主串形如“AAAAAAAAAAA...B”，而模式串形如“AAAAA...B”。每次字符串比较都需要付出 |P| 次字符比较的代价，总共需要比较 |S| - |P| + 1次，因此总时间复杂度是  &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28%7CP%7C%5Ccdot+%28%7CS%7C+-+%7CP%7C+%2B+1%29+%29&#34; alt=&#34;[公式]&#34; loading=&#34;lazy&#34;&gt; . 考虑到主串一般比模式串长很多，故 Brute-Force 的复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28%7CP%7C+%5Ccdot+%7CS%7C%29&#34; alt=&#34;[公式]&#34; loading=&#34;lazy&#34;&gt; ，也就是 O(nm)的。这太慢了！&lt;/p&gt;
&lt;h4 id=&#34;brute-force的改进思路&#34;&gt;Brute-Force的改进思路&lt;/h4&gt;
&lt;p&gt;经过刚刚的分析，您已经看到，Brute-Force 慢得像爬一样。它最坏的情况如下图所示：&lt;br&gt;
&lt;img src=&#34;https://pic4.zhimg.com/80/v2-4fe5612ff13a6286e1a8e50a0b06cd96_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们很难降低字符串比较的复杂度（因为比较两个字符串，真的只能逐个比较字符）。因此，我们考虑&lt;strong&gt;降低比较的趟数&lt;/strong&gt;。如果比较的趟数能降到足够低，那么总的复杂度也将会下降很多。　　要优化一个算法，首先要回答的问题是“我手上有什么信息？”　我们手上的信息是否足够、是否有效，决定了我们能把算法优化到何种程度。请记住：&lt;strong&gt;尽可能利用残余的信息，是KMP算法的思想所在&lt;/strong&gt;。&lt;br&gt;
　　在 Brute-Force 中，如果从 S[i] 开始的那一趟比较失败了，算法会直接开始尝试从 S[i+1] 开始比较。这种行为，属于典型的“没有从之前的错误中学到东西”。我们应当注意到，一次失败的匹配，会给我们提供宝贵的信息——如果 S[i : i+len(P)] 与 P 的匹配是在第 r 个位置失败的，那么从 S[i] 开始的 (r-1) 个连续字符，一定与 P 的前 (r-1) 个字符一模一样！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-7dc61b0836af61e302d9474eeeecfe83_720w.jpg?source=1940ef5c&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;需要实现的任务是“字符串匹配”，而每一次失败都会给我们换来一些信息——能告诉我们，主串的某一个子串等于模式串的某一个前缀。但是这又有什么用呢？&lt;/p&gt;
&lt;h4 id=&#34;跳过不可能成功的字符串比较&#34;&gt;跳过不可能成功的字符串比较&lt;/h4&gt;
&lt;p&gt;有些趟字符串比较是有可能会成功的；有些则毫无可能。我们刚刚提到过，优化 Brute-Force 的路线是“尽量减少比较的趟数”，而如果我们跳过那些&lt;strong&gt;绝不可能成功的&lt;/strong&gt;字符串比较，则可以希望复杂度降低到能接受的范围。&lt;br&gt;
　　那么，哪些字符串比较是不可能成功的？来看一个例子。已知信息如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式串 P = &amp;quot;abcabd&amp;quot;.&lt;/li&gt;
&lt;li&gt;和主串从S[0]开始匹配时，在 P[5] 处失配。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/50/v2-372dc6c567ba53a1e4559fdb0cb6b206_hd.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;首先，利用上一节的结论。既然是在 P[5] 失配的，那么说明 S[0:5] 等于 P[0:5]，即&amp;quot;abcab&amp;quot;. 现在我们来考虑：从 S[1]、S[2]、S[3] 开始的匹配尝试，有没有可能成功？&lt;br&gt;
　　从 S[1] 开始肯定没办法成功，因为 S[1] = P[1] = &#39;b&#39;，和 P[0] 并不相等。从 S[2] 开始也是没戏的，因为 S[2] = P[2] = &#39;c&#39;，并不等于P[0]. 但是从 S[3] 开始是有可能成功的——至少按照已知的信息，我们推不出矛盾。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/50/v2-67dd66b86323d3d08f976589cf712a1a_hd.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;带着“跳过不可能成功的尝试”的思想，我们来看next数组。&lt;/p&gt;
&lt;h4 id=&#34;next数组&#34;&gt;next数组&lt;/h4&gt;
&lt;p&gt;next数组是对于模式串而言的。P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i] 这一个子串，使得 &lt;strong&gt;前k个字符&lt;/strong&gt;恰等于&lt;strong&gt;后k个字符&lt;/strong&gt; 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-49c7168b5184cc1744459f325e426a4a_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上图给出了一个例子。P=&amp;quot;abcabd&amp;quot;时，next[4]=2，这是因为P[0] ~ P[4] 这个子串是&amp;quot;abcab&amp;quot;，前两个字符与后两个字符相等，因此next[4]取2. 而next[5]=0，是因为&amp;quot;abcabd&amp;quot;找不到前缀与后缀相同，因此只能取0.&lt;/p&gt;
&lt;p&gt;如果把模式串视为一把标尺，在主串上移动，那么 Brute-Force 就是每次失配之后只右移一位；改进算法则是&lt;strong&gt;每次失配之后，移很多位&lt;/strong&gt;，跳过那些不可能匹配成功的位置。但是该如何确定要移多少位呢？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-d6c6d433813595dce5aad08b40dc0b72_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在 S[0] 尝试匹配，失配于 S[3] &amp;lt;=&amp;gt; P[3] 之后，我们直接把模式串往右移了两位，让 S[3] 对准 P[1]. 接着继续匹配，失配于 S[8] &amp;lt;=&amp;gt; P[6], 接下来我们把 P 往右平移了三位，把 S[8] 对准 P[3]. 此后继续匹配直到成功。&lt;br&gt;
　　我们应该如何移动这把标尺？&lt;strong&gt;很明显，如图中蓝色箭头所示，旧的后缀要与新的前缀一致&lt;/strong&gt;（如果不一致，那就肯定没法匹配上了）！&lt;/p&gt;
&lt;p&gt;回忆next数组的性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，&lt;strong&gt;前next[r-1]个字符恰好和后next[r-1]个字符相等&lt;/strong&gt;——也就是说，我们可以拿长度为 next[r-1] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去！&lt;br&gt;
　　您可以验证一下上面的匹配例子：P[3]失配后，把P[next[3-1]]也就是P[1]对准了主串刚刚失配的那一位；P[6]失配后，把P[next[6-1]]也就是P[3]对准了主串刚刚失配的那一位。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-6ddb50d021e9fa660b5add8ea225383a_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如上图所示，绿色部分是成功匹配，失配于红色部分。深绿色手绘线条标出了相等的前缀和后缀，&lt;strong&gt;其长度为next[右端]&lt;/strong&gt;. 由于手绘线条部分的字符是一样的，所以直接把前面那条移到后面那条的位置。因此说，&lt;strong&gt;next数组为我们如何移动标尺提供了依据&lt;/strong&gt;。接下来，我们实现这个优化的算法。&lt;/p&gt;
&lt;h4 id=&#34;利用next数组进行匹配&#34;&gt;利用next数组进行匹配&lt;/h4&gt;
&lt;p&gt;了解了利用next数组加速字符串匹配的原理，我们接下来代码实现之。分为两个部分：建立next数组、利用next数组进行匹配。&lt;br&gt;
　　首先是建立next数组。我们暂且用最朴素的做法，以后再回来优化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic1.zhimg.com/50/v2-1dda8f33e5847449cd9784e76e972cab_hd.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-1dda8f33e5847449cd9784e76e972cab_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;如上图代码所示，直接根据next数组的定义来建立next数组。不难发现它的复杂度是 &lt;img src=&#34;https://www.zhihu.com/equation?tex=O%28m%5E2%29&#34; alt=&#34;[公式]&#34; loading=&#34;lazy&#34;&gt; 的。&lt;br&gt;
　　接下来，实现利用next数组加速字符串匹配。代码如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/50/v2-a6bd81af7cf9bbda32b2cfb0e4858276_hd.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如何分析这个字符串匹配的复杂度呢？乍一看，pos值可能不停地变成next[pos-1]，代价会很高；但我们使用摊还分析，显然pos值一共顶多自增len(S)次，因此pos值减少的次数不会高于len(S)次。由此，复杂度是可以接受的，不难分析出整个匹配算法的时间复杂度：O(n+m).&lt;/p&gt;
&lt;h4 id=&#34;快速求next数组&#34;&gt;快速求next数组&lt;/h4&gt;
&lt;p&gt;终于来到了我们最后一个问题——如何快速构建next数组。&lt;br&gt;
　　首先说一句：快速构建next数组，是KMP算法的精髓所在，核心思想是“&lt;strong&gt;P自己与自己做匹配&lt;/strong&gt;”。&lt;br&gt;
　　为什么这样说呢？回顾next数组的完整定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。&lt;/li&gt;
&lt;li&gt;next[x] 定义为： P[0]~P[x] 这一段字符串，使得&lt;strong&gt;k-前缀恰等于k-后缀&lt;/strong&gt;的最大的k.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], ... next[x-1]均已知，那么如何求出 next[x] 呢？&lt;/p&gt;
&lt;p&gt;来分情况讨论。首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1. 图示如下。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-6d6a40331cd9e44bfccd27ac5a764618_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;刚刚解决了 P[x] = P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://pic1.zhimg.com/80/v2-ce1d46a1e3603b07a13789b6ece6022f_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如图。长度为 now 的子串 A 和子串 B 是 P[0]~P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该&lt;strong&gt;缩短这个now&lt;/strong&gt;，把它改成小一点的值，再来试试 P[x] 是否等于 P[now].&lt;br&gt;
　　now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]~P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 &lt;strong&gt;A的k-前缀&lt;/strong&gt;等于&lt;strong&gt;B的k-后缀&lt;/strong&gt; 的最大的k.&lt;br&gt;
　　您应该已经注意到了一个非常强的性质——&lt;strong&gt;串A和串B是相同的&lt;/strong&gt;！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://pic2.zhimg.com/80/v2-c5ff4faaab9c3e13690deb86d8d17d71_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;来看上面的例子。当P[now]与P[x]不相等的时候，我们需要缩小now——把now变成next[now-1]，直到P[now]=P[x]为止。P[now]=P[x]时，就可以直接向右扩展了。&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic4.zhimg.com/50/v2-010a582b0c92a92044c43a2a2ea88928_hd.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://pic4.zhimg.com/80/v2-010a582b0c92a92044c43a2a2ea88928_720w.jpg?source=1940ef5c&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;应用摊还分析，不难证明构建next数组的时间复杂度是O(m)的。至此，我们以O(n+m)的时间复杂度，实现了构建next数组、利用next数组进行字符串匹配。&lt;/p&gt;
&lt;p&gt;以上就是KMP算法。它于1977年被提出，全称 Knuth–Morris–Pratt 算法。让我们记住前辈们的名字：&lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Donald_Knuth&#34;&gt;Donald Knuth&lt;/a&gt;(K), &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/James_H._Morris&#34;&gt;James H. Morris&lt;/a&gt;(M), &lt;a href=&#34;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Vaughan_Pratt&#34;&gt;Vaughan Pratt&lt;/a&gt;(P).&lt;/p&gt;
&lt;p&gt;作者：阮行止&lt;br&gt;
链接：https://www.zhihu.com/question/21923021/answer/1032665486&lt;br&gt;
来源：知乎&lt;/p&gt;
">KMP算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/xi-er-pai-xu/"" data-c="
          &lt;p&gt;为了展示初级排序算法性质的价值，接下来我们将学习一种基于插入排序的快速的排序算法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要№1次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。&lt;/p&gt;
&lt;p&gt;实现希尔排序的一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插人排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插人排序但使用不同增量的过程。&lt;/p&gt;
&lt;p&gt;希尔排序为插入排序高级版，先把几个部分的数组用插入排序排好，然后再把这几个分散数组排序成有序数组。&lt;br&gt;
确定一个增量h（h可以是数组总长/3 or /2），每次循环完增量变小直到为1，每次把分散的数组整合成一个大的有序数组，直到增量为1时，整个数组排序完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;void shellsort(int a[], int m)
{
    int h = m / 2; //确定增量h
    for (h; h &amp;gt;= 1; h /= 2) //每次增量变小
    {
        for (int i = h; i &amp;lt; m; i += h)
        {
            for (int j = i; j &amp;gt;= 0 &amp;amp;&amp;amp; j - h &amp;gt;= 0 &amp;amp;&amp;amp; a[j] &amp;lt; a[j - h]; j -= h)
            {
                int temp = a[j];
                a[j] = a[j - h];
                a[j - h] = temp;
            }
        }
    }

    for (int i = 0; i &amp;lt; m; i++)
    {
        cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">希尔排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/kuai-su-pai-xu/"" data-c="
          &lt;p&gt;快速排序的特点是他是原地排序（只需要一个很小的辅助栈），且长度为N的数组时间复杂度为NlgN。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;快速排序是一种分治的算法，他将一个数组分成两个数组，将两部分独立排序，在快排中切分的位置取决于数组的内容。&lt;br&gt;
取首元素为切分元素，比切分元素小的放到左边，比切分元素大的放到右边，再把两个数组切分，最后有序&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/QQ%E5%9B%BE%E7%89%8720201015164728.jpg&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;void qsort(int a[], int lo, int hi)
{
    if (lo &amp;gt;= hi)
        return;
    int i, j, m, temp, mid;
    m = a[lo]; //切分元素
    i = lo; //下面循环时i和j就会先自增/自减1再判断，所以i为头元素，j为尾元素 - 1
    j = hi + 1;
    while (true)
    {
        while (a[++i] &amp;lt; m)
        {
            if (i == hi)//直到循环到右边界也没有找到比切分元素大的元素
                break;
        }
        while (a[--j] &amp;gt; m)
        {
            if (j == lo)//直到循环到左边界也没有找到比切分元素小的元素
                break;
        }
        if (i &amp;gt;= j)//当i的位置在j的右边，a[i] &amp;gt; a[j],不可以交换
            break;
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
    temp = a[lo];
    a[lo] = a[j];
    a[j] = temp;
    mid = j;
    qsort(a, lo, mid - 1);
    qsort(a, mid + 1, hi);
}
&lt;/code&gt;&lt;/pre&gt;
">快速排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/gui-bing-pai-xu/"" data-c="
          &lt;p&gt;归并排序将两个有序的排列归并为一个有序的排列。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;归并算法都基于归并这个简单的操作，即将两个有序的数组归并成一个更大的有序数组。很快人们就根据这个操作发明了一种简单的递归排序算法：归并排序。要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来：你将会看到，归并排序最&lt;br&gt;
吸引人的性质是它能够保证将任意长度为，的数组排序所需时间和，成正比；它的主要缺点则是它所需的额外空间。简单的归并排序如图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_6xnNTxUAow.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;原地归并&#34;&gt;原地归并&lt;/h4&gt;
&lt;p&gt;先创建一个数组aux将a的元素全部赋给aux。然后开始将两个有序的数组归并成一个有序的数组。&lt;br&gt;
将a[lo, mid]和a[mid + 1, hi]两个有序数组归并为一个有序数组&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_1FWin67kuQ.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;void merge(int a[], int lo, int mid, int hi)
{
    int i, j;
    i = lo;
    j = mid + 1;
    int aux[hi + 1];
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        aux[k] = a[k];
    }
    for (int k = lo; k &amp;lt;= hi; k++)
    {
        if (i &amp;gt; mid)
        {
            a[k] = aux[j++];
        }
        else if (j &amp;gt; hi)
        {
            a[k] = aux[i++];
        }
        else if (aux[j] &amp;lt; aux[i])
        {
            a[k] = aux[j++];
        }
        else
        {
            a[k] = aux[i++];
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当左边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑左边元素，直接把右边剩余元素全部赋值给a即可  if(i &amp;gt; mid)&lt;br&gt;
当右边（mid为中界）元素已经全部赋值到a中时，则不需要再考虑右边元素，直接把左边剩余元素全部赋值给a即可  if(j &amp;gt; hi)&lt;br&gt;
如果右边当前元素小于左边当前元素则将右边当前元素赋给a,(aux[j] &amp;lt; aux[i])&lt;br&gt;
右边当前元素大于等于左边当前元素，最后一个else&lt;/p&gt;
&lt;h4 id=&#34;自上向下&#34;&gt;自上向下&lt;/h4&gt;
&lt;p&gt;自顶向下归并将一个数组先中间拆分，再把拆分的数组拆分，直到只有一个元素的数组，然后将每两个数组就行归并。最后归并为一个有序数组。&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_pNM5lWqMZA.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_VlHXNLFh2k.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;void gbsort(int a[], int lo, int hi)
{
    if (hi &amp;lt;= lo)
    {
        return;
    }
    int mid;
    mid = lo + (hi - lo) / 2;
    gbsort(a, lo, mid);
    gbsort(a, mid + 1, hi);
    merge(a, lo, mid, hi);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;自底向上&#34;&gt;自底向上&lt;/h4&gt;
&lt;p&gt;自底向上归并第一次每两个元素的数组归并，然后每四个，八个......归并，最终归并成一个有序数组&lt;br&gt;
&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/FoxitPhantom_3ixOLZEZqD.png&#34; alt=&#34;图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c/c++&#34;&gt;void gbsort(int a[], int lo, int hi)
{
    int n = hi + 1; //n为数组长度
    for (int i = 1; i &amp;lt; n; i += i)//每次循环完了归并前一次翻倍的数组元素个数
    {
        for (int j = 0; j &amp;lt; n - i; j += i * 2)
        {
            if (j + i * 2 - 1 &amp;lt; hi)
            {
                merge(a, j, j + i - 1, j + i * 2 - 1);
            }
            else {
                merge(a, j, j + i - 1, hi);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">归并排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/fu-jin-zhi/"" data-c="
          &lt;h3 id=&#34;题目描述&#34;&gt;题目描述&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/ZSakuraTears/cdn/img/chrome_kZgFEYVhht.png&#34; alt=&#34;洛谷&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;输入格式&#34;&gt;输入格式&lt;/h3&gt;
&lt;p&gt;输入的每行有两个输入数据。&lt;br&gt;
第一个是十进制数 n。 第二个是负进制数的基数 −R。&lt;/p&gt;
&lt;h3 id=&#34;输出格式&#34;&gt;输出格式&lt;/h3&gt;
&lt;p&gt;输出此负进制数及其基数，若此基数超过 10，则参照 16 进制的方式处理。&lt;/p&gt;
&lt;h3 id=&#34;输入输出样例&#34;&gt;输入输出样例&lt;/h3&gt;
&lt;p&gt;输入 3000 -2&lt;br&gt;
输出 30000=11011010101110000(base-2)&lt;br&gt;
输入 -20000 -2&lt;br&gt;
输出 -20000=1111011000100000(base-2)&lt;br&gt;
输入 28800 -16&lt;br&gt;
输出 28800=19180(base-16)&lt;br&gt;
输入 -25000 -16&lt;br&gt;
输出 -25000=7FB8(base-16)&lt;/p&gt;
&lt;h3 id=&#34;说明&#34;&gt;说明&lt;/h3&gt;
&lt;p&gt;【数据范围】&lt;br&gt;
对于 100% 的数据,−20≤R≤−2,∣n∣≤37336。&lt;/p&gt;
&lt;p&gt;NOIp2000提高组第一题&lt;/p&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解：&lt;/h3&gt;
&lt;p&gt;正常情况下-7 % -2 商4 余1&lt;br&gt;
但是C语言（或者说所有语言）这里是商3 余-1&lt;br&gt;
这就很明显了，只需要把商+1，被除数+1就和正常计算情况一样了&lt;/p&gt;
&lt;h4 id=&#34;代码为&#34;&gt;代码为：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

void zh(int a, int b)
{
    if (a == 0) {
        return;
    }
    int m = a % b;
    if (m &amp;lt; 0) {
        m -= b;
        a += b;
    }
    if (m &amp;gt; 9) {
        m = &#39;A&#39; + m - 10;
    }
    else
        m += &#39;0&#39;;
    zh(a / b, b);
    printf(&amp;quot;%c&amp;quot;, m);
}

int main()
{
    int a, b;
    scanf(&amp;quot;%d%d&amp;quot;, &amp;amp;a, &amp;amp;b);
    printf(&amp;quot;%d=&amp;quot;, a);
    zh(a, b);
    printf(&amp;quot;(base%d)&amp;quot;, b);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">负进制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/dai-bei-wang-lu-he-dp-de-di-gui/"" data-c="
          &lt;h4 id=&#34;备忘录算法&#34;&gt;备忘录算法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int helper(vector&amp;lt;int&amp;gt; &amp;amp;m, int n);
int fib(int n);

int fib(int n)
{
    if(n &amp;lt; 1)
    {
        return 0;
    }
    vector&amp;lt;int&amp;gt; m(n + 1, 0);
    return helper(m, n);
}

int helper(vector&amp;lt;int&amp;gt;&amp;amp;m, int n)
{
    if(n == 1 || n == 2) 
    {
        return 1;
    }
    if (m[n] != 0)
    {
        return m[n];
    }
    m[n] = helper(m, n - 1) + helper(m, n - 2);
    return m[n];
} 

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;
    cout &amp;lt;&amp;lt; fib(n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dp数组迭代&#34;&gt;dp数组迭代&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int fib(int n);

int fib(int n)
{
    if(n &amp;lt; 1)
    {
        return 0;
    }
    vector&amp;lt;int&amp;gt; dp(n + 1, 0);
    dp[1] = dp[2] = 1;
    for (int i = 3; i &amp;lt;= n; i++) 
    {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;
    cout &amp;lt;&amp;lt; fib(n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;空间优化&#34;&gt;空间优化&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/c++&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

int fib(int n);

int fib(int n)
{
    if (n == 1 || n == 2)
    {
        return 1;
    }
    int a, b, sum;
    a = b = 1;
    for (int i = 3; i &amp;lt;= n; i++) 
    {
        sum = a + b;
        a = b;
        b = sum;
    }
    return sum;
}

int main()
{
    int n;
    cin &amp;gt;&amp;gt; n;
    cout &amp;lt;&amp;lt; fib(n);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">带备忘录和dp的递归</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/cou-ling-qian-wen-ti/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;limits.h&amp;gt;
#define INT_MAX 2147483647;
using namespace std;

int coinchange(int coin, vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount, vector&amp;lt;int&amp;gt; &amp;amp;bwl) 
{
    if (amount &amp;lt; 0) return -1;
    if (amount == 0) return 0;
    if (bwl[amount] != 0) return bwl[amount];
    int res, i, j, dp = 0, m;
    m = INT_MAX;
    j = 0;
    res = INT_MAX;
    while (j &amp;lt; coin) {
        i = coins[j];
        dp = coinchange(coin, coins, amount - i, bwl);
        if (dp == -1) {
            j++;
            continue;
        }
        if (res &amp;gt; 1 + dp) {
            res = 1 + dp;
        }
        j++;
    }
    if (res != m) {
        bwl[amount] = res;
    }
    else {
        bwl[amount] = -1;
    }
    return bwl[amount];
}

int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) 
{
    int coin = coins.size();
    vector&amp;lt;int&amp;gt; bwl(amount + 1, 0);
    return coinchange(coin, coins, amount, bwl);
}


int main() 
{
    vector&amp;lt;int&amp;gt; coins;
    int a, n, i = 0, amount, m;
    cin &amp;gt;&amp;gt; n;
    coins.clear();
    while (i &amp;lt; n) {
        cin &amp;gt;&amp;gt; a;
        coins.push_back(a);
        i++;
    }
    cin &amp;gt;&amp;gt; amount;
    m = coinChange(coins, amount);
    cout &amp;lt;&amp;lt; m;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;limits.h&amp;gt;
#include &amp;lt;vector&amp;gt;
#define INT_MAX 2147483647;
using namespace std;

int coinChange(vector&amp;lt;int&amp;gt; &amp;amp;coins, int amount)
{
    vector&amp;lt;int&amp;gt; dp(amount + 1, amount + 1);
    dp[0] = 0;
    int i, j;
    for (i = 0; i &amp;lt; dp.size(); i++) 
    {
        for (j = 0; j &amp;lt; coins.size(); j++)
        {
            if (i &amp;lt; coins[j])
            {
                continue;
            }
            if (dp[i] &amp;gt; dp[i - coins[j]]) 
            {
                dp[i] = 1 + dp[i - coins[j]];
            }
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}

int main()
{
    vector&amp;lt;int&amp;gt; coins;
    int a, n, i = 0, amount, m;
    cin &amp;gt;&amp;gt; n;
    coins.clear();
    while (i &amp;lt; n)
    {
        cin &amp;gt;&amp;gt; a;
        coins.push_back(a);
        i++;
    }
    cin &amp;gt;&amp;gt; amount;
    m = coinChange(coins, amount);
    cout &amp;lt;&amp;lt; m;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">凑零钱问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/c-yu-yan-shi-xian-lian-biao-ji-ben-cao-zuo-jiao-huan-di-i-ge-he-di-j-ge-jie-dian/"" data-c="
          &lt;h2 id=&#34;c语言实现链表基本操作交换第i个和第j个节点&#34;&gt;C语言实现链表基本操作（交换第i个和第j个节点）&lt;/h2&gt;
&lt;h3 id=&#34;当i或者j为1时需要让链表的表头指向j&#34;&gt;当i或者j为1时，需要让链表的表头指向j。&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611081240188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70&#34; alt=&#34;开始时&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611081335308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/2020061108140129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611081415319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611081427878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_8,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/
    if (i == 1) { 
        t1 = *L;
        for (m = 1; temp-&amp;gt;Next != NULL; m++, temp = temp-&amp;gt;Next) {
            if (m + 1 == j) {
                *L = temp-&amp;gt;Next;
                t2 = temp-&amp;gt;Next-&amp;gt;Next;
                temp-&amp;gt;Next-&amp;gt;Next = t1-&amp;gt;Next;
                t1-&amp;gt;Next = t2;
                temp-&amp;gt;Next = t1;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;当i和j都不为1时&#34;&gt;当i和j都不为1时。&lt;/h3&gt;
&lt;p&gt;节点相邻与不相邻也是不一样的。&lt;br&gt;
不相邻的情况下就是让i前面的节点指向j，然后让j前面的节点指向i。如果两个节点相邻（假设i &amp;lt; j）j前面的节点就是i，j前面的节点指向i就是指向了自己，所以要分开写。&lt;br&gt;
不相邻节点时：&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611083309796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611083331554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611083418720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611083435638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;if ((i - j) != 1 &amp;amp;&amp;amp; (j- i) != 1) {//非相邻结点之间交换
            for (m = 1; temp-&amp;gt;Next != NULL; m++, temp = temp-&amp;gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m + 1 == j) {
                    t2 = temp;
                }
            }
            t5 = t1-&amp;gt;Next-&amp;gt;Next;
            t3 = t1-&amp;gt;Next;
            t4 = t2-&amp;gt;Next;
            t1-&amp;gt;Next = t4;
            t2-&amp;gt;Next = t3;
            t3-&amp;gt;Next = t4-&amp;gt;Next;
            t4-&amp;gt;Next = t5;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最后一种情况两个节点相邻&#34;&gt;最后一种情况，两个节点相邻：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611084227643.png&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611084240634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611084255116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200611084305639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MDg5ODUw,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
代码为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;for (m = 1; temp != NULL; m++, temp = temp-&amp;gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m == j) {
                    t2 = temp;
                }
            }
            temp = t2-&amp;gt;Next;
            t3 = t1-&amp;gt;Next;
            t1-&amp;gt;Next = t2;
            t3-&amp;gt;Next = temp;
            t2-&amp;gt;Next = t3;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;

typedef struct node
{
    int Score;
    struct node * Next;
}Node, * List;

void Insert(List *L, Node e)
{
    List temp = *L;
    List n = (List)malloc(sizeof(Node));
    n-&amp;gt;Score = e.Score;
    if (temp == NULL) {
        *L = n;
    }
    else {
        while (temp-&amp;gt;Next != NULL) {
            temp = temp-&amp;gt;Next;
        }
        temp-&amp;gt;Next = n;
    }
    n-&amp;gt;Next = NULL;
}

void Swap(List * L, int i, int j)
{
    List temp = *L;
    List t1;
    List t2;
    List t3;
    List t4;
    List t5;
    int m;
    /*i和j为1时情况比较特殊，需要让表头重新指向交换后的那个节点*/
    if (i == 1) { 
        t1 = *L;
        for (m = 1; temp-&amp;gt;Next != NULL; m++, temp = temp-&amp;gt;Next) {
            if (m + 1 == j) {
                *L = temp-&amp;gt;Next;
                t2 = temp-&amp;gt;Next-&amp;gt;Next;
                temp-&amp;gt;Next-&amp;gt;Next = t1-&amp;gt;Next;
                t1-&amp;gt;Next = t2;
                temp-&amp;gt;Next = t1;
            }
        }
    }
    if (j == 1) {
        t1 = *L;
        for (m = 1; temp-&amp;gt;Next != NULL; m++, temp = temp-&amp;gt;Next) {
            if (m + 1 == i) {
                *L = temp-&amp;gt;Next;
                t2 = temp-&amp;gt;Next-&amp;gt;Next;
                temp-&amp;gt;Next-&amp;gt;Next = t1-&amp;gt;Next;
                t1-&amp;gt;Next = t2;
                temp-&amp;gt;Next = t1;
            }
        }
    }
    /*相邻节点之间交换和非相邻结点之间交换不一样*/
    else {
        if ((i - j) != 1 &amp;amp;&amp;amp; (j- i) != 1) {//非相邻结点之间交换
            for (m = 1; temp-&amp;gt;Next != NULL; m++, temp = temp-&amp;gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m + 1 == j) {
                    t2 = temp;
                }
            }
            t5 = t1-&amp;gt;Next-&amp;gt;Next;
            t3 = t1-&amp;gt;Next;
            t4 = t2-&amp;gt;Next;
            t1-&amp;gt;Next = t4;
            t2-&amp;gt;Next = t3;
            t3-&amp;gt;Next = t4-&amp;gt;Next;
            t4-&amp;gt;Next = t5;
        }
        else if (i &amp;lt; j) {//相邻节点之间交换
            for (m = 1; temp != NULL; m++, temp = temp-&amp;gt;Next) {
                if (m + 1 == i) {
                    t1 = temp;
                }
                if (m == j) {
                    t2 = temp;
                }
            }
            temp = t2-&amp;gt;Next;
            t3 = t1-&amp;gt;Next;
            t1-&amp;gt;Next = t2;
            t3-&amp;gt;Next = temp;
            t2-&amp;gt;Next = t3;
        }
        else if (i &amp;gt; j) {
            for (m = 1; temp != NULL; m++, temp = temp-&amp;gt;Next) {
                if (m + 1 == j) {
                    t1 = temp;
                }
                if (m == i) {
                    t2 = temp;
                }
            }
            temp = t2-&amp;gt;Next;
            t3 = t1-&amp;gt;Next;
            t1-&amp;gt;Next = t2;
            t3-&amp;gt;Next = temp;
            t2-&amp;gt;Next = t3;
        }
    }
}

void printflist(List list) 
{
    List temp;
    for (temp = list; temp != NULL; temp = temp-&amp;gt;Next) {
        printf(&amp;quot;%d\n&amp;quot;, temp-&amp;gt;Score);
    }
}

void freelist(List *list)
{
    List temp = *list, del;
    while (temp != NULL) {
        del = temp;
        temp = temp-&amp;gt;Next;
        free(del);
    }
}

int main()
{
    List list = NULL;
    Node n1, n2, n3, n4, e;//定义5个节点
    e.Score = 5;
    n1.Score = 1;
    n2.Score = 2;
    n3.Score = 3;
    n4.Score = 4;
    Insert(&amp;amp;list, n1);
    Insert(&amp;amp;list, n2);
    Insert(&amp;amp;list, n3);
    Insert(&amp;amp;list, n4);
    Insert(&amp;amp;list, e);
    // dellist(&amp;amp;list, 8);
    Swap(&amp;amp;list, 5, 4);
    printflist(list);
    freelist(&amp;amp;list);
    return 0;
}


&lt;/code&gt;&lt;/pre&gt;
">C语言实现链表基本操作（交换第i个和第j个节点）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/c-yu-yan-lian-biao-ji-ben-cao-zuo-tou-cha-fa-ji-qi-ni-zhi/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-C/C++&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;malloc.h&amp;gt;

typedef struct Node
{
    char data;
	struct Node *next;
}SN;

SN * create(int n)
{
	int i;
	SN *h,*p;
    h = NULL;
    for(i = 0; i&amp;lt;n; i++)
	{
		p=(SN*)malloc(sizeof(SN));
		printf(&amp;quot;请输入第%d个字符：&amp;quot;,i+1);
		p-&amp;gt;data = getchar();
		fflush(stdin);
		p-&amp;gt;next = h;
		h=p;
	}
	return h;
}

SN * def(SN * h)
{ 
    SN * n1, *n2;
	n1 = h;
	n2 = NULL;
	while(n1 != NULL)
	{
		SN *temp;
		temp = n1;
		n1 = n1-&amp;gt;next;
		temp-&amp;gt;next = n2;
		n2 = temp;
	}
	h = n2;
	return h;
}
void visit(SN * h)
{ 
	while(h != NULL)
	{
		printf(&amp;quot;%c&amp;quot;, h-&amp;gt;data);
		h = h-&amp;gt;next;
	}
	printf(&amp;quot;\n&amp;quot;);
}

void freelist(SN *h)
{
    SN *temp = h;
	SN *del;
	while (temp != NULL) {
        del = temp;
        temp = temp-&amp;gt;next;
        free(del);
    }
}

int main() 
{
	int n;
	SN *h;
	printf(&amp;quot;请输入字符个数：\n&amp;quot;);
	scanf(&amp;quot;%d&amp;quot;, &amp;amp;n);
	fflush(stdin);
	h = create(n);
	printf(&amp;quot;链表创建成功，对其遍历\n&amp;quot;);
    visit(h);
	printf(&amp;quot;链表逆置成功，对其遍历\n&amp;quot;);
	h = def(h);
	visit(h);
	freelist(h);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">C语言链表基本操作（头插法及其逆置）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/ji-qi-xue-xi-knn/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math
import numpy#导入两个库

def knn(c):#定义knn函数
    k_a = 0
    k_b = 0
    distance_a = []#定义a和c的距离列表
    distance_b = []#定义b和c的距离列表
    distance = []#所有数据距离列表
    for i in range(0, len(a)):#a的每个数据和c的每个数据的距离
        distance_a.append(math.sqrt(numpy.square(a[i][0] - c[0]) + numpy.square(a[i][1] - c[1])))
    for i in range(0, len(b)):#b的每个数据和c的每个数据的距离
        distance_b.append(math.sqrt(numpy.square(b[i][0] - c[0]) + numpy.square(b[i][1] - c[1])))
    distance = distance_a + distance_b
    distance.sort()#排序距离
    k = int(len(distance) / 2) + 1#取k的值
    for i in range(k):
        if distance_a.count(distance[i]) != 0:#判断该距离是否是a和c的距离
            k_a = k_a + 1
        if distance_b.count(distance[i]) != 0:#判断该距离是否是b和c的距离
            k_b = k_b + 1
    if k_a &amp;gt; k_b:#判断c的数据和哪个类别接近
        print(&amp;quot;你属于肥胖身材&amp;quot;)
    else:
        print(&amp;quot;你属于标准身材&amp;quot;)


a = [[150, 60], [152, 65], [154, 68], [156, 70], [158, 72]]#类别a
b = [[150, 49.5], [152, 50.8], [154, 52.2], [156, 53.5], [158, 54.9]]#类别b
c = []  #判断类别c
print(&amp;quot;输入身高体重&amp;quot;)
for i in range(2):#输入c
    num = int(input())
    c.append(num)
knn(c)#调用函数knn

&lt;/code&gt;&lt;/pre&gt;
">机器学习-knn</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://sakuratears.cn/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>


<script src="/media/js/cool.js"></script>



<script src="https://cdn.jsdelivr.net/gh/lete114/CDN/Sum/sakura.js"></script>


</html>